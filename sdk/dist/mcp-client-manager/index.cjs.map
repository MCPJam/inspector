{"version":3,"sources":["../../mcp-client-manager/index.ts","../../mcp-client-manager/tool-converters.ts"],"sourcesContent":["import { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { ClientOptions } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport {\n  getDefaultEnvironment,\n  StdioClientTransport,\n} from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type { StreamableHTTPClientTransportOptions } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport { DEFAULT_REQUEST_TIMEOUT_MSEC } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type { RequestOptions } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport {\n  CallToolResultSchema,\n  ElicitRequestSchema,\n  ResourceListChangedNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  PromptListChangedNotificationSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type {\n  ElicitRequest,\n  ElicitResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport {\n  convertMCPToolsToVercelTools,\n  type ConvertedToolSet,\n  type ToolSchemaOverrides,\n} from \"./tool-converters\";\nimport type { ToolCallOptions, ToolSet } from \"ai\";\ntype ClientCapabilityOptions = NonNullable<ClientOptions[\"capabilities\"]>;\n\ntype BaseServerConfig = {\n  capabilities?: ClientCapabilityOptions;\n  timeout?: number;\n  version?: string;\n  onError?: (error: unknown) => void;\n};\n\ntype StdioServerConfig = BaseServerConfig & {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n\n  url?: never;\n  requestInit?: never;\n  eventSourceInit?: never;\n  authProvider?: never;\n  reconnectionOptions?: never;\n  sessionId?: never;\n  preferSSE?: never;\n};\n\ntype HttpServerConfig = BaseServerConfig & {\n  url: URL;\n  requestInit?: StreamableHTTPClientTransportOptions[\"requestInit\"];\n  eventSourceInit?: SSEClientTransportOptions[\"eventSourceInit\"];\n  authProvider?: StreamableHTTPClientTransportOptions[\"authProvider\"];\n  reconnectionOptions?: StreamableHTTPClientTransportOptions[\"reconnectionOptions\"];\n  sessionId?: StreamableHTTPClientTransportOptions[\"sessionId\"];\n  preferSSE?: boolean;\n\n  command?: never;\n  args?: never;\n  env?: never;\n};\n\nexport type MCPServerConfig = StdioServerConfig | HttpServerConfig;\n\nexport type MCPClientManagerConfig = Record<string, MCPServerConfig>;\n\ntype NotificationSchema = Parameters<Client[\"setNotificationHandler\"]>[0];\ntype NotificationHandler = Parameters<Client[\"setNotificationHandler\"]>[1];\n\ninterface ManagedClientState {\n  config: MCPServerConfig;\n  timeout: number;\n  client?: Client;\n  transport?: Transport;\n  promise?: Promise<Client>;\n}\n\n// Pending state is tracked inside ManagedClientState.promise\n\ntype ClientRequestOptions = RequestOptions;\ntype CallToolOptions = RequestOptions;\n\ntype ListResourcesParams = Parameters<Client[\"listResources\"]>[0];\ntype ListResourceTemplatesParams = Parameters<\n  Client[\"listResourceTemplates\"]\n>[0];\ntype ReadResourceParams = Parameters<Client[\"readResource\"]>[0];\ntype SubscribeResourceParams = Parameters<Client[\"subscribeResource\"]>[0];\ntype UnsubscribeResourceParams = Parameters<Client[\"unsubscribeResource\"]>[0];\ntype ListPromptsParams = Parameters<Client[\"listPrompts\"]>[0];\ntype GetPromptParams = Parameters<Client[\"getPrompt\"]>[0];\ntype ListToolsResult = Awaited<ReturnType<Client[\"listTools\"]>>;\n\nexport type MCPConnectionStatus = \"connected\" | \"connecting\" | \"disconnected\";\ntype ServerSummary = {\n  id: string;\n  status: MCPConnectionStatus;\n  config?: MCPServerConfig;\n};\n\nexport type ExecuteToolArguments = Record<string, unknown>;\nexport type ElicitationHandler = (\n  params: ElicitRequest[\"params\"],\n) => Promise<ElicitResult> | ElicitResult;\n\nexport class MCPClientManager {\n  private readonly clientStates = new Map<string, ManagedClientState>();\n  private readonly notificationHandlers = new Map<\n    string,\n    Map<NotificationSchema, Set<NotificationHandler>>\n  >();\n  private readonly elicitationHandlers = new Map<string, ElicitationHandler>();\n  private readonly toolsMetadataCache = new Map<string, Map<string, any>>();\n  private readonly defaultClientVersion: string;\n  private readonly defaultCapabilities: ClientCapabilityOptions;\n  private readonly defaultTimeout: number;\n  // Global elicitation callback support (used by streaming chat endpoint)\n  private elicitationCallback?: (request: {\n    requestId: string;\n    message: string;\n    schema: unknown;\n  }) => Promise<ElicitResult> | ElicitResult;\n  private readonly pendingElicitations = new Map<\n    string,\n    {\n      resolve: (value: ElicitResult) => void;\n      reject: (error: unknown) => void;\n    }\n  >();\n\n  constructor(\n    servers: MCPClientManagerConfig = {},\n    options: {\n      defaultClientVersion?: string;\n      defaultCapabilities?: ClientCapabilityOptions;\n      defaultTimeout?: number;\n    } = {},\n  ) {\n    this.defaultClientVersion = options.defaultClientVersion ?? \"1.0.0\";\n    this.defaultCapabilities = { ...(options.defaultCapabilities ?? {}) };\n    this.defaultTimeout =\n      options.defaultTimeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;\n\n    for (const [id, config] of Object.entries(servers)) {\n      void this.connectToServer(id, config);\n    }\n  }\n\n  listServers(): string[] {\n    return Array.from(this.clientStates.keys());\n  }\n\n  hasServer(serverId: string): boolean {\n    return this.clientStates.has(serverId);\n  }\n\n  getServerSummaries(): ServerSummary[] {\n    return Array.from(this.clientStates.entries()).map(([serverId, state]) => ({\n      id: serverId,\n      status: this.resolveConnectionStatus(state),\n      config: state.config,\n    }));\n  }\n\n  getConnectionStatus(serverId: string): MCPConnectionStatus {\n    return this.resolveConnectionStatus(this.clientStates.get(serverId));\n  }\n\n  getServerConfig(serverId: string): MCPServerConfig | undefined {\n    return this.clientStates.get(serverId)?.config;\n  }\n\n  async connectToServer(\n    serverId: string,\n    config: MCPServerConfig,\n  ): Promise<Client> {\n    if (this.clientStates.has(serverId)) {\n      throw new Error(`MCP server \"${serverId}\" is already connected.`);\n    }\n    const timeout = this.getTimeout(config);\n    const state = this.clientStates.get(serverId) ?? {\n      config,\n      timeout,\n    };\n    // Update config/timeout on every call\n    state.config = config;\n    state.timeout = timeout;\n    // If already connected, return the client\n    if (state.client) {\n      this.clientStates.set(serverId, state);\n      return state.client;\n    }\n    // If connection is in-flight, reuse the promise\n    if (state.promise) {\n      this.clientStates.set(serverId, state);\n      return state.promise;\n    }\n\n    const connectionPromise = (async () => {\n      const client = new Client(\n        {\n          name: serverId,\n          version: config.version ?? this.defaultClientVersion,\n        },\n        {\n          capabilities: this.buildCapabilities(config),\n        },\n      );\n\n      this.applyNotificationHandlers(serverId, client);\n      this.applyElicitationHandler(serverId, client);\n\n      if (config.onError) {\n        client.onerror = (error) => {\n          config.onError?.(error);\n        };\n      }\n\n      client.onclose = () => {\n        this.resetState(serverId);\n      };\n\n      let transport: Transport;\n      if (this.isStdioConfig(config)) {\n        transport = await this.connectViaStdio(client, config, timeout);\n      } else {\n        transport = await this.connectViaHttp(\n          serverId,\n          client,\n          config,\n          timeout,\n        );\n      }\n\n      state.client = client;\n      state.transport = transport;\n      // clear pending\n      state.promise = undefined;\n      this.clientStates.set(serverId, state);\n\n      return client;\n    })().catch((error) => {\n      // Clear pending but keep config so the server remains registered\n      state.promise = undefined;\n      state.client = undefined;\n      state.transport = undefined;\n      this.clientStates.set(serverId, state);\n      throw error;\n    });\n\n    state.promise = connectionPromise;\n    this.clientStates.set(serverId, state);\n    return connectionPromise;\n  }\n\n  async disconnectServer(serverId: string): Promise<void> {\n    const client = this.getClientById(serverId);\n    try {\n      await client.close();\n    } finally {\n      if (client.transport) {\n        await this.safeCloseTransport(client.transport);\n      }\n      this.resetState(serverId);\n    }\n  }\n\n  removeServer(serverId: string): void {\n    this.resetState(serverId);\n    this.notificationHandlers.delete(serverId);\n    this.elicitationHandlers.delete(serverId);\n  }\n\n  async disconnectAllServers(): Promise<void> {\n    const serverIds = this.listServers();\n    await Promise.all(\n      serverIds.map((serverId) => this.disconnectServer(serverId)),\n    );\n\n    for (const serverId of serverIds) {\n      this.resetState(serverId);\n      this.notificationHandlers.delete(serverId);\n      this.elicitationHandlers.delete(serverId);\n    }\n  }\n\n  async listTools(\n    serverId: string,\n    params?: Parameters<Client[\"listTools\"]>[0],\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    try {\n      const result = await client.listTools(\n        params,\n        this.withTimeout(serverId, options),\n      );\n\n      const metadataMap = new Map<string, any>();\n      for (const tool of result.tools) {\n        if (tool._meta) {\n          metadataMap.set(tool.name, tool._meta);\n        }\n      }\n      this.toolsMetadataCache.set(serverId, metadataMap);\n\n      return result;\n    } catch (error) {\n      if (this.isMethodUnavailableError(error, \"tools/list\")) {\n        this.toolsMetadataCache.set(serverId, new Map());\n        return { tools: [] } as Awaited<ReturnType<Client[\"listTools\"]>>;\n      }\n      throw error;\n    }\n  }\n\n  async getTools(serverIds?: string[]): Promise<ListToolsResult> {\n    const targetServerIds =\n      serverIds && serverIds.length > 0 ? serverIds : this.listServers();\n\n    const toolLists = await Promise.all(\n      targetServerIds.map(async (serverId) => {\n        await this.ensureConnected(serverId);\n        const client = this.getClientById(serverId);\n        const result = await client.listTools(\n          undefined,\n          this.withTimeout(serverId),\n        );\n\n        const metadataMap = new Map<string, any>();\n        for (const tool of result.tools) {\n          if (tool._meta) {\n            metadataMap.set(tool.name, tool._meta);\n          }\n        }\n        this.toolsMetadataCache.set(serverId, metadataMap);\n\n        return result.tools;\n      }),\n    );\n    return { tools: toolLists.flat() } as ListToolsResult;\n  }\n\n  getAllToolsMetadata(serverId: string): Record<string, Record<string, any>> {\n    const metadataMap = this.toolsMetadataCache.get(serverId);\n    return metadataMap ? Object.fromEntries(metadataMap) : {};\n  }\n\n  pingServer(serverId: string, options?: RequestOptions) {\n    const client = this.getClientById(serverId);\n    try {\n      client.ping(options);\n    } catch (error) {\n      throw new Error(\n        `Failed to ping MCP server \"${serverId}\": ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      );\n    }\n  }\n\n  async getToolsForAiSdk(\n    serverIds?: string[] | string,\n    options: { schemas?: ToolSchemaOverrides | \"automatic\" } = {},\n  ): Promise<ToolSet> {\n    const ids = Array.isArray(serverIds)\n      ? serverIds\n      : serverIds\n        ? [serverIds]\n        : this.listServers();\n\n    const loadForServer = async (id: string): Promise<ToolSet> => {\n      await this.ensureConnected(id);\n      const listToolsResult = await this.listTools(id);\n      return convertMCPToolsToVercelTools(listToolsResult, {\n        schemas: options.schemas,\n        callTool: async ({ name, args, options: callOptions }) => {\n          const requestOptions = callOptions?.abortSignal\n            ? { signal: callOptions.abortSignal }\n            : undefined;\n          const result = await this.executeTool(\n            id,\n            name,\n            (args ?? {}) as ExecuteToolArguments,\n            requestOptions,\n          );\n          return CallToolResultSchema.parse(result);\n        },\n      });\n    };\n\n    const perServerTools = await Promise.all(\n      ids.map(async (id) => {\n        try {\n          const tools = await loadForServer(id);\n          // Attach server id metadata to each tool object for downstream extraction\n          for (const [name, tool] of Object.entries(tools)) {\n            (tool as any)._serverId = id;\n          }\n          return tools;\n        } catch (error) {\n          if (this.isMethodUnavailableError(error, \"tools/list\")) {\n            return {} as ToolSet;\n          }\n          throw error;\n        }\n      }),\n    );\n\n    // Flatten into a single ToolSet (last-in wins for name collisions)\n    const flattened: ToolSet = {};\n    for (const toolset of perServerTools) {\n      for (const [name, tool] of Object.entries(toolset)) {\n        flattened[name] = tool;\n      }\n    }\n\n    return flattened;\n  }\n\n  async executeTool(\n    serverId: string,\n    toolName: string,\n    args: ExecuteToolArguments = {},\n    options?: CallToolOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    return client.callTool(\n      {\n        name: toolName,\n        arguments: args,\n      },\n      CallToolResultSchema,\n      this.withTimeout(serverId, options),\n    );\n  }\n\n  async listResources(\n    serverId: string,\n    params?: ListResourcesParams,\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    try {\n      return await client.listResources(\n        params,\n        this.withTimeout(serverId, options),\n      );\n    } catch (error) {\n      if (this.isMethodUnavailableError(error, \"resources/list\")) {\n        return {\n          resources: [],\n        } as Awaited<ReturnType<Client[\"listResources\"]>>;\n      }\n      throw error;\n    }\n  }\n\n  async readResource(\n    serverId: string,\n    params: ReadResourceParams,\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    return client.readResource(params, this.withTimeout(serverId, options));\n  }\n\n  async subscribeResource(\n    serverId: string,\n    params: SubscribeResourceParams,\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    return client.subscribeResource(\n      params,\n      this.withTimeout(serverId, options),\n    );\n  }\n\n  async unsubscribeResource(\n    serverId: string,\n    params: UnsubscribeResourceParams,\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    return client.unsubscribeResource(\n      params,\n      this.withTimeout(serverId, options),\n    );\n  }\n\n  async listResourceTemplates(\n    serverId: string,\n    params?: ListResourceTemplatesParams,\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    return client.listResourceTemplates(\n      params,\n      this.withTimeout(serverId, options),\n    );\n  }\n\n  async listPrompts(\n    serverId: string,\n    params?: ListPromptsParams,\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    try {\n      return await client.listPrompts(\n        params,\n        this.withTimeout(serverId, options),\n      );\n    } catch (error) {\n      if (this.isMethodUnavailableError(error, \"prompts/list\")) {\n        return {\n          prompts: [],\n        } as Awaited<ReturnType<Client[\"listPrompts\"]>>;\n      }\n      throw error;\n    }\n  }\n\n  async getPrompt(\n    serverId: string,\n    params: GetPromptParams,\n    options?: ClientRequestOptions,\n  ) {\n    await this.ensureConnected(serverId);\n    const client = this.getClientById(serverId);\n    return client.getPrompt(params, this.withTimeout(serverId, options));\n  }\n\n  getSessionIdByServer(serverId: string): string | undefined {\n    const state = this.clientStates.get(serverId);\n    if (!state?.transport) {\n      throw new Error(`Unknown MCP server \"${serverId}\".`);\n    }\n    if (state.transport instanceof StreamableHTTPClientTransport) {\n      return state.transport.sessionId;\n    }\n    throw new Error(\n      `Server \"${serverId}\" must be Streamable HTTP to get the session ID.`,\n    );\n  }\n\n  addNotificationHandler(\n    serverId: string,\n    schema: NotificationSchema,\n    handler: NotificationHandler,\n  ): void {\n    const serverHandlers = this.notificationHandlers.get(serverId) ?? new Map();\n    const handlersForSchema =\n      serverHandlers.get(schema) ?? new Set<NotificationHandler>();\n    handlersForSchema.add(handler);\n    serverHandlers.set(schema, handlersForSchema);\n    this.notificationHandlers.set(serverId, serverHandlers);\n\n    const client = this.clientStates.get(serverId)?.client;\n    if (client) {\n      client.setNotificationHandler(\n        schema,\n        this.createNotificationDispatcher(serverId, schema),\n      );\n    }\n  }\n\n  onResourceListChanged(serverId: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(\n      serverId,\n      ResourceListChangedNotificationSchema,\n      handler,\n    );\n  }\n\n  onResourceUpdated(serverId: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(\n      serverId,\n      ResourceUpdatedNotificationSchema,\n      handler,\n    );\n  }\n\n  onPromptListChanged(serverId: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(\n      serverId,\n      PromptListChangedNotificationSchema,\n      handler,\n    );\n  }\n\n  getClient(serverId: string): Client | undefined {\n    return this.clientStates.get(serverId)?.client;\n  }\n\n  setElicitationHandler(serverId: string, handler: ElicitationHandler): void {\n    if (!this.clientStates.has(serverId)) {\n      throw new Error(`Unknown MCP server \"${serverId}\".`);\n    }\n\n    this.elicitationHandlers.set(serverId, handler);\n\n    const client = this.clientStates.get(serverId)?.client;\n    if (client) {\n      this.applyElicitationHandler(serverId, client);\n    }\n  }\n\n  clearElicitationHandler(serverId: string): void {\n    this.elicitationHandlers.delete(serverId);\n    const client = this.clientStates.get(serverId)?.client;\n    if (client) {\n      client.removeRequestHandler(\"elicitation/create\");\n    }\n  }\n\n  // Global elicitation callback API (no serverId required)\n  setElicitationCallback(\n    callback: (request: {\n      requestId: string;\n      message: string;\n      schema: unknown;\n    }) => Promise<ElicitResult> | ElicitResult,\n  ): void {\n    this.elicitationCallback = callback;\n    // Apply to all connected clients that don't have a server-specific handler\n    for (const [serverId, state] of this.clientStates.entries()) {\n      const client = state.client;\n      if (!client) continue;\n      if (this.elicitationHandlers.has(serverId)) {\n        // Respect server-specific handler\n        this.applyElicitationHandler(serverId, client);\n      } else {\n        this.applyElicitationHandler(serverId, client);\n      }\n    }\n  }\n\n  clearElicitationCallback(): void {\n    this.elicitationCallback = undefined;\n    // Reconfigure clients: keep server-specific handlers, otherwise remove\n    for (const [serverId, state] of this.clientStates.entries()) {\n      const client = state.client;\n      if (!client) continue;\n      if (this.elicitationHandlers.has(serverId)) {\n        this.applyElicitationHandler(serverId, client);\n      } else {\n        client.removeRequestHandler(\"elicitation/create\");\n      }\n    }\n  }\n\n  // Expose the pending elicitation map so callers can add resolvers\n  getPendingElicitations(): Map<\n    string,\n    {\n      resolve: (value: ElicitResult) => void;\n      reject: (error: unknown) => void;\n    }\n  > {\n    return this.pendingElicitations;\n  }\n\n  // Helper to resolve a pending elicitation from outside\n  respondToElicitation(requestId: string, response: ElicitResult): boolean {\n    const pending = this.pendingElicitations.get(requestId);\n    if (!pending) return false;\n    try {\n      pending.resolve(response);\n      return true;\n    } finally {\n      this.pendingElicitations.delete(requestId);\n    }\n  }\n\n  private async connectViaStdio(\n    client: Client,\n    config: StdioServerConfig,\n    timeout: number,\n  ): Promise<Transport> {\n    const transport = new StdioClientTransport({\n      command: config.command,\n      args: config.args,\n      env: { ...getDefaultEnvironment(), ...(config.env ?? {}) },\n    });\n    await client.connect(transport, { timeout });\n    return transport;\n  }\n\n  private async connectViaHttp(\n    serverId: string,\n    client: Client,\n    config: HttpServerConfig,\n    timeout: number,\n  ): Promise<Transport> {\n    const preferSSE = config.preferSSE ?? config.url.pathname.endsWith(\"/sse\");\n    let streamableError: unknown;\n\n    if (!preferSSE) {\n      const streamableTransport = new StreamableHTTPClientTransport(\n        config.url,\n        {\n          requestInit: config.requestInit,\n          reconnectionOptions: config.reconnectionOptions,\n          authProvider: config.authProvider,\n          sessionId: config.sessionId,\n        },\n      );\n\n      try {\n        await client.connect(streamableTransport, {\n          timeout: Math.min(timeout, 3000),\n        });\n        return streamableTransport;\n      } catch (error) {\n        streamableError = error;\n        await this.safeCloseTransport(streamableTransport);\n      }\n    }\n\n    const sseTransport = new SSEClientTransport(config.url, {\n      requestInit: config.requestInit,\n      eventSourceInit: config.eventSourceInit,\n      authProvider: config.authProvider,\n    });\n\n    try {\n      await client.connect(sseTransport, { timeout });\n      return sseTransport;\n    } catch (error) {\n      await this.safeCloseTransport(sseTransport);\n      const streamableMessage = streamableError\n        ? ` Streamable HTTP error: ${this.formatError(streamableError)}.`\n        : \"\";\n      throw new Error(\n        `Failed to connect to MCP server \"${serverId}\" using HTTP transports.${streamableMessage} SSE error: ${this.formatError(error)}.`,\n      );\n    }\n  }\n\n  private async safeCloseTransport(transport: Transport): Promise<void> {\n    try {\n      await transport.close();\n    } catch {\n      // Ignore close errors during cleanup.\n    }\n  }\n\n  private applyNotificationHandlers(serverId: string, client: Client): void {\n    const serverHandlers = this.notificationHandlers.get(serverId);\n    if (!serverHandlers) {\n      return;\n    }\n\n    for (const [schema] of serverHandlers) {\n      client.setNotificationHandler(\n        schema,\n        this.createNotificationDispatcher(serverId, schema),\n      );\n    }\n  }\n\n  private createNotificationDispatcher(\n    serverId: string,\n    schema: NotificationSchema,\n  ): NotificationHandler {\n    return (notification) => {\n      const serverHandlers = this.notificationHandlers.get(serverId);\n      const handlersForSchema = serverHandlers?.get(schema);\n      if (!handlersForSchema || handlersForSchema.size === 0) {\n        return;\n      }\n      for (const handler of handlersForSchema) {\n        try {\n          handler(notification);\n        } catch {\n          // Swallow individual handler errors to avoid breaking other listeners.\n        }\n      }\n    };\n  }\n\n  private applyElicitationHandler(serverId: string, client: Client): void {\n    const serverSpecific = this.elicitationHandlers.get(serverId);\n    if (serverSpecific) {\n      client.setRequestHandler(ElicitRequestSchema, async (request) =>\n        serverSpecific(request.params),\n      );\n      return;\n    }\n\n    if (this.elicitationCallback) {\n      client.setRequestHandler(ElicitRequestSchema, async (request) => {\n        const reqId = `elicit_${Date.now()}_${Math.random()\n          .toString(36)\n          .slice(2, 9)}`;\n        return await this.elicitationCallback!({\n          requestId: reqId,\n          message: (request.params as any)?.message,\n          schema:\n            (request.params as any)?.requestedSchema ??\n            (request.params as any)?.schema,\n        });\n      });\n      return;\n    }\n  }\n\n  private async ensureConnected(serverId: string): Promise<void> {\n    const state = this.clientStates.get(serverId);\n    if (state?.client) {\n      return;\n    }\n\n    if (!state) {\n      throw new Error(`Unknown MCP server \"${serverId}\".`);\n    }\n    if (state.promise) {\n      await state.promise;\n      return;\n    }\n    await this.connectToServer(serverId, state.config);\n  }\n\n  private resetState(serverId: string): void {\n    this.clientStates.delete(serverId);\n    this.toolsMetadataCache.delete(serverId);\n  }\n\n  private resolveConnectionStatus(\n    state: ManagedClientState | undefined,\n  ): MCPConnectionStatus {\n    if (!state) {\n      return \"disconnected\";\n    }\n    if (state.client) {\n      return \"connected\";\n    }\n    if (state.promise) {\n      return \"connecting\";\n    }\n    return \"disconnected\";\n  }\n\n  private withTimeout(\n    serverId: string,\n    options?: RequestOptions,\n  ): RequestOptions {\n    const state = this.clientStates.get(serverId);\n    const timeout =\n      state?.timeout ??\n      (state ? this.getTimeout(state.config) : this.defaultTimeout);\n\n    if (!options) {\n      return { timeout };\n    }\n\n    if (options.timeout === undefined) {\n      return { ...options, timeout };\n    }\n\n    return options;\n  }\n\n  private buildCapabilities(config: MCPServerConfig): ClientCapabilityOptions {\n    const capabilities: ClientCapabilityOptions = {\n      ...this.defaultCapabilities,\n      ...(config.capabilities ?? {}),\n    };\n\n    if (!capabilities.elicitation) {\n      capabilities.elicitation = {};\n    }\n\n    return capabilities;\n  }\n\n  private formatError(error: unknown): string {\n    if (error instanceof Error) {\n      return error.message;\n    }\n\n    try {\n      return JSON.stringify(error);\n    } catch {\n      return String(error);\n    }\n  }\n\n  private isMethodUnavailableError(error: unknown, method: string): boolean {\n    if (!(error instanceof Error)) {\n      return false;\n    }\n    const message = error.message.toLowerCase();\n    const methodTokens = new Set<string>();\n    const pushToken = (token: string) => {\n      if (token) {\n        methodTokens.add(token.toLowerCase());\n      }\n    };\n\n    pushToken(method);\n    for (const part of method.split(/[\\/:._-]/)) {\n      pushToken(part);\n    }\n    const indicators = [\n      \"method not found\",\n      \"not implemented\",\n      \"unsupported\",\n      \"does not support\",\n      \"unimplemented\",\n    ];\n    const indicatorMatch = indicators.some((indicator) =>\n      message.includes(indicator),\n    );\n    if (!indicatorMatch) {\n      return false;\n    }\n\n    if (Array.from(methodTokens).some((token) => message.includes(token))) {\n      return true;\n    }\n\n    return true;\n  }\n\n  private getTimeout(config: MCPServerConfig): number {\n    return config.timeout ?? this.defaultTimeout;\n  }\n\n  private isStdioConfig(config: MCPServerConfig): config is StdioServerConfig {\n    return \"command\" in config;\n  }\n\n  private getClientById(serverId: string): Client {\n    const state = this.clientStates.get(serverId);\n    if (!state?.client) {\n      throw new Error(`MCP server \"${serverId}\" is not connected.`);\n    }\n    return state.client;\n  }\n}\n\nexport type MCPPromptListResult = Awaited<\n  ReturnType<MCPClientManager[\"listPrompts\"]>\n>;\nexport type MCPPrompt = MCPPromptListResult[\"prompts\"][number];\nexport type MCPGetPromptResult = Awaited<\n  ReturnType<MCPClientManager[\"getPrompt\"]>\n>;\nexport type MCPResourceListResult = Awaited<\n  ReturnType<MCPClientManager[\"listResources\"]>\n>;\nexport type MCPResource = MCPResourceListResult[\"resources\"][number];\nexport type MCPReadResourceResult = Awaited<\n  ReturnType<MCPClientManager[\"readResource\"]>\n>;\nexport type MCPServerSummary = ServerSummary;\nexport type MCPConvertedToolSet<\n  SCHEMAS extends ToolSchemaOverrides | \"automatic\",\n> = ConvertedToolSet<SCHEMAS>;\nexport type MCPToolSchemaOverrides = ToolSchemaOverrides;\n","import type { JSONSchema7, JSONSchema7Definition } from \"json-schema\";\nimport {\n  CallToolResult,\n  CallToolResultSchema,\n  ListToolsResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport {\n  dynamicTool,\n  jsonSchema,\n  tool as defineTool,\n  type Tool,\n  type ToolCallOptions,\n  ToolSet,\n} from \"ai\";\nimport type { FlexibleSchema } from \"@ai-sdk/provider-utils\";\n\nconst ensureJsonSchemaObject = (schema: unknown): JSONSchema7 => {\n  if (schema && typeof schema === \"object\") {\n    const record = schema as Record<string, unknown>;\n    const base: JSONSchema7 = record.jsonSchema\n      ? ensureJsonSchemaObject(record.jsonSchema)\n      : (record as JSONSchema7);\n\n    // Many MCP tools omit the top-level type; Anthropic requires an object schema.\n    if (!(\"type\" in base) || base.type === undefined) {\n      base.type = \"object\";\n    }\n    if (base.type === \"object\") {\n      base.properties = (base.properties ?? {}) as Record<\n        string,\n        JSONSchema7Definition\n      >;\n      if (base.additionalProperties === undefined) {\n        base.additionalProperties = false;\n      }\n    }\n\n    return base;\n  }\n\n  return {\n    type: \"object\",\n    properties: {},\n    additionalProperties: false,\n  } satisfies JSONSchema7;\n};\n\ntype CallToolExecutor = (params: {\n  name: string;\n  args: unknown;\n  options: ToolCallOptions;\n}) => Promise<CallToolResult>;\n\nexport type ToolSchemaOverrides = Record<\n  string,\n  { inputSchema: FlexibleSchema<unknown> }\n>;\n\nexport type ConvertedToolSet<\n  SCHEMAS extends ToolSchemaOverrides | \"automatic\",\n> = SCHEMAS extends ToolSchemaOverrides\n  ? { [K in keyof SCHEMAS]: Tool }\n  : Record<string, Tool>;\n\ntype ConvertOptions<TOOL_SCHEMAS extends ToolSchemaOverrides | \"automatic\"> = {\n  schemas?: TOOL_SCHEMAS;\n  callTool: CallToolExecutor;\n};\n\nexport async function convertMCPToolsToVercelTools(\n  listToolsResult: ListToolsResult,\n  {\n    schemas = \"automatic\",\n    callTool,\n  }: ConvertOptions<ToolSchemaOverrides | \"automatic\">,\n): Promise<ToolSet> {\n  const tools: ToolSet = {};\n\n  for (const toolDescription of listToolsResult.tools) {\n    const { name, description, inputSchema } = toolDescription;\n\n    const execute = async (args: unknown, options: ToolCallOptions) => {\n      options?.abortSignal?.throwIfAborted?.();\n      const result = await callTool({ name, args, options });\n      return CallToolResultSchema.parse(result);\n    };\n\n    let vercelTool: Tool;\n    if (schemas === \"automatic\") {\n      const normalizedInputSchema = ensureJsonSchemaObject(inputSchema);\n      vercelTool = dynamicTool({\n        description,\n        inputSchema: jsonSchema({\n          type: \"object\",\n          properties: normalizedInputSchema.properties ?? {},\n          additionalProperties:\n            (normalizedInputSchema as any).additionalProperties ?? false,\n        }),\n        execute,\n      });\n    } else {\n      const overrides = schemas;\n      if (!(name in overrides)) {\n        // If overrides are provided, only include tools explicitly listed\n        continue;\n      }\n      vercelTool = defineTool({\n        description,\n        inputSchema: overrides[name].inputSchema,\n        execute,\n      });\n    }\n\n    tools[name] = vercelTool;\n  }\n\n  return tools;\n}\n"],"mappings":"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","names":["import_types","_a","_b","defineTool","_a"]}