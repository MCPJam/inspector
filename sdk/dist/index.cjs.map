{"version":3,"sources":["../index.ts","../mcp-client-manager/index.js"],"sourcesContent":["export * from \"./mcp-client-manager/index.js\";\nexport * as mcpClientManager from \"./mcp-client-manager/index.js\";\n","// index.ts\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport {\n  getDefaultEnvironment,\n  StdioClientTransport,\n} from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport { DEFAULT_REQUEST_TIMEOUT_MSEC } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport {\n  CallToolResultSchema,\n  ElicitRequestSchema,\n  ResourceListChangedNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  PromptListChangedNotificationSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nvar MCPClientManager = class {\n  constructor(servers = {}, options = {}) {\n    this.clientStates = /* @__PURE__ */ new Map();\n    this.pendingConnections = /* @__PURE__ */ new Map();\n    this.serverConfigs = /* @__PURE__ */ new Map();\n    this.notificationHandlers = /* @__PURE__ */ new Map();\n    this.elicitationHandlers = /* @__PURE__ */ new Map();\n    var _a, _b, _c;\n    this.defaultClientVersion =\n      (_a = options.defaultClientVersion) != null ? _a : \"1.0.0\";\n    this.defaultCapabilities = {\n      ...((_b = options.defaultCapabilities) != null ? _b : {}),\n    };\n    this.defaultTimeout =\n      (_c = options.defaultTimeout) != null ? _c : DEFAULT_REQUEST_TIMEOUT_MSEC;\n    for (const [name, config] of Object.entries(servers)) {\n      void this.connectToServer(name, config);\n    }\n  }\n  listServers() {\n    return Array.from(this.serverConfigs.keys());\n  }\n  hasServer(name) {\n    const serverName = this.normalizeName(name);\n    return this.serverConfigs.has(serverName);\n  }\n  async connectToServer(name, config) {\n    const serverName = this.normalizeName(name);\n    this.serverConfigs.set(serverName, config);\n    const timeout = this.getTimeout(config);\n    const existingState = this.clientStates.get(serverName);\n    if (existingState) {\n      existingState.config = config;\n      existingState.timeout = timeout;\n      this.clientStates.set(serverName, existingState);\n      return existingState.client;\n    }\n    const pendingState = this.pendingConnections.get(serverName);\n    if (pendingState) {\n      pendingState.config = config;\n      pendingState.timeout = timeout;\n      return pendingState.promise;\n    }\n    const connectionPromise = (async () => {\n      var _a;\n      const client = new Client(\n        {\n          name: serverName,\n          version:\n            (_a = config.version) != null ? _a : this.defaultClientVersion,\n        },\n        {\n          capabilities: this.buildCapabilities(config),\n        },\n      );\n      this.applyNotificationHandlers(serverName, client);\n      this.applyElicitationHandler(serverName, client);\n      if (config.onError) {\n        client.onerror = (error) => {\n          var _a2;\n          (_a2 = config.onError) == null ? void 0 : _a2.call(config, error);\n        };\n      }\n      client.onclose = () => {\n        this.resetState(serverName, { preserveConfig: true });\n      };\n      let transport;\n      if (this.isStdioConfig(config)) {\n        transport = await this.connectViaStdio(client, config, timeout);\n      } else {\n        transport = await this.connectViaHttp(\n          serverName,\n          client,\n          config,\n          timeout,\n        );\n      }\n      const managedState = {\n        config,\n        client,\n        transport,\n        timeout,\n      };\n      this.clientStates.set(serverName, managedState);\n      this.pendingConnections.delete(serverName);\n      return client;\n    })().catch((error) => {\n      this.pendingConnections.delete(serverName);\n      this.clientStates.delete(serverName);\n      throw error;\n    });\n    this.pendingConnections.set(serverName, {\n      config,\n      timeout,\n      promise: connectionPromise,\n    });\n    return connectionPromise;\n  }\n  async disconnectServer(name) {\n    const serverName = this.normalizeName(name);\n    const pending = this.pendingConnections.get(serverName);\n    if (pending) {\n      try {\n        await pending.promise;\n      } catch {}\n    }\n    const state = this.clientStates.get(serverName);\n    if (!state) {\n      this.resetState(serverName, { preserveConfig: true });\n      return;\n    }\n    try {\n      await state.client.close();\n    } finally {\n      await this.safeCloseTransport(state.transport);\n      this.resetState(serverName, { preserveConfig: true });\n    }\n  }\n  async disconnectAllServers() {\n    const serverNames = this.listServers();\n    await Promise.all(serverNames.map((name) => this.disconnectServer(name)));\n    for (const name of serverNames) {\n      const serverName = this.normalizeName(name);\n      this.resetState(serverName, { preserveConfig: false });\n      this.notificationHandlers.delete(serverName);\n      this.elicitationHandlers.delete(serverName);\n    }\n  }\n  async listTools(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.listTools(params, this.withTimeout(serverName, options));\n  }\n  async getTools(names) {\n    const targetNames =\n      names && names.length > 0\n        ? names.map((name) => this.normalizeName(name))\n        : this.listServers();\n    const uniqueNames = Array.from(new Set(targetNames));\n    const toolLists = await Promise.all(\n      uniqueNames.map(async (serverName) => {\n        await this.ensureConnected(serverName);\n        const client = this.getClientByName(serverName);\n        const result = await client.listTools(\n          void 0,\n          this.withTimeout(serverName),\n        );\n        return result.tools;\n      }),\n    );\n    return { tools: toolLists.flat() };\n  }\n  async executeTool(name, toolName, args = {}, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.callTool(\n      {\n        name: toolName,\n        arguments: args,\n      },\n      CallToolResultSchema,\n      this.withTimeout(serverName, options),\n    );\n  }\n  async listResources(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.listResources(params, this.withTimeout(serverName, options));\n  }\n  async readResource(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.readResource(params, this.withTimeout(serverName, options));\n  }\n  async subscribeResource(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.subscribeResource(\n      params,\n      this.withTimeout(serverName, options),\n    );\n  }\n  async unsubscribeResource(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.unsubscribeResource(\n      params,\n      this.withTimeout(serverName, options),\n    );\n  }\n  async listResourceTemplates(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.listResourceTemplates(\n      params,\n      this.withTimeout(serverName, options),\n    );\n  }\n  async listPrompts(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.listPrompts(params, this.withTimeout(serverName, options));\n  }\n  async getPrompt(name, params, options) {\n    const serverName = this.normalizeName(name);\n    await this.ensureConnected(serverName);\n    const client = this.getClientByName(serverName);\n    return client.getPrompt(params, this.withTimeout(serverName, options));\n  }\n  getSessionIdByServer(name) {\n    const state = this.clientStates.get(this.normalizeName(name));\n    if (!(state == null ? void 0 : state.transport)) {\n      throw new Error(`Unknown MCP server \"${name}\".`);\n    }\n    if (state.transport instanceof StreamableHTTPClientTransport) {\n      return state.transport.sessionId;\n    }\n    throw new Error(\n      `Server \"${name}\" must be Streamable HTTP to get the session ID.`,\n    );\n  }\n  addNotificationHandler(name, schema, handler) {\n    var _a, _b;\n    const serverName = this.normalizeName(name);\n    const handlers =\n      (_a = this.notificationHandlers.get(serverName)) != null ? _a : [];\n    handlers.push({ schema, handler });\n    this.notificationHandlers.set(serverName, handlers);\n    const client =\n      (_b = this.clientStates.get(serverName)) == null ? void 0 : _b.client;\n    if (client) {\n      client.setNotificationHandler(schema, handler);\n    }\n  }\n  onResourceListChanged(name, handler) {\n    this.addNotificationHandler(\n      name,\n      ResourceListChangedNotificationSchema,\n      handler,\n    );\n  }\n  onResourceUpdated(name, handler) {\n    this.addNotificationHandler(\n      name,\n      ResourceUpdatedNotificationSchema,\n      handler,\n    );\n  }\n  onPromptListChanged(name, handler) {\n    this.addNotificationHandler(\n      name,\n      PromptListChangedNotificationSchema,\n      handler,\n    );\n  }\n  getClient(name) {\n    var _a;\n    return (_a = this.clientStates.get(this.normalizeName(name))) == null\n      ? void 0\n      : _a.client;\n  }\n  setElicitationHandler(name, handler) {\n    var _a;\n    const serverName = this.normalizeName(name);\n    if (!this.serverConfigs.has(serverName)) {\n      throw new Error(`Unknown MCP server \"${serverName}\".`);\n    }\n    this.elicitationHandlers.set(serverName, handler);\n    const client =\n      (_a = this.clientStates.get(serverName)) == null ? void 0 : _a.client;\n    if (client) {\n      this.applyElicitationHandler(serverName, client);\n    }\n  }\n  clearElicitationHandler(name) {\n    var _a;\n    const serverName = this.normalizeName(name);\n    this.elicitationHandlers.delete(serverName);\n    const client =\n      (_a = this.clientStates.get(serverName)) == null ? void 0 : _a.client;\n    if (client) {\n      client.removeRequestHandler(\"elicitation/create\");\n    }\n  }\n  async connectViaStdio(client, config, timeout) {\n    var _a;\n    const transport = new StdioClientTransport({\n      command: config.command,\n      args: config.args,\n      env: {\n        ...getDefaultEnvironment(),\n        ...((_a = config.env) != null ? _a : {}),\n      },\n    });\n    await client.connect(transport, { timeout });\n    return transport;\n  }\n  async connectViaHttp(serverName, client, config, timeout) {\n    var _a;\n    const preferSSE =\n      (_a = config.preferSSE) != null\n        ? _a\n        : config.url.pathname.endsWith(\"/sse\");\n    let streamableError;\n    if (!preferSSE) {\n      const streamableTransport = new StreamableHTTPClientTransport(\n        config.url,\n        {\n          requestInit: config.requestInit,\n          reconnectionOptions: config.reconnectionOptions,\n          authProvider: config.authProvider,\n          sessionId: config.sessionId,\n        },\n      );\n      try {\n        await client.connect(streamableTransport, {\n          timeout: Math.min(timeout, 3e3),\n        });\n        return streamableTransport;\n      } catch (error) {\n        streamableError = error;\n        await this.safeCloseTransport(streamableTransport);\n      }\n    }\n    const sseTransport = new SSEClientTransport(config.url, {\n      requestInit: config.requestInit,\n      eventSourceInit: config.eventSourceInit,\n      authProvider: config.authProvider,\n    });\n    try {\n      await client.connect(sseTransport, { timeout });\n      return sseTransport;\n    } catch (error) {\n      await this.safeCloseTransport(sseTransport);\n      const streamableMessage = streamableError\n        ? ` Streamable HTTP error: ${this.formatError(streamableError)}.`\n        : \"\";\n      throw new Error(\n        `Failed to connect to MCP server \"${serverName}\" using HTTP transports.${streamableMessage} SSE error: ${this.formatError(error)}.`,\n      );\n    }\n  }\n  async safeCloseTransport(transport) {\n    try {\n      await transport.close();\n    } catch {}\n  }\n  applyNotificationHandlers(serverName, client) {\n    const handlers = this.notificationHandlers.get(serverName);\n    if (!handlers) {\n      return;\n    }\n    for (const { schema, handler } of handlers) {\n      client.setNotificationHandler(schema, handler);\n    }\n  }\n  applyElicitationHandler(serverName, client) {\n    const handler = this.elicitationHandlers.get(serverName);\n    if (!handler) {\n      return;\n    }\n    client.setRequestHandler(ElicitRequestSchema, async (request) =>\n      handler(request.params),\n    );\n  }\n  async ensureConnected(name) {\n    const serverName = this.normalizeName(name);\n    if (this.clientStates.has(serverName)) {\n      return;\n    }\n    const pending = this.pendingConnections.get(serverName);\n    if (pending) {\n      await pending.promise;\n      return;\n    }\n    const config = this.serverConfigs.get(serverName);\n    if (!config) {\n      throw new Error(`Unknown MCP server \"${serverName}\".`);\n    }\n    await this.connectToServer(serverName, config);\n  }\n  resetState(name, options) {\n    const serverName = this.normalizeName(name);\n    this.pendingConnections.delete(serverName);\n    this.clientStates.delete(serverName);\n    if (!options.preserveConfig) {\n      this.serverConfigs.delete(serverName);\n    }\n  }\n  withTimeout(name, options) {\n    var _a;\n    const serverName = this.normalizeName(name);\n    const connectedState = this.clientStates.get(serverName);\n    const serverConfig = this.serverConfigs.get(serverName);\n    const timeout =\n      (_a = connectedState == null ? void 0 : connectedState.timeout) != null\n        ? _a\n        : serverConfig\n          ? this.getTimeout(serverConfig)\n          : this.defaultTimeout;\n    if (!options) {\n      return { timeout };\n    }\n    if (options.timeout === void 0) {\n      return { ...options, timeout };\n    }\n    return options;\n  }\n  buildCapabilities(config) {\n    var _a;\n    const capabilities = {\n      ...this.defaultCapabilities,\n      ...((_a = config.capabilities) != null ? _a : {}),\n    };\n    if (!capabilities.elicitation) {\n      capabilities.elicitation = {};\n    }\n    return capabilities;\n  }\n  formatError(error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n    try {\n      return JSON.stringify(error);\n    } catch {\n      return String(error);\n    }\n  }\n  getTimeout(config) {\n    var _a;\n    return (_a = config.timeout) != null ? _a : this.defaultTimeout;\n  }\n  isStdioConfig(config) {\n    return \"command\" in config;\n  }\n  normalizeName(name) {\n    const normalized = name.trim();\n    if (!normalized) {\n      throw new Error(\"Server name must be a non-empty string.\");\n    }\n    return normalized;\n  }\n  getClientByName(name) {\n    const serverName = this.normalizeName(name);\n    const state = this.clientStates.get(serverName);\n    if (!state) {\n      throw new Error(`MCP server \"${serverName}\" is not connected.`);\n    }\n    return state.client;\n  }\n};\nexport { MCPClientManager };\n//# sourceMappingURL=index.js.map\n"],"mappings":"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","names":[]}