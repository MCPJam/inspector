<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>OpenAI Apps Sandbox Proxy</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100vh;
        width: 100vw;
      }
      body {
        display: flex;
        flex-direction: column;
      }
      * {
        box-sizing: border-box;
      }
      iframe {
        background-color: transparent;
        border: 0px none transparent;
        padding: 0px;
        overflow: hidden;
        flex-grow: 1;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <script>
      /**
       * OpenAI Apps Sandbox Proxy
       *
       * Double-iframe architecture for ChatGPT parity:
       * Inspector Host -> This Proxy (different origin) -> Widget (srcdoc)
       *
       * Protocol (OpenAI-native, no JSON-RPC):
       * 1. Host sends { type: 'openai:load-widget', html, sandbox, csp }
       * 2. Proxy injects CSP, loads HTML via srcdoc
       * 3. All openai:* messages forwarded transparently
       *
       * Unlike the MCP Apps sandbox-proxy.html which uses JSON-RPC 2.0,
       * this proxy speaks the native OpenAI widget protocol.
       */

      /**
       * Sanitize a domain/origin value for CSP
       * Prevents injection attacks via malicious domain values
       * @param {string} domain - Domain to sanitize
       * @returns {string} Sanitized domain
       */
      function sanitizeDomain(domain) {
        if (typeof domain !== "string") return "";
        // Remove characters that could break out of CSP or HTML attributes
        return domain.replace(/['"<>;]/g, "").trim();
      }

      /**
       * Build CSP string from metadata
       * @param {Object} csp - CSP metadata with connectDomains and resourceDomains
       * @returns {string} CSP policy string
       */
      function buildCSP(csp) {
        // If no CSP declared, use restrictive defaults
        // Note: 'self' doesn't work in srcdoc iframes (refers to about:srcdoc)
        // So we use 'unsafe-inline' for scripts/styles since all widget code is inline
        //
        // Images and media allow https: because:
        // 1. They can't execute code (safe)
        // 2. Widgets commonly load images from various CDNs/APIs
        // 3. This matches the old single-iframe CSP behavior
        if (!csp) {
          return [
            "default-src 'none'",
            "script-src 'unsafe-inline'",
            "style-src 'unsafe-inline'",
            "img-src data: blob: https:",
            "media-src data: blob: https:",
            "font-src data: https:",
            "connect-src 'none'",
            "frame-src 'none'",
            "object-src 'none'",
            // Allow any base-uri - widgets need this to set their origin for URL resolution
            // This is safe in the sandboxed srcdoc context
          ].join("; ");
        }

        // Build CSP from declared domains
        const connectDomains = (csp.connectDomains || [])
          .map(sanitizeDomain)
          .filter(Boolean);
        const resourceDomains = (csp.resourceDomains || [])
          .map(sanitizeDomain)
          .filter(Boolean);

        // connect-src: Only allow declared domains, or 'none' if empty
        const connectSrc =
          connectDomains.length > 0 ? connectDomains.join(" ") : "'none'";

        // Script/style sources: only declared domains (security-sensitive)
        const scriptStyleSrc =
          resourceDomains.length > 0
            ? ["data:", "blob:", ...resourceDomains].join(" ")
            : "data: blob:";

        // Image/media/font sources: allow https: (safe, can't execute code)
        // Plus any declared domains for consistency
        const mediaSrc =
          resourceDomains.length > 0
            ? ["data:", "blob:", "https:", ...resourceDomains].join(" ")
            : "data: blob: https:";

        return [
          "default-src 'none'",
          "script-src 'unsafe-inline' " + scriptStyleSrc,
          "style-src 'unsafe-inline' " + scriptStyleSrc,
          "img-src " + mediaSrc,
          "media-src " + mediaSrc,
          "font-src " + mediaSrc,
          "connect-src " + connectSrc,
          "frame-src 'none'",
          "object-src 'none'",
          // No base-uri restriction - widgets need this for URL resolution
        ].join("; ");
      }

      /**
       * Inject CSP meta tag into HTML
       * Note: Base tag is now injected by the server (openai.ts) before the HTML reaches here
       * We only inject CSP meta tag after the opening head tag
       * @param {string} html - Original HTML content
       * @param {string} cspValue - CSP policy string
       * @returns {string} HTML with CSP meta tag injected
       */
      function injectCSP(html, cspValue) {
        const cspMeta =
          '<meta http-equiv="Content-Security-Policy" content="' +
          cspValue +
          '">';

        // Match <head> with any attributes (e.g., <head>, <head class="...">)
        const headRegex = /<head[^>]*>/i;
        if (headRegex.test(html)) {
          return html.replace(headRegex, "$&" + cspMeta);
        } else if (/<html[^>]*>/i.test(html)) {
          return html.replace(/<html[^>]*>/i, "$&<head>" + cspMeta + "</head>");
        } else if (/<!DOCTYPE[^>]*>/i.test(html)) {
          return html.replace(
            /<!DOCTYPE[^>]*>/i,
            "$&<head>" + cspMeta + "</head>"
          );
        } else {
          return "<head>" + cspMeta + "</head>" + html;
        }
      }

      // Allowed sandbox tokens - prevents host from granting dangerous permissions
      const ALLOWED_SANDBOX_TOKENS = [
        "allow-scripts",
        "allow-same-origin",
        "allow-forms",
        "allow-popups",
        "allow-popups-to-escape-sandbox",
      ];
      const DEFAULT_SANDBOX = ALLOWED_SANDBOX_TOKENS.join(" ");

      /**
       * Validate sandbox attribute against allowlist
       * @param {string} sandbox - Sandbox attribute value
       * @returns {string} Safe sandbox value
       */
      function validateSandbox(sandbox) {
        if (typeof sandbox !== "string") return DEFAULT_SANDBOX;
        const tokens = sandbox.split(/\s+/).filter(Boolean);
        const safe = tokens.every((t) => ALLOWED_SANDBOX_TOKENS.includes(t));
        return safe ? sandbox : DEFAULT_SANDBOX;
      }

      // Create inner iframe immediately (before HTML arrives)
      const inner = document.createElement("iframe");
      inner.style.cssText = "width:100%; height:100%; border:none;";
      inner.setAttribute("sandbox", DEFAULT_SANDBOX);
      document.body.appendChild(inner);

      // CSP violation reporting - forward to host for debugging
      document.addEventListener("securitypolicyviolation", (e) => {
        window.parent.postMessage(
          {
            type: "openai:csp-violation",
            directive: e.violatedDirective,
            blockedUri: e.blockedURI,
            sourceFile: e.sourceFile,
            lineNumber: e.lineNumber,
            columnNumber: e.columnNumber,
          },
          "*"
        );
      });

      let widgetLoaded = false;

      // Handle messages from parent (host) and inner (widget)
      window.addEventListener("message", (event) => {
        if (event.source === window.parent) {
          // Message from host
          if (event.data?.type === "openai:load-widget") {
            const { html, sandbox, csp } = event.data;

            // Validate sandbox attribute against allowlist
            const safeSandbox = validateSandbox(sandbox);
            inner.setAttribute("sandbox", safeSandbox);

            if (typeof html === "string") {
              const cspValue = buildCSP(csp);
              inner.srcdoc = injectCSP(html, cspValue);
              widgetLoaded = true;
            }
          } else if (widgetLoaded && inner.contentWindow) {
            // Forward all other messages to widget
            inner.contentWindow.postMessage(event.data, "*");
          }
        } else if (event.source === inner.contentWindow) {
          // Forward all messages from widget to host
          window.parent.postMessage(event.data, "*");
        }
      });

      // Notify host that sandbox is ready
      window.parent.postMessage({ type: "openai:sandbox-ready" }, "*");
    </script>
  </body>
</html>
