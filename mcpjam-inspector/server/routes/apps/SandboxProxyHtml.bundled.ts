// This file is auto-generated by scripts/bundle-sandbox-proxy-html.js
// Do not edit directly - modify sandbox-proxy.html files instead

export const MCP_APPS_SANDBOX_PROXY_HTML =
  '<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <!-- Permissive CSP so nested srcdoc content is not constrained by host CSP.\n         The actual security enforcement is done by the dynamically-generated CSP\n         injected into the inner srcdoc iframe based on widget declarations (SEP-1865).\n         This outer CSP must allow external scripts since srcdoc network requests\n         are subject to the parent document\'s CSP. -->\n    <meta\n      http-equiv="Content-Security-Policy"\n      content="default-src \'self\'; img-src * data: blob: \'unsafe-inline\'; media-src * blob: data:; font-src * blob: data:; script-src * \'wasm-unsafe-eval\' \'unsafe-inline\' \'unsafe-eval\' blob: data:; style-src * blob: data: \'unsafe-inline\'; connect-src * data: blob: about:; frame-src * blob: data: http://localhost:* https://localhost:* http://127.0.0.1:* https://127.0.0.1:*;"\n    />\n    <title>MCP Apps Sandbox Proxy</title>\n    <style>\n      html,\n      body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n        width: 100%;\n        overflow: hidden;\n      }\n      * {\n        box-sizing: border-box;\n      }\n      iframe {\n        display: block;\n        background-color: transparent;\n        border: 0px none transparent;\n        padding: 0px;\n        width: 100%;\n        height: 100%;\n      }\n    </style>\n  </head>\n  <body>\n    <script>\n      /**\n       * MCP Apps Sandbox Proxy (SEP-1865)\n       *\n       * Double-iframe architecture for security isolation:\n       * Host Page → Sandbox Proxy (this page, different origin) → Guest UI\n       *\n       * This proxy:\n       * 1. Creates inner iframe immediately\n       * 2. Waits for HTML content via ui/notifications/sandbox-resource-ready\n       * 3. Builds CSP from metadata and injects into HTML\n       * 4. Loads HTML via srcdoc with configurable sandbox attributes\n       * 5. Forwards all non-sandbox messages between host and guest\n       *\n       * Reference: https://gist.github.com/ochafik/a9603ba2d6757d6038ce066eded4c354\n       */\n\n      /**\n       * Sanitize a domain/origin value for CSP (SEP-1865)\n       * Prevents injection attacks via malicious domain values\n       * @param {string} domain - Domain to sanitize\n       * @returns {string} Sanitized domain\n       */\n      function sanitizeDomain(domain) {\n        if (typeof domain !== "string") return "";\n        // Remove characters that could break out of CSP or HTML attributes\n        // Valid CSP sources shouldn\'t contain these characters\n        return domain.replace(/[\'"<>;]/g, "").trim();\n      }\n\n      /**\n       * Build iframe allow attribute from permissions (SEP-1865)\n       * @param {Object} permissions - Permissions metadata (camera, microphone, geolocation, clipboardWrite)\n       * @returns {string} Permission Policy allow attribute string\n       *\n       * Note: For srcdoc iframes, we use \'*\' allowlist since they don\'t have a defined origin.\n       * This allows the sandboxed content to request these permissions.\n       */\n      function buildAllowAttribute(permissions) {\n        if (!permissions) return "";\n\n        const allowList = [];\n        if (permissions.camera) allowList.push("camera *");\n        if (permissions.microphone) allowList.push("microphone *");\n        if (permissions.geolocation) allowList.push("geolocation *");\n        if (permissions.clipboardWrite) allowList.push("clipboard-write *");\n\n        return allowList.join("; ");\n      }\n\n      /**\n       * Build CSP string from metadata (SEP-1865)\n       * @param {Object} csp - CSP metadata with connectDomains, resourceDomains, frameDomains, and baseUriDomains\n       * @returns {string} CSP policy string\n       */\n      function buildCSP(csp) {\n        // Per SEP-1865: If no CSP declared, use restrictive defaults\n        // Note: \'self\' doesn\'t work in srcdoc iframes (refers to about:srcdoc)\n        // So we use \'unsafe-inline\' for scripts/styles since all widget code is inline\n        if (!csp) {\n          return [\n            "default-src \'none\'",\n            "script-src \'unsafe-inline\'",\n            "style-src \'unsafe-inline\'",\n            "img-src data:",\n            "font-src data:",\n            "media-src data:",\n            "connect-src \'none\'",\n            "frame-src \'none\'",\n            "object-src \'none\'",\n            "base-uri \'none\'",\n          ].join("; ");\n        }\n\n        // Build CSP from declared domains (SEP-1865)\n        // Per spec: "Host MAY further restrict but MUST NOT allow undeclared domains"\n        const connectDomains = (csp.connectDomains || [])\n          .map(sanitizeDomain)\n          .filter(Boolean);\n        const resourceDomains = (csp.resourceDomains || [])\n          .map(sanitizeDomain)\n          .filter(Boolean);\n        const frameDomains = (csp.frameDomains || [])\n          .map(sanitizeDomain)\n          .filter(Boolean);\n        const baseUriDomains = (csp.baseUriDomains || [])\n          .map(sanitizeDomain)\n          .filter(Boolean);\n\n        // connect-src: Only allow declared domains, or \'none\' if empty\n        const connectSrc =\n          connectDomains.length > 0 ? connectDomains.join(" ") : "\'none\'";\n\n        // Resource sources: data: and blob: are always allowed for inline content\n        // Only add declared resourceDomains - no forced CDNs per SEP-1865\n        const resourceSrc =\n          resourceDomains.length > 0\n            ? ["data:", "blob:", ...resourceDomains].join(" ")\n            : "data: blob:";\n\n        // frame-src: Only allow declared frame domains, or \'none\' if empty\n        const frameSrc =\n          frameDomains.length > 0 ? frameDomains.join(" ") : "\'none\'";\n\n        // base-uri: Only allow declared base URI domains, or \'none\' if empty\n        const baseUri =\n          baseUriDomains.length > 0 ? baseUriDomains.join(" ") : "\'none\'";\n\n        console.log("[buildCSP] Processing domains:", {\n          frameDomains,\n          frameSrc,\n          baseUriDomains,\n          baseUri,\n        });\n\n        console.log(\n          "[buildCSP] Built CSP string:",\n          [\n            "default-src \'none\'",\n            "script-src \'unsafe-inline\' " + resourceSrc,\n            "style-src \'unsafe-inline\' " + resourceSrc,\n            "img-src " + resourceSrc,\n            "font-src " + resourceSrc,\n            "media-src " + resourceSrc,\n            "connect-src " + connectSrc,\n            "frame-src " + frameSrc,\n            "object-src \'none\'",\n            "base-uri " + baseUri,\n          ].join("; "),\n        );\n\n        return [\n          "default-src \'none\'",\n          "script-src \'unsafe-inline\' " + resourceSrc,\n          "style-src \'unsafe-inline\' " + resourceSrc,\n          "img-src " + resourceSrc,\n          "font-src " + resourceSrc,\n          "media-src " + resourceSrc,\n          "connect-src " + connectSrc,\n          "frame-src " + frameSrc,\n          "object-src \'none\'",\n          "base-uri " + baseUri,\n        ].join("; ");\n      }\n\n      /**\n       * Build CSP violation listener script\n       * Forwards securitypolicyviolation events to the host via postMessage\n       * @returns {string} Script tag with violation listener\n       */\n      function buildViolationListenerScript() {\n        return `<script>\ndocument.addEventListener(\'securitypolicyviolation\', function(e) {\n  var violation = {\n    type: \'mcp-apps:csp-violation\',\n    directive: e.violatedDirective,\n    blockedUri: e.blockedURI,\n    sourceFile: e.sourceFile || null,\n    lineNumber: e.lineNumber || null,\n    columnNumber: e.columnNumber || null,\n    effectiveDirective: e.effectiveDirective,\n    originalPolicy: e.originalPolicy,\n    disposition: e.disposition,\n    timestamp: Date.now()\n  };\n  console.warn(\'[MCP Apps CSP Violation]\', violation.directive, \':\', violation.blockedUri);\n  window.parent.postMessage(violation, \'*\');\n});\n<\\/script>`;\n      }\n\n      /**\n       * Inject CSP meta tag and violation listener into HTML\n       * @param {string} html - Original HTML content\n       * @param {string} cspValue - CSP policy string\n       * @returns {string} HTML with CSP meta tag and violation listener injected\n       */\n      function injectCSP(html, cspValue) {\n        const cspMeta =\n          \'<meta http-equiv="Content-Security-Policy" content="\' +\n          cspValue +\n          \'">\';\n        const violationListener = buildViolationListenerScript();\n        const injection = cspMeta + violationListener;\n\n        if (html.includes("<head>")) {\n          return html.replace("<head>", "<head>" + injection);\n        } else if (html.includes("<HEAD>")) {\n          return html.replace("<HEAD>", "<HEAD>" + injection);\n        } else if (html.includes("<html>")) {\n          return html.replace("<html>", "<html><head>" + injection + "</head>");\n        } else if (html.includes("<HTML>")) {\n          return html.replace("<HTML>", "<HTML><head>" + injection + "</head>");\n        } else if (html.includes("<!DOCTYPE") || html.includes("<!doctype")) {\n          // Insert after doctype\n          return html.replace(\n            /(<!DOCTYPE[^>]*>|<!doctype[^>]*>)/i,\n            "$1<head>" + injection + "</head>",\n          );\n        } else {\n          // Prepend CSP meta tag and listener\n          return injection + html;\n        }\n      }\n\n      // Create inner iframe immediately (before HTML arrives)\n      const inner = document.createElement("iframe");\n      inner.style = "width:100%; height:100%; border:none;";\n      // Default minimal sandbox before HTML arrives\n      inner.setAttribute(\n        "sandbox",\n        "allow-scripts allow-same-origin allow-forms",\n      );\n      document.body.appendChild(inner);\n\n      // Handle messages from parent (host) and inner (guest UI)\n      window.addEventListener("message", async (event) => {\n        if (event.source === window.parent) {\n          // Message from host\n          if (\n            event.data &&\n            event.data.method === "ui/notifications/sandbox-resource-ready"\n          ) {\n            // Load HTML into inner iframe with CSP enforcement\n            const { html, sandbox, csp, permissions, permissive } =\n              event.data.params || {};\n\n            if (typeof sandbox === "string") {\n              inner.setAttribute("sandbox", sandbox);\n            }\n\n            // Set Permission Policy allow attribute based on requested permissions (SEP-1865)\n            const allowAttribute = buildAllowAttribute(permissions);\n            if (allowAttribute) {\n              inner.setAttribute("allow", allowAttribute);\n            }\n\n            if (typeof html === "string") {\n              if (permissive) {\n                // Permissive mode: inject maximally permissive CSP\n                // Must explicitly allow everything since srcdoc inherits parent CSP\n                const permissiveCsp = [\n                  "default-src * \'unsafe-inline\' \'unsafe-eval\' data: blob: filesystem: about:",\n                  "script-src * \'unsafe-inline\' \'unsafe-eval\' data: blob:",\n                  "style-src * \'unsafe-inline\' data: blob:",\n                  "img-src * data: blob: https: http:",\n                  "media-src * data: blob: https: http:",\n                  "font-src * data: blob: https: http:",\n                  "connect-src * data: blob: https: http: ws: wss: about:",\n                  "frame-src * data: blob: https: http: about:",\n                  "object-src * data: blob:",\n                  "base-uri *",\n                  "form-action *",\n                ].join("; ");\n                const processedHtml = injectCSP(html, permissiveCsp);\n                inner.srcdoc = processedHtml;\n              } else {\n                // Build CSP and inject into HTML (SEP-1865)\n                const cspValue = buildCSP(csp);\n                const processedHtml = injectCSP(html, cspValue);\n                inner.srcdoc = processedHtml;\n              }\n            }\n          } else {\n            // Forward other messages to inner iframe (guest UI)\n            if (inner && inner.contentWindow) {\n              inner.contentWindow.postMessage(event.data, "*");\n            }\n          }\n        } else if (event.source === inner.contentWindow) {\n          // Relay messages from inner (guest UI) to parent (host)\n          // Only forward JSON-RPC 2.0 messages and whitelisted non-JSON-RPC types.\n          // This prevents non-protocol messages (browser extensions, widget internals)\n          // from reaching PostMessageTransport and causing parse errors.\n          var data = event.data;\n          if (data && typeof data === "object") {\n            if (\n              data.jsonrpc === "2.0" ||\n              data.type === "mcp-apps:csp-violation" ||\n              data.type === "openai:uploadFile" ||\n              data.type === "openai:getFileDownloadUrl"\n            ) {\n              window.parent.postMessage(data, "*");\n            }\n          }\n        }\n      });\n\n      // Notify parent that sandbox is ready (per SEP-1865)\n      window.parent.postMessage(\n        {\n          jsonrpc: "2.0",\n          method: "ui/notifications/sandbox-proxy-ready",\n          params: {},\n        },\n        "*",\n      );\n    </script>\n  </body>\n</html>\n';
export const CHATGPT_APPS_SANDBOX_PROXY_HTML =
  '<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>ChatGPT Apps Sandbox Proxy</title>\n    <style>\n      html,\n      body {\n        margin: 0;\n        height: 100vh;\n        width: 100vw;\n      }\n\n      body {\n        display: flex;\n        flex-direction: column;\n      }\n\n      * {\n        box-sizing: border-box;\n      }\n\n      iframe {\n        background-color: transparent;\n        border: 0px none transparent;\n        padding: 0px;\n        overflow: hidden;\n        flex-grow: 1;\n        width: 100%;\n        height: 100%;\n      }\n    </style>\n  </head>\n\n  <body>\n    <script>\n      /**\n       * ChatGPT Apps Sandbox Proxy - Triple-iframe architecture for ChatGPT parity\n       * Inspector Host -> Outer (about:blank) -> This Proxy (different origin) -> Widget (src URL)\n       *\n       * The widget is loaded via src URL (not srcdoc) to preserve proper URL context\n       * for Next.js navigation and React hydration.\n       */\n\n      const ALLOWED_SANDBOX_TOKENS = [\n        "allow-scripts",\n        "allow-same-origin",\n        "allow-forms",\n        "allow-popups",\n        "allow-popups-to-escape-sandbox",\n      ];\n      const DEFAULT_SANDBOX = ALLOWED_SANDBOX_TOKENS.join(" ");\n\n      function validateSandbox(sandbox) {\n        if (typeof sandbox !== "string") return DEFAULT_SANDBOX;\n        const tokens = sandbox.split(/\\s+/).filter(Boolean);\n        return tokens.every((t) => ALLOWED_SANDBOX_TOKENS.includes(t))\n          ? sandbox\n          : DEFAULT_SANDBOX;\n      }\n\n      const inner = document.createElement("iframe");\n      inner.style.cssText = "width:100%; height:100%; border:none;";\n      inner.setAttribute("sandbox", DEFAULT_SANDBOX);\n      // Permissions Policy matching ChatGPT\'s actual implementation\n      inner.setAttribute(\n        "allow",\n        "local-network-access *; microphone *; midi *",\n      );\n      document.body.appendChild(inner);\n\n      let widgetLoaded = false;\n\n      window.addEventListener("message", (event) => {\n        console.log(\n          "[Sandbox Proxy] Received message:",\n          event.data?.type,\n          "from:",\n          event.source === window.parent\n            ? "parent"\n            : event.source === inner.contentWindow\n              ? "inner"\n              : "unknown",\n        );\n        if (event.source === window.parent) {\n          if (event.data?.type === "openai:load-widget") {\n            const { url, sandbox } = event.data;\n            console.log("[Sandbox Proxy] Loading widget from URL:", url);\n            inner.setAttribute("sandbox", validateSandbox(sandbox));\n            if (typeof url === "string") {\n              inner.src = url;\n              widgetLoaded = true;\n            }\n          } else if (widgetLoaded && inner.contentWindow) {\n            inner.contentWindow.postMessage(event.data, "*");\n          }\n        } else if (event.source === inner.contentWindow) {\n          console.log(\n            "[Sandbox Proxy] Forwarding to parent:",\n            event.data?.type,\n          );\n          window.parent.postMessage(event.data, "*");\n        }\n      });\n\n      window.parent.postMessage({ type: "openai:sandbox-ready" }, "*");\n    </script>\n  </body>\n</html>\n';
