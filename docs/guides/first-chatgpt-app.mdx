---
title: "My First ChatGPT App"
description: "Build a simple Coffee Shop ChatGPT App from scratch"
icon: "sparkles"
---

We're going to create a simple Coffee Shop ChatGPT App where users can order and drink coffees through an interactive widget!

## Setting up your environment

### Initialize the project

```bash
mkdir coffee-shop
cd coffee-shop
npm init -y
```

### Install dependencies

```bash
npm install @modelcontextprotocol/sdk
```

## Setting up the MCP Server

### Creating the MCP Server

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { createServer, IncomingMessage, ServerResponse } from "http";

const server = new McpServer({
  name: "coffee-shop",
  version: "1.0.0"
});
```

### Registering Resources and Tools

Widget resources and tools work together. The resource provides the widget HTML, and tools reference it to display your UI:

```typescript
// ...
// Register the widget resource
server.registerResource(
  "coffee-widget",
  "ui://widget/coffee.html",                // Identifier that tools reference via openai/outputTemplate
  { description: "Coffee Shop widget" },
  async () => ({
    contents: [{
      uri: "ui://widget/coffee.html",
      mimeType: "text/html+skybridge",      // Marks this as a widget that receives window.openai
      text: WIDGET_HTML,
      _meta: {
        "openai/widgetPrefersBorder": true,  // Adds a border around your widget in the chat
        "openai/widgetCSP": {
          redirect_domains: ["https://www.mcpjam.com"]  // Domains users can be redirected to
        }
      }
    }]
  })
);

// Register a tool that uses this widget
server.registerTool(
  "orderCoffee",
  {
    title: "Order Coffee",
    description: "Order a coffee to add to your collection.",
    _meta: {
      "openai/outputTemplate": "ui://widget/coffee.html",    // Which widget to display
      "openai/widgetAccessible": true,                       // Allow widget buttons to call this tool
      "openai/toolInvocation/invoking": "Brewing coffee...", // Loading message while tool runs
      "openai/toolInvocation/invoked": "Coffee ready!"       // Success message when tool completes
    }
  },
  async () => {
    // ...
    return {
      structuredContent: {                                   // Data for widget + model reasoning
        coffeeCount: coffeeCount,
        message: "Here's your coffee! ‚òïÔ∏è"
      },
      content: [{                                            // Text the model uses to craft its response
        type: "text" as const,
        text: `Ordered a coffee! You now have ${coffeeCount} coffees.`
      }]
    };
  }
);
// ...
```

## Understanding the Widget

ChatGPT Apps can display interactive widgets inside the chat. Widget resources are registered by your app and become available when the client connects to your MCP server. Your widget can be built using vanilla JavaScript or a framework like React (optionally with TypeScript), and is bundled into a self-contained HTML file. The client injects `window.openai` into the iframe, allowing the widget to communicate with ChatGPT and invoke tools exposed by your MCP server.

### The `window.openai` API

The `window.openai` object is how your widget talks to the client. Our Coffee Shop uses a few of its methods, but there's much more available - file uploads, modals, theming, and more. For the full API reference, see the [OpenAI Apps SDK docs](https://developers.openai.com/apps-sdk/reference#windowopenai-component-bridge).

### Reading data with `window.openai.toolOutput`

When ChatGPT calls your tool, the server returns `structuredContent`. The client transforms this into `window.openai.toolOutput` for your widget:

```javascript
// ...
const output = window.openai.toolOutput;
///
const count = output.coffeeCount;
const message = output.message;
// ...
```

<Note>
Our Coffee Shop stores `coffeeCount` on the server, so the widget simply reads `toolOutput` and renders it.

If you need to track state in the widget without updating the server, use `window.openai.widgetState` and `window.openai.setWidgetState()`. Our Coffee Shop doesn't need this because every interaction calls the server.
</Note>

### Calling tools with `window.openai.callTool()`

Widget buttons can call server tools directly. This requires `"openai/widgetAccessible": true` in your tool's metadata:

```javascript
// ...
const result = await window.openai.callTool("orderCoffee", {});
const { coffeeCount, message } = result.structuredContent;
// ...
```

### Listening for updates with `openai:set_globals`

When a user triggers a tool via chat (not button click), ChatGPT sends updated data to your widget via the `openai:set_globals` event:

```javascript
// ...
window.addEventListener("openai:set_globals", (event) => {
  const output = event.detail.globals.toolOutput;
});
// ...
```

<Note>
This event fires when the user says something like "order me a coffee" in chat. Your widget stays in sync whether the user clicks buttons or types messages.
</Note>

### Display Modes

Widgets can request different display modes to optimize their presentation:

- **Inline** (default) - Widget renders within the chat message flow
- **Picture-in-Picture (PiP)** - Widget floats at the top of the screen, staying visible while scrolling
- **Fullscreen** - Widget expands to fill the entire viewport for immersive experiences

Widgets start in inline mode. To request a different mode:

```javascript
window.openai.requestDisplayMode({ mode: "pip" });
window.openai.requestDisplayMode({ mode: "fullscreen" });
```

Users can exit PiP or fullscreen by clicking the close button, returning to inline. Our Coffee Shop uses the default inline mode, but you can test all three in MCPJam Inspector's App Builder.

### Content Security Policy (CSP)

Widgets run in a sandboxed iframe, so you need to declare which external domains your widget can interact with. Set `openai/widgetCSP` in your resource's `_meta` to configure these permissions:

- **`connect_domains`** - Domains your widget can fetch from (API calls)
- **`resource_domains`** - Domains for static assets (images, fonts, scripts)
- **`redirect_domains`** - Domains for `window.openai.openExternal()` redirects

Our Coffee Shop uses `redirect_domains` to allow the "Learn more" button to redirect users to mcpjam.com:

```javascript
window.openai.openExternal("https://www.mcpjam.com");
```

<Note>
Without declaring a domain in your CSP, the sandbox will block the request. Only declare the domains you actually need.
</Note>

## A note on authentication

Since the purpose of this guide is to get you building your first ChatGPT App, we've kept things simple and skipped authentication. For production apps that need to identify users or access protected resources, check out the [OpenAI's authentication docs](https://developers.openai.com/apps-sdk/build/auth).

## Running Your App

### Start the server

```bash
npm start
```

Your server is now running on `http://localhost:8787`.

### Testing with MCPJam Inspector

The easiest way to test your app:

1. Run the inspector: `npx @mcpjam/inspector@latest`
2. Enter URL: `http://localhost:8787/mcp`
3. Try your app in our Chat or App Builder!

### Connecting to ChatGPT

To connect your app to ChatGPT:

1. In MCPJam Inspector, click **Create ngrok tunnel** with your server connected
2. Use the tunnel URL as your connector endpoint in ChatGPT

For more information, see our [ngrok tunneling feature blog](https://www.mcpjam.com/blog/ngrok).

## What's next?

Now that your Coffee Shop is running, you can:

1. **Test the flow** - Call the `orderCoffee` tool to see your widget
2. **Try the buttons** - Click "Order" and "Drink" to interact with your server
3. **Chat naturally** - Say "order me 3 coffees" and watch the widget update
4. **Iterate and expand** - Add more tools, improve the UI, or build something completely new!

Congratulations! You've built your first ChatGPT App! üéâ
