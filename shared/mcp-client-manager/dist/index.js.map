{"version":3,"sources":["../index.ts"],"sourcesContent":["import { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport type { ClientOptions } from '@modelcontextprotocol/sdk/client/index.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport type { SSEClientTransportOptions } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { getDefaultEnvironment, StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport type { StreamableHTTPClientTransportOptions } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport { DEFAULT_REQUEST_TIMEOUT_MSEC } from '@modelcontextprotocol/sdk/shared/protocol.js';\nimport type { RequestOptions } from '@modelcontextprotocol/sdk/shared/protocol.js';\nimport type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport {\n  CallToolResultSchema,\n  ElicitRequestSchema,\n  ResourceListChangedNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  PromptListChangedNotificationSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport type { ElicitRequest, ElicitResult } from '@modelcontextprotocol/sdk/types.js';\ntype ClientCapabilityOptions = NonNullable<ClientOptions['capabilities']>;\n\ntype BaseServerConfig = {\n  capabilities?: ClientCapabilityOptions;\n  timeout?: number;\n  version?: string;\n  onError?: (error: unknown) => void;\n};\n\ntype StdioServerConfig = BaseServerConfig & {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n\n  url?: never;\n  requestInit?: never;\n  eventSourceInit?: never;\n  authProvider?: never;\n  reconnectionOptions?: never;\n  sessionId?: never;\n  preferSSE?: never;\n};\n\ntype HttpServerConfig = BaseServerConfig & {\n  url: URL;\n  requestInit?: StreamableHTTPClientTransportOptions['requestInit'];\n  eventSourceInit?: SSEClientTransportOptions['eventSourceInit'];\n  authProvider?: StreamableHTTPClientTransportOptions['authProvider'];\n  reconnectionOptions?: StreamableHTTPClientTransportOptions['reconnectionOptions'];\n  sessionId?: StreamableHTTPClientTransportOptions['sessionId'];\n  preferSSE?: boolean;\n\n  command?: never;\n  args?: never;\n  env?: never;\n};\n\nexport type MCPServerConfig = StdioServerConfig | HttpServerConfig;\n\nexport type MCPClientManagerConfig = Record<string, MCPServerConfig>;\n\ntype NotificationSchema = Parameters<Client['setNotificationHandler']>[0];\ntype NotificationHandler = Parameters<Client['setNotificationHandler']>[1];\n\ninterface NotificationHandlerEntry {\n  schema: NotificationSchema;\n  handler: NotificationHandler;\n}\n\ninterface ManagedClientState {\n  config: MCPServerConfig;\n  timeout: number;\n  client?: Client;\n  transport?: Transport;\n  promise?: Promise<Client>;\n}\n\n// Pending state is tracked inside ManagedClientState.promise\n\ntype ClientRequestOptions = RequestOptions;\ntype CallToolOptions = RequestOptions;\n\ntype ListResourcesParams = Parameters<Client['listResources']>[0];\ntype ListResourceTemplatesParams = Parameters<Client['listResourceTemplates']>[0];\ntype ReadResourceParams = Parameters<Client['readResource']>[0];\ntype SubscribeResourceParams = Parameters<Client['subscribeResource']>[0];\ntype UnsubscribeResourceParams = Parameters<Client['unsubscribeResource']>[0];\ntype ListPromptsParams = Parameters<Client['listPrompts']>[0];\ntype GetPromptParams = Parameters<Client['getPrompt']>[0];\ntype ListToolsResult = Awaited<ReturnType<Client['listTools']>>;\n\nexport type ExecuteToolArguments = Record<string, unknown>;\nexport type ElicitationHandler = (\n  params: ElicitRequest['params'],\n) => Promise<ElicitResult> | ElicitResult;\n\nexport class MCPClientManager {\n  private readonly clientStates = new Map<string, ManagedClientState>();\n  private readonly notificationHandlers = new Map<string, Map<NotificationSchema, Set<NotificationHandler>>>();\n  private readonly elicitationHandlers = new Map<string, ElicitationHandler>();\n  private readonly defaultClientVersion: string;\n  private readonly defaultCapabilities: ClientCapabilityOptions;\n  private readonly defaultTimeout: number;\n\n  constructor(\n    servers: MCPClientManagerConfig = {},\n    options: {\n      defaultClientVersion?: string;\n      defaultCapabilities?: ClientCapabilityOptions;\n      defaultTimeout?: number;\n    } = {},\n  ) {\n    this.defaultClientVersion = options.defaultClientVersion ?? '1.0.0';\n    this.defaultCapabilities = { ...(options.defaultCapabilities ?? {}) };\n    this.defaultTimeout = options.defaultTimeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;\n\n    for (const [name, config] of Object.entries(servers)) {\n      void this.connectToServer(name, config);\n    }\n  }\n\n  listServers(): string[] {\n    return Array.from(this.clientStates.keys());\n  }\n\n  hasServer(serverName: string): boolean {\n    const normalizedServerName = this.normalizeName(serverName);\n    return this.clientStates.has(normalizedServerName);\n  }\n\n  async connectToServer(serverName: string, config: MCPServerConfig): Promise<Client> {\n    const normalizedServerName = this.normalizeName(serverName);\n    const timeout = this.getTimeout(config);\n    const state = this.clientStates.get(normalizedServerName) ?? { config, timeout };\n    // Update config/timeout on every call\n    state.config = config;\n    state.timeout = timeout;\n    // If already connected, return the client\n    if (state.client) {\n      this.clientStates.set(normalizedServerName, state);\n      return state.client;\n    }\n    // If connection is in-flight, reuse the promise\n    if (state.promise) {\n      this.clientStates.set(normalizedServerName, state);\n      return state.promise;\n    }\n\n    const connectionPromise = (async () => {\n      const client = new Client(\n        {\n          name: normalizedServerName,\n          version: config.version ?? this.defaultClientVersion,\n        },\n        {\n          capabilities: this.buildCapabilities(config),\n        },\n      );\n\n      this.applyNotificationHandlers(normalizedServerName, client);\n      this.applyElicitationHandler(normalizedServerName, client);\n\n      if (config.onError) {\n        client.onerror = error => {\n          config.onError?.(error);\n        };\n      }\n\n      client.onclose = () => {\n        this.resetState(normalizedServerName);\n      };\n\n      let transport: Transport;\n      if (this.isStdioConfig(config)) {\n        transport = await this.connectViaStdio(client, config, timeout);\n      } else {\n        transport = await this.connectViaHttp(normalizedServerName, client, config, timeout);\n      }\n\n      state.client = client;\n      state.transport = transport;\n      // clear pending\n      state.promise = undefined;\n      this.clientStates.set(normalizedServerName, state);\n\n      return client;\n    })().catch(error => {\n      // Clear pending but keep config so the server remains registered\n      state.promise = undefined;\n      state.client = undefined;\n      state.transport = undefined;\n      this.clientStates.set(normalizedServerName, state);\n      throw error;\n    });\n\n    state.promise = connectionPromise;\n    this.clientStates.set(normalizedServerName, state);\n    return connectionPromise;\n  }\n\n  async disconnectServer(serverName: string): Promise<void> {\n    const normalizedServerName = this.normalizeName(serverName);\n    const client = this.getClientByName(normalizedServerName);\n    try {\n      await client.close();\n    } finally {\n      if (client.transport) {\n        await this.safeCloseTransport(client.transport);\n      }\n      this.resetState(normalizedServerName);\n    }\n  }\n\n  async disconnectAllServers(): Promise<void> {\n    const serverNames = this.listServers();\n    await Promise.all(serverNames.map(name => this.disconnectServer(name)));\n\n    for (const serverName of serverNames) {\n      const normalizedServerName = this.normalizeName(serverName);\n      this.resetState(normalizedServerName);\n      this.notificationHandlers.delete(normalizedServerName);\n      this.elicitationHandlers.delete(normalizedServerName);\n    }\n  }\n\n  async listTools(serverName: string, params?: Parameters<Client['listTools']>[0], options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.listTools(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  async getTools(names?: string[]): Promise<ListToolsResult> {\n    const targetNames = names && names.length > 0 ? names.map(name => this.normalizeName(name)) : this.listServers();\n    const uniqueNames = Array.from(new Set(targetNames));\n\n    const toolLists = await Promise.all(\n      uniqueNames.map(async serverName => {\n        await this.ensureConnected(serverName);\n        const client = this.getClientByName(serverName);\n        const result = await client.listTools(undefined, this.withTimeout(serverName));\n        return result.tools;\n      }),\n    );\n\n    return { tools: toolLists.flat() };\n  }\n\n  async executeTool(serverName: string, toolName: string, args: ExecuteToolArguments = {}, options?: CallToolOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.callTool(\n      {\n        name: toolName,\n        arguments: args,\n      },\n      CallToolResultSchema,\n      this.withTimeout(normalizedServerName, options),\n    );\n  }\n\n  async listResources(serverName: string, params?: ListResourcesParams, options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.listResources(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  async readResource(serverName: string, params: ReadResourceParams, options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.readResource(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  async subscribeResource(serverName: string, params: SubscribeResourceParams, options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.subscribeResource(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  async unsubscribeResource(serverName: string, params: UnsubscribeResourceParams, options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.unsubscribeResource(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  async listResourceTemplates(serverName: string, params?: ListResourceTemplatesParams, options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.listResourceTemplates(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  async listPrompts(serverName: string, params?: ListPromptsParams, options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.listPrompts(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  async getPrompt(serverName: string, params: GetPromptParams, options?: ClientRequestOptions) {\n    const normalizedServerName = this.normalizeName(serverName);\n    await this.ensureConnected(normalizedServerName);\n    const client = this.getClientByName(normalizedServerName);\n    return client.getPrompt(params, this.withTimeout(normalizedServerName, options));\n  }\n\n  getSessionIdByServer(serverName: string): string | undefined {\n    const state = this.clientStates.get(this.normalizeName(serverName));\n    if (!state?.transport) {\n      throw new Error(`Unknown MCP server \"${serverName}\".`);\n    }\n    if (state.transport instanceof StreamableHTTPClientTransport) {\n      return state.transport.sessionId;\n    }\n    throw new Error(`Server \"${serverName}\" must be Streamable HTTP to get the session ID.`);\n  }\n\n  addNotificationHandler(serverName: string, schema: NotificationSchema, handler: NotificationHandler): void {\n    const normalizedServerName = this.normalizeName(serverName);\n    const serverHandlers = this.notificationHandlers.get(normalizedServerName) ?? new Map();\n    const handlersForSchema = serverHandlers.get(schema) ?? new Set<NotificationHandler>();\n    handlersForSchema.add(handler);\n    serverHandlers.set(schema, handlersForSchema);\n    this.notificationHandlers.set(normalizedServerName, serverHandlers);\n\n    const client = this.clientStates.get(normalizedServerName)?.client;\n    if (client) {\n      client.setNotificationHandler(schema, this.createNotificationDispatcher(normalizedServerName, schema));\n    }\n  }\n\n  onResourceListChanged(serverName: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(serverName, ResourceListChangedNotificationSchema, handler);\n  }\n\n  onResourceUpdated(serverName: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(serverName, ResourceUpdatedNotificationSchema, handler);\n  }\n\n  onPromptListChanged(serverName: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(serverName, PromptListChangedNotificationSchema, handler);\n  }\n\n  getClient(serverName: string): Client | undefined {\n    return this.clientStates.get(this.normalizeName(serverName))?.client;\n  }\n\n  setElicitationHandler(serverName: string, handler: ElicitationHandler): void {\n    const normalizedServerName = this.normalizeName(serverName);\n    if (!this.clientStates.has(normalizedServerName)) {\n      throw new Error(`Unknown MCP server \"${normalizedServerName}\".`);\n    }\n\n    this.elicitationHandlers.set(normalizedServerName, handler);\n\n    const client = this.clientStates.get(normalizedServerName)?.client;\n    if (client) {\n      this.applyElicitationHandler(normalizedServerName, client);\n    }\n  }\n\n  clearElicitationHandler(serverName: string): void {\n    const normalizedServerName = this.normalizeName(serverName);\n    this.elicitationHandlers.delete(normalizedServerName);\n    const client = this.clientStates.get(normalizedServerName)?.client;\n    if (client) {\n      client.removeRequestHandler('elicitation/create');\n    }\n  }\n\n  private async connectViaStdio(client: Client, config: StdioServerConfig, timeout: number): Promise<Transport> {\n    const transport = new StdioClientTransport({\n      command: config.command,\n      args: config.args,\n      env: { ...getDefaultEnvironment(), ...(config.env ?? {}) },\n    });\n    await client.connect(transport, { timeout });\n    return transport;\n  }\n\n  private async connectViaHttp(serverName: string, client: Client, config: HttpServerConfig, timeout: number): Promise<Transport> {\n    const preferSSE = config.preferSSE ?? config.url.pathname.endsWith('/sse');\n    let streamableError: unknown;\n\n    if (!preferSSE) {\n      const streamableTransport = new StreamableHTTPClientTransport(config.url, {\n        requestInit: config.requestInit,\n        reconnectionOptions: config.reconnectionOptions,\n        authProvider: config.authProvider,\n        sessionId: config.sessionId,\n      });\n\n      try {\n        await client.connect(streamableTransport, { timeout: Math.min(timeout, 3000) });\n        return streamableTransport;\n      } catch (error) {\n        streamableError = error;\n        await this.safeCloseTransport(streamableTransport);\n      }\n    }\n\n    const sseTransport = new SSEClientTransport(config.url, {\n      requestInit: config.requestInit,\n      eventSourceInit: config.eventSourceInit,\n      authProvider: config.authProvider,\n    });\n\n    try {\n      await client.connect(sseTransport, { timeout });\n      return sseTransport;\n    } catch (error) {\n      await this.safeCloseTransport(sseTransport);\n      const streamableMessage = streamableError\n        ? ` Streamable HTTP error: ${this.formatError(streamableError)}.`\n        : '';\n      throw new Error(\n        `Failed to connect to MCP server \"${serverName}\" using HTTP transports.${streamableMessage} SSE error: ${this.formatError(error)}.`,\n      );\n    }\n  }\n\n  private async safeCloseTransport(transport: Transport): Promise<void> {\n    try {\n      await transport.close();\n    } catch {\n      // Ignore close errors during cleanup.\n    }\n  }\n\n  private applyNotificationHandlers(serverName: string, client: Client): void {\n    const serverHandlers = this.notificationHandlers.get(serverName);\n    if (!serverHandlers) {\n      return;\n    }\n\n    for (const [schema] of serverHandlers) {\n      client.setNotificationHandler(schema, this.createNotificationDispatcher(serverName, schema));\n    }\n  }\n\n  private createNotificationDispatcher(serverName: string, schema: NotificationSchema): NotificationHandler {\n    return notification => {\n      const serverHandlers = this.notificationHandlers.get(serverName);\n      const handlersForSchema = serverHandlers?.get(schema);\n      if (!handlersForSchema || handlersForSchema.size === 0) {\n        return;\n      }\n      for (const handler of handlersForSchema) {\n        try {\n          handler(notification);\n        } catch {\n          // Swallow individual handler errors to avoid breaking other listeners.\n        }\n      }\n    };\n  }\n\n  private applyElicitationHandler(serverName: string, client: Client): void {\n    const handler = this.elicitationHandlers.get(serverName);\n    if (!handler) {\n      return;\n    }\n\n    client.setRequestHandler(ElicitRequestSchema, async request => handler(request.params));\n  }\n\n  private async ensureConnected(serverName: string): Promise<void> {\n    const normalizedServerName = this.normalizeName(serverName);\n    const state = this.clientStates.get(normalizedServerName);\n    if (state?.client) {\n      return;\n    }\n\n    if (!state) {\n      throw new Error(`Unknown MCP server \"${normalizedServerName}\".`);\n    }\n    if (state.promise) {\n      await state.promise;\n      return;\n    }\n    await this.connectToServer(normalizedServerName, state.config);\n  }\n\n  private resetState(serverName: string): void {\n    const normalizedServerName = this.normalizeName(serverName);\n    this.clientStates.delete(normalizedServerName);\n  }\n\n  private withTimeout(serverName: string, options?: RequestOptions): RequestOptions {\n    const normalizedServerName = this.normalizeName(serverName);\n    const state = this.clientStates.get(normalizedServerName);\n    const timeout = state?.timeout ?? (state ? this.getTimeout(state.config) : this.defaultTimeout);\n\n    if (!options) {\n      return { timeout };\n    }\n\n    if (options.timeout === undefined) {\n      return { ...options, timeout };\n    }\n\n    return options;\n  }\n\n  private buildCapabilities(config: MCPServerConfig): ClientCapabilityOptions {\n    const capabilities: ClientCapabilityOptions = {\n      ...this.defaultCapabilities,\n      ...(config.capabilities ?? {}),\n    };\n\n    if (!capabilities.elicitation) {\n      capabilities.elicitation = {};\n    }\n\n    return capabilities;\n  }\n\n  private formatError(error: unknown): string {\n    if (error instanceof Error) {\n      return error.message;\n    }\n\n    try {\n      return JSON.stringify(error);\n    } catch {\n      return String(error);\n    }\n  }\n\n  private getTimeout(config: MCPServerConfig): number {\n    return config.timeout ?? this.defaultTimeout;\n  }\n\n  private isStdioConfig(config: MCPServerConfig): config is StdioServerConfig {\n    return 'command' in config;\n  }\n\n  private normalizeName(serverName: string): string {\n    const normalized = serverName.trim();\n    if (!normalized) {\n      throw new Error('Server name must be a non-empty string.');\n    }\n    return normalized;\n  }\n\n  private getClientByName(serverName: string): Client {\n    const normalizedServerName = this.normalizeName(serverName);\n    const state = this.clientStates.get(normalizedServerName);\n    if (!state?.client) {\n      throw new Error(`MCP server \"${normalizedServerName}\" is not connected.`);\n    }\n    return state.client;\n  }\n}\n"],"mappings":"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","names":["_a"]}