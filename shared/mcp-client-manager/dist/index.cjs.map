{"version":3,"sources":["../index.ts"],"sourcesContent":["import { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport type { ClientOptions } from '@modelcontextprotocol/sdk/client/index.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport type { SSEClientTransportOptions } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { getDefaultEnvironment, StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport type { StreamableHTTPClientTransportOptions } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport { DEFAULT_REQUEST_TIMEOUT_MSEC } from '@modelcontextprotocol/sdk/shared/protocol.js';\nimport type { RequestOptions } from '@modelcontextprotocol/sdk/shared/protocol.js';\nimport type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport {\n  CallToolResultSchema,\n  ResourceListChangedNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  PromptListChangedNotificationSchema,\n} from '@modelcontextprotocol/sdk/types.js';\ntype ClientCapabilityOptions = NonNullable<ClientOptions['capabilities']>;\n\ntype BaseServerConfig = {\n  capabilities?: ClientCapabilityOptions;\n  timeout?: number;\n  version?: string;\n  onError?: (error: unknown) => void;\n};\n\ntype StdioServerConfig = BaseServerConfig & {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n\n  url?: never;\n  requestInit?: never;\n  eventSourceInit?: never;\n  authProvider?: never;\n  reconnectionOptions?: never;\n  sessionId?: never;\n  preferSSE?: never;\n};\n\ntype HttpServerConfig = BaseServerConfig & {\n  url: URL;\n  requestInit?: StreamableHTTPClientTransportOptions['requestInit'];\n  eventSourceInit?: SSEClientTransportOptions['eventSourceInit'];\n  authProvider?: StreamableHTTPClientTransportOptions['authProvider'];\n  reconnectionOptions?: StreamableHTTPClientTransportOptions['reconnectionOptions'];\n  sessionId?: StreamableHTTPClientTransportOptions['sessionId'];\n  preferSSE?: boolean;\n\n  command?: never;\n  args?: never;\n  env?: never;\n};\n\nexport type MCPServerConfig = StdioServerConfig | HttpServerConfig;\n\nexport type MCPClientManagerConfig = Record<string, MCPServerConfig>;\n\ntype NotificationSchema = Parameters<Client['setNotificationHandler']>[0];\ntype NotificationHandler = Parameters<Client['setNotificationHandler']>[1];\n\ninterface NotificationHandlerEntry {\n  schema: NotificationSchema;\n  handler: NotificationHandler;\n}\n\ninterface ManagedClientState {\n  config: MCPServerConfig;\n  client?: Client;\n  transport?: Transport;\n  connectionPromise?: Promise<Client>;\n  timeout: number;\n}\n\ntype ClientRequestOptions = RequestOptions;\ntype CallToolOptions = RequestOptions;\n\ntype ListResourcesParams = Parameters<Client['listResources']>[0];\ntype ListResourceTemplatesParams = Parameters<Client['listResourceTemplates']>[0];\ntype ReadResourceParams = Parameters<Client['readResource']>[0];\ntype SubscribeResourceParams = Parameters<Client['subscribeResource']>[0];\ntype UnsubscribeResourceParams = Parameters<Client['unsubscribeResource']>[0];\ntype ListPromptsParams = Parameters<Client['listPrompts']>[0];\ntype GetPromptParams = Parameters<Client['getPrompt']>[0];\n\nexport type ExecuteToolArguments = Record<string, unknown>;\n\nexport class MCPClientManager {\n  private readonly serverConfigs = new Map<string, MCPServerConfig>();\n  private readonly clientStates = new Map<string, ManagedClientState>();\n  private readonly notificationHandlers = new Map<string, NotificationHandlerEntry[]>();\n  private readonly defaultClientVersion: string;\n  private readonly defaultCapabilities: ClientCapabilityOptions;\n  private readonly defaultTimeout: number;\n\n  constructor(\n    servers: MCPClientManagerConfig = {},\n    options: {\n      defaultClientVersion?: string;\n      defaultCapabilities?: ClientCapabilityOptions;\n      defaultTimeout?: number;\n    } = {},\n  ) {\n    this.defaultClientVersion = options.defaultClientVersion ?? '1.0.0';\n    this.defaultCapabilities = { ...(options.defaultCapabilities ?? {}) };\n    this.defaultTimeout = options.defaultTimeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;\n\n    for (const [name, config] of Object.entries(servers)) {\n      this.registerServer(name, config);\n    }\n  }\n\n  registerServer(name: string, config: MCPServerConfig): void {\n    const serverName = name.trim();\n    if (!serverName) {\n      throw new Error('Server name must be a non-empty string.');\n    }\n\n    const state = this.clientStates.get(serverName);\n    if (state?.connectionPromise) {\n      throw new Error(`Server \"${serverName}\" is currently connecting. Disconnect before reconfiguring.`);\n    }\n    if (state?.client) {\n      throw new Error(`Server \"${serverName}\" is already connected. Disconnect before reconfiguring.`);\n    }\n\n    this.serverConfigs.set(serverName, config);\n    this.clientStates.set(serverName, {\n      config,\n      timeout: this.getTimeout(config),\n    });\n  }\n\n  unregisterServer(name: string): void {\n    const serverName = name.trim();\n    const state = this.clientStates.get(serverName);\n    if (state?.client || state?.connectionPromise) {\n      throw new Error(`Cannot unregister server \"${serverName}\" while it is connected. Disconnect first.`);\n    }\n\n    this.serverConfigs.delete(serverName);\n    this.clientStates.delete(serverName);\n    this.notificationHandlers.delete(serverName);\n  }\n\n  listServers(): string[] {\n    return Array.from(this.serverConfigs.keys());\n  }\n\n  hasServer(name: string): boolean {\n    return this.serverConfigs.has(name.trim());\n  }\n\n  async connectToServer(name: string): Promise<Client> {\n    const serverName = name.trim();\n    const config = this.getServerConfig(serverName);\n    const state = this.ensureState(serverName, config);\n\n    if (state.client) {\n      return state.client;\n    }\n\n    if (state.connectionPromise) {\n      return state.connectionPromise;\n    }\n\n    const connectionPromise = this.createClientAndConnect(serverName, config)\n      .then(client => {\n        const updatedState = this.clientStates.get(serverName);\n        if (!updatedState) {\n          return client;\n        }\n\n        updatedState.client = client;\n        updatedState.connectionPromise = undefined;\n        updatedState.timeout = this.getTimeout(config);\n        return client;\n      })\n      .catch(error => {\n        this.resetState(serverName, { preserveConfig: true });\n        throw error;\n      });\n\n    state.connectionPromise = connectionPromise;\n    this.clientStates.set(serverName, state);\n    return connectionPromise;\n  }\n\n  async disconnectServer(name: string): Promise<void> {\n    const serverName = name.trim();\n    const state = this.clientStates.get(serverName);\n\n    if (!state?.client) {\n      state?.connectionPromise?.catch(() => undefined);\n      state ? (state.connectionPromise = undefined) : undefined;\n      return;\n    }\n\n    try {\n      await state.client.close();\n      await state.transport?.close();\n    } finally {\n      this.resetState(serverName, { preserveConfig: true });\n    }\n  }\n\n  async disconnectAll(): Promise<void> {\n    await Promise.all(this.listServers().map(name => this.disconnectServer(name)));\n  }\n\n  async listTools(name: string, params?: Parameters<Client['listTools']>[0], options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.listTools(params, this.withTimeout(name, options));\n  }\n\n  async executeTool(name: string, toolName: string, args: ExecuteToolArguments = {}, options?: CallToolOptions) {\n    const client = await this.connectToServer(name);\n    return client.callTool(\n      {\n        name: toolName,\n        arguments: args,\n      },\n      CallToolResultSchema,\n      this.withTimeout(name, options),\n    );\n  }\n\n  async listResources(name: string, params?: ListResourcesParams, options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.listResources(params, this.withTimeout(name, options));\n  }\n\n  async readResource(name: string, params: ReadResourceParams, options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.readResource(params, this.withTimeout(name, options));\n  }\n\n  async subscribeResource(name: string, params: SubscribeResourceParams, options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.subscribeResource(params, this.withTimeout(name, options));\n  }\n\n  async unsubscribeResource(name: string, params: UnsubscribeResourceParams, options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.unsubscribeResource(params, this.withTimeout(name, options));\n  }\n\n  async listResourceTemplates(name: string, params?: ListResourceTemplatesParams, options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.listResourceTemplates(params, this.withTimeout(name, options));\n  }\n\n  async listPrompts(name: string, params?: ListPromptsParams, options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.listPrompts(params, this.withTimeout(name, options));\n  }\n\n  async getPrompt(name: string, params: GetPromptParams, options?: ClientRequestOptions) {\n    const client = await this.connectToServer(name);\n    return client.getPrompt(params, this.withTimeout(name, options));\n  }\n\n  getSessionId(name: string): string | undefined {\n    const state = this.clientStates.get(name.trim());\n    if (!state?.transport) {\n      return undefined;\n    }\n    if (state.transport instanceof StreamableHTTPClientTransport) {\n      return state.transport.sessionId;\n    }\n    return undefined;\n  }\n\n  addNotificationHandler(name: string, schema: NotificationSchema, handler: NotificationHandler): void {\n    const serverName = name.trim();\n    const handlers = this.notificationHandlers.get(serverName) ?? [];\n    handlers.push({ schema, handler });\n    this.notificationHandlers.set(serverName, handlers);\n\n    const client = this.clientStates.get(serverName)?.client;\n    if (client) {\n      client.setNotificationHandler(schema, handler);\n    }\n  }\n\n  onResourceListChanged(name: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(name, ResourceListChangedNotificationSchema, handler);\n  }\n\n  onResourceUpdated(name: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(name, ResourceUpdatedNotificationSchema, handler);\n  }\n\n  onPromptListChanged(name: string, handler: NotificationHandler): void {\n    this.addNotificationHandler(name, PromptListChangedNotificationSchema, handler);\n  }\n\n  getClient(name: string): Client | undefined {\n    return this.clientStates.get(name.trim())?.client;\n  }\n\n  private async createClientAndConnect(serverName: string, config: MCPServerConfig): Promise<Client> {\n    const capabilities = this.buildCapabilities(config);\n\n    const client = new Client(\n      {\n        name: serverName,\n        version: config.version ?? this.defaultClientVersion,\n      },\n      {\n        capabilities,\n      },\n    );\n\n    this.applyNotificationHandlers(serverName, client);\n\n    if (config.onError) {\n      client.onerror = error => {\n        config.onError?.(error);\n      };\n    }\n\n    client.onclose = () => {\n      this.resetState(serverName, { preserveConfig: true });\n    };\n\n    const timeout = this.getTimeout(config);\n\n    if (this.isStdioConfig(config)) {\n      const transport = await this.connectViaStdio(client, config, timeout);\n      this.setTransport(serverName, transport);\n      return client;\n    }\n\n    const transport = await this.connectViaHttp(serverName, client, config, timeout);\n    this.setTransport(serverName, transport);\n    return client;\n  }\n\n  private async connectViaStdio(client: Client, config: StdioServerConfig, timeout: number): Promise<Transport> {\n    const transport = new StdioClientTransport({\n      command: config.command,\n      args: config.args,\n      env: { ...getDefaultEnvironment(), ...(config.env ?? {}) },\n    });\n    await client.connect(transport, { timeout });\n    return transport;\n  }\n\n  private async connectViaHttp(serverName: string, client: Client, config: HttpServerConfig, timeout: number): Promise<Transport> {\n    const preferSSE = config.preferSSE ?? config.url.pathname.endsWith('/sse');\n    let streamableError: unknown;\n\n    if (!preferSSE) {\n      const streamableTransport = new StreamableHTTPClientTransport(config.url, {\n        requestInit: config.requestInit,\n        reconnectionOptions: config.reconnectionOptions,\n        authProvider: config.authProvider,\n        sessionId: config.sessionId,\n      });\n\n      try {\n        await client.connect(streamableTransport, { timeout: Math.min(timeout, 3000) });\n        return streamableTransport;\n      } catch (error) {\n        streamableError = error;\n        await this.safeCloseTransport(streamableTransport);\n      }\n    }\n\n    const sseTransport = new SSEClientTransport(config.url, {\n      requestInit: config.requestInit,\n      eventSourceInit: config.eventSourceInit,\n      authProvider: config.authProvider,\n    });\n\n    try {\n      await client.connect(sseTransport, { timeout });\n      return sseTransport;\n    } catch (error) {\n      await this.safeCloseTransport(sseTransport);\n      const streamableMessage = streamableError\n        ? ` Streamable HTTP error: ${this.formatError(streamableError)}.`\n        : '';\n      throw new Error(\n        `Failed to connect to MCP server \"${serverName}\" using HTTP transports.${streamableMessage} SSE error: ${this.formatError(error)}.`,\n      );\n    }\n  }\n\n  private async safeCloseTransport(transport: Transport): Promise<void> {\n    try {\n      await transport.close();\n    } catch {\n      // Ignore close errors during cleanup.\n    }\n  }\n\n  private applyNotificationHandlers(serverName: string, client: Client): void {\n    const handlers = this.notificationHandlers.get(serverName);\n    if (!handlers) {\n      return;\n    }\n\n    for (const { schema, handler } of handlers) {\n      client.setNotificationHandler(schema, handler);\n    }\n  }\n\n  private ensureState(name: string, config: MCPServerConfig): ManagedClientState {\n    const existing = this.clientStates.get(name);\n    if (existing) {\n      existing.config = config;\n      existing.timeout = this.getTimeout(config);\n      return existing;\n    }\n\n    const state: ManagedClientState = {\n      config,\n      timeout: this.getTimeout(config),\n    };\n    this.clientStates.set(name, state);\n    return state;\n  }\n\n  private resetState(name: string, options: { preserveConfig: boolean }): void {\n    const state = this.clientStates.get(name);\n    if (!state) {\n      return;\n    }\n\n    if (!options.preserveConfig) {\n      this.clientStates.delete(name);\n      return;\n    }\n\n    state.client = undefined;\n    state.transport = undefined;\n    state.connectionPromise = undefined;\n  }\n\n  private setTransport(name: string, transport: Transport): void {\n    const state = this.clientStates.get(name);\n    if (!state) {\n      return;\n    }\n    state.transport = transport;\n  }\n\n  private withTimeout(name: string, options?: RequestOptions): RequestOptions {\n    const timeout = this.clientStates.get(name.trim())?.timeout ?? this.defaultTimeout;\n\n    if (!options) {\n      return { timeout };\n    }\n\n    if (options.timeout === undefined) {\n      return { ...options, timeout };\n    }\n\n    return options;\n  }\n\n  private getServerConfig(name: string): MCPServerConfig {\n    const config = this.serverConfigs.get(name);\n    if (!config) {\n      throw new Error(`Unknown MCP server \"${name}\".`);\n    }\n    return config;\n  }\n\n  private buildCapabilities(config: MCPServerConfig): ClientCapabilityOptions {\n    const capabilities: ClientCapabilityOptions = {\n      ...this.defaultCapabilities,\n      ...(config.capabilities ?? {}),\n    };\n\n    if (!capabilities.elicitation) {\n      capabilities.elicitation = {};\n    }\n\n    return capabilities;\n  }\n\n  private formatError(error: unknown): string {\n    if (error instanceof Error) {\n      return error.message;\n    }\n\n    try {\n      return JSON.stringify(error);\n    } catch {\n      return String(error);\n    }\n  }\n\n  private getTimeout(config: MCPServerConfig): number {\n    return config.timeout ?? this.defaultTimeout;\n  }\n\n  private isStdioConfig(config: MCPServerConfig): config is StdioServerConfig {\n    return 'command' in config;\n  }\n\n}\n"],"mappings":"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","names":["_a","transport"]}