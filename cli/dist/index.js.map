{"version":3,"sources":["../src/index.ts","../src/commands/evals.ts","../schemas/test-schema.ts","../schemas/environment-schema.ts","../src/runner/test-runner.ts","../src/server/tests-router.ts","../../server/services/mcpjam-client-manager.ts","../../server/utils/mcp-utils.ts","../src/utils/env-resolver.ts"],"sourcesContent":["import { Command } from \"commander\";\nimport { evalsCommand } from \"./commands/evals.js\";\n\nconst program = new Command();\n\nprogram\n  .name(\"mcpjam\")\n  .description(\"MCPJam CLI for programmatic MCP testing\")\n  .version(\"1.0.0\");\n\nprogram.addCommand(evalsCommand);\n\nprogram.parse();\n","import { Command } from \"commander\";\nimport { readFile } from \"fs/promises\";\nimport { resolve } from \"path\";\nimport { TestsFileSchema } from \"../../schemas/test-schema.js\";\nimport { EnvironmentFileSchema } from \"../../schemas/environment-schema.js\";\nimport { runTests } from \"../runner/test-runner.js\";\nimport { resolveEnvironmentVariables } from \"../utils/env-resolver.js\";\n\nexport const evalsCommand = new Command(\"evals\");\n\nevalsCommand\n  .description(\"Run MCP evaluations\")\n  .command(\"run\")\n  .description(\"Run tests against MCP servers\")\n  .requiredOption(\"-t, --tests <file>\", \"Path to tests JSON file\")\n  .requiredOption(\"-e, --environment <file>\", \"Path to environment JSON file\")\n  .action(async (options) => {\n    try {\n      console.log(\"MCPJAM Evals v1.0.0\\n\");\n\n      // Read and parse test file\n      const testsContent = await readFile(resolve(options.tests), \"utf8\");\n      const testsData = TestsFileSchema.parse(JSON.parse(testsContent));\n\n      // Read and parse environment file\n      const envContent = await readFile(resolve(options.environment), \"utf8\");\n      const envData = EnvironmentFileSchema.parse(JSON.parse(envContent));\n\n      // Resolve environment variables\n      const resolvedEnv = resolveEnvironmentVariables(envData);\n\n      console.log(`Running ${testsData.tests.length} tests...\\n`);\n\n      // Run tests\n      const results = await runTests(testsData.tests, resolvedEnv);\n\n      // Display results\n      console.log(\n        `\\nResults: ${results.passed} passed, ${results.failed} failed (${results.duration}s total)\\n`,\n      );\n\n      // Exit with error code if any tests failed\n      if (results.failed > 0) {\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error(\n        \"❌ Error:\",\n        error instanceof Error ? error.message : String(error),\n      );\n      process.exit(1);\n    }\n  });\n","import { z } from \"zod\";\n\nexport const ModelSchema = z.object({\n  id: z.string(),\n  provider: z.enum([\"openai\", \"anthropic\", \"deepseek\", \"ollama\"]),\n});\n\nexport const AdvancedConfigSchema = z.object({\n  instructions: z.string().optional(),\n  temperature: z.number().min(0).max(2).optional(),\n  maxSteps: z.number().positive().optional(),\n  toolChoice: z.enum([\"auto\", \"required\", \"none\"]).optional(),\n});\n\nexport const TestSchema = z.object({\n  title: z.string(),\n  prompt: z.string(),\n  expectedTools: z.array(z.string()),\n  model: ModelSchema,\n  selectedServers: z.array(z.string()),\n  advancedConfig: AdvancedConfigSchema.optional(),\n});\n\nexport const TestsFileSchema = z.object({\n  tests: z.array(TestSchema),\n});\n\nexport type Model = z.infer<typeof ModelSchema>;\nexport type AdvancedConfig = z.infer<typeof AdvancedConfigSchema>;\nexport type Test = z.infer<typeof TestSchema>;\nexport type TestsFile = z.infer<typeof TestsFileSchema>;\n","import { z } from \"zod\";\n\nexport const MCPServerConfigSchema = z.union([\n  // STDIO server\n  z.object({\n    command: z.string(),\n    args: z.array(z.string()).optional(),\n    env: z.record(z.string()).optional(),\n  }),\n  // HTTP server\n  z.object({\n    url: z.string().url(),\n    headers: z.record(z.string()).optional(),\n  }),\n]);\n\nexport const EnvironmentFileSchema = z.object({\n  mcpServers: z.record(MCPServerConfigSchema),\n  providerApiKeys: z\n    .object({\n      anthropic: z.string().optional(),\n      openai: z.string().optional(),\n      deepseek: z.string().optional(),\n    })\n    .optional(),\n});\n\nexport type MCPServerConfig = z.infer<typeof MCPServerConfigSchema>;\nexport type EnvironmentFile = z.infer<typeof EnvironmentFileSchema>;\n","import { createServer } from \"http\";\nimport { serve } from \"@hono/node-server\";\nimport { Hono } from \"hono\";\nimport type { Test } from \"../../schemas/test-schema.js\";\nimport type { EnvironmentFile } from \"../../schemas/environment-schema.js\";\nimport { createTestsRouter } from \"../server/tests-router.js\";\n\nasync function findAvailablePort(startPort = 3500): Promise<number> {\n  return new Promise((resolve, reject) => {\n    const server = createServer();\n    server.listen(0, () => {\n      const port = (server.address() as any)?.port;\n      server.close(() => {\n        resolve(port || startPort);\n      });\n    });\n    server.on(\"error\", () => {\n      resolve(startPort);\n    });\n  });\n}\n\nexport interface TestResult {\n  testId: string;\n  title: string;\n  passed: boolean;\n  calledTools: string[];\n  missingTools: string[];\n  unexpectedTools: string[];\n  error?: string;\n  duration: number;\n}\n\nexport interface TestRunResults {\n  passed: number;\n  failed: number;\n  duration: string;\n  results: TestResult[];\n}\n\nexport async function runTests(\n  tests: Test[],\n  environment: EnvironmentFile,\n): Promise<TestRunResults> {\n  const startTime = Date.now();\n\n  // Start temporary backend server\n  const app = new Hono();\n  app.route(\"/mcp/tests\", createTestsRouter());\n\n  // Find an available port\n  const port = await findAvailablePort();\n  const server = serve({\n    fetch: app.fetch,\n    port,\n  });\n\n  // Wait a moment for server to start\n  await new Promise((resolve) => setTimeout(resolve, 100));\n\n  try {\n    // Convert tests to backend format\n    const backendTests = tests.map((test, index) => ({\n      id: `test_${index}`,\n      title: test.title,\n      prompt: test.prompt,\n      expectedTools: test.expectedTools,\n      model: test.model,\n      selectedServers: test.selectedServers,\n    }));\n\n    // Convert environment to backend format\n    const backendServers = Object.fromEntries(\n      Object.entries(environment.mcpServers).map(([name, config]) => [\n        name,\n        convertServerConfig(config),\n      ]),\n    );\n\n    const payload = {\n      tests: backendTests,\n      allServers: backendServers,\n      providerApiKeys: environment.providerApiKeys || {},\n    };\n\n    // Make request to backend\n    const response = await fetch(`http://localhost:${port}/mcp/tests/run-all`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Server error: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    // Process streaming response\n    const results = await processStreamingResults(response, tests);\n\n    const duration = ((Date.now() - startTime) / 1000).toFixed(1);\n\n    return {\n      passed: results.filter((r) => r.passed).length,\n      failed: results.filter((r) => !r.passed).length,\n      duration,\n      results,\n    };\n  } finally {\n    if (server && typeof server.close === \"function\") {\n      server.close();\n    }\n  }\n}\n\nfunction convertServerConfig(config: any): any {\n  if (\"command\" in config) {\n    // STDIO server\n    return {\n      command: config.command,\n      args: config.args || [],\n      env: config.env || {},\n    };\n  } else {\n    // HTTP server - keep URL as string per schema\n    return {\n      url: config.url,\n      requestInit: {\n        headers: config.headers || {},\n      },\n      eventSourceInit: {\n        headers: config.headers || {},\n      },\n    };\n  }\n}\n\nasync function processStreamingResults(\n  response: Response,\n  tests: Test[],\n): Promise<TestResult[]> {\n  const results: TestResult[] = [];\n  const reader = response.body?.getReader();\n  const decoder = new TextDecoder();\n\n  if (!reader) {\n    throw new Error(\"No response body\");\n  }\n\n  let buffer = \"\";\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n\n    buffer += decoder.decode(value, { stream: true });\n\n    // Process complete lines\n    const lines = buffer.split(\"\\n\");\n    buffer = lines.pop() || \"\";\n\n    for (const line of lines) {\n      if (line.startsWith(\"data: \")) {\n        const data = line.slice(6);\n        if (data === \"[DONE]\") break;\n\n        try {\n          const event = JSON.parse(data);\n\n          if (event.type === \"result\") {\n            const testIndex = parseInt(event.testId.split(\"_\")[1]);\n            const test = tests[testIndex];\n            const testStart = Date.now();\n\n            const result: TestResult = {\n              testId: event.testId,\n              title: test?.title || \"Unknown Test\",\n              passed: event.passed,\n              calledTools: event.calledTools || [],\n              missingTools: event.missingTools || [],\n              unexpectedTools: event.unexpectedTools || [],\n              error: event.error,\n              duration: 0, // We don't have individual timing from the stream\n            };\n\n            results.push(result);\n\n            // Print result immediately\n            if (result.passed) {\n              console.log(`✅ ${result.title}`);\n              console.log(\n                `   Called tools: ${result.calledTools.join(\", \") || \"none\"}`,\n              );\n            } else {\n              console.log(`❌ ${result.title}`);\n              if (result.error) {\n                console.log(`   Error: ${result.error}`);\n              } else {\n                console.log(\n                  `   Called tools: ${result.calledTools.join(\", \") || \"none\"}`,\n                );\n                if (result.missingTools.length > 0) {\n                  console.log(`   Missing: ${result.missingTools.join(\", \")}`);\n                }\n                if (result.unexpectedTools.length > 0) {\n                  console.log(\n                    `   Unexpected: ${result.unexpectedTools.join(\", \")}`,\n                  );\n                }\n              }\n            }\n          } else if (event.type === \"trace_step\") {\n            // Optional: could show progress steps\n          }\n        } catch (e) {\n          // Ignore malformed JSON\n        }\n      }\n    }\n  }\n\n  return results;\n}\n","import { Hono } from \"hono\";\nimport { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport { createOllama } from \"ollama-ai-provider\";\nimport { Agent } from \"@mastra/core/agent\";\nimport { MCPJamClientManager } from \"../../../server/services/mcpjam-client-manager.js\";\n\n// Simplified version of the server's tests router for CLI use\nexport function createTestsRouter() {\n  const tests = new Hono();\n\n  tests.post(\"/run-all\", async (c) => {\n    const encoder = new TextEncoder();\n    try {\n      const body = await c.req.json();\n      const testsInput = (body?.tests || []) as Array<{\n        id: string;\n        title: string;\n        prompt: string;\n        expectedTools: string[];\n        model: { id: string; provider: string };\n        selectedServers?: string[];\n      }>;\n      const allServers = body?.allServers || {};\n      const providerApiKeys = body?.providerApiKeys || {};\n\n      if (!Array.isArray(testsInput) || testsInput.length === 0) {\n        return c.json({ success: false, error: \"No tests provided\" }, 400);\n      }\n\n      function createModel(model: { id: string; provider: string }) {\n        switch (model.provider) {\n          case \"anthropic\":\n            return createAnthropic({\n              apiKey:\n                providerApiKeys?.anthropic ||\n                process.env.ANTHROPIC_API_KEY ||\n                \"\",\n            })(model.id);\n          case \"openai\":\n            return createOpenAI({\n              apiKey:\n                providerApiKeys?.openai || process.env.OPENAI_API_KEY || \"\",\n            })(model.id);\n          case \"deepseek\":\n            return createOpenAI({\n              apiKey:\n                providerApiKeys?.deepseek || process.env.DEEPSEEK_API_KEY || \"\",\n              baseURL: \"https://api.deepseek.com/v1\",\n            })(model.id);\n          case \"ollama\":\n            return createOllama({\n              baseURL: process.env.OLLAMA_BASE_URL || \"http://localhost:11434\",\n            })(model.id, { simulateStreaming: true });\n          default:\n            throw new Error(`Unsupported provider: ${model.provider}`);\n        }\n      }\n\n      const readableStream = new ReadableStream({\n        async start(controller) {\n          let failed = false;\n\n          const clientManager = new MCPJamClientManager();\n\n          for (const test of testsInput) {\n            console.log(`🔍 Starting test: ${test.title}`);\n            const calledTools = new Set<string>();\n            const expectedSet = new Set<string>(test.expectedTools || []);\n\n            // Build servers for this test - keep in outer scope for cleanup\n            let serverConfigs: Record<string, any> = {};\n            if (test.selectedServers && test.selectedServers.length > 0) {\n              for (const name of test.selectedServers) {\n                if (allServers[name]) serverConfigs[name] = allServers[name];\n              }\n            } else {\n              serverConfigs = allServers;\n            }\n\n            console.log(\n              `📋 Test ${test.title} using servers: ${Object.keys(serverConfigs).join(\", \")}`,\n            );\n\n            if (Object.keys(serverConfigs).length === 0) {\n              console.error(\n                `❌ No valid MCP server configs for test ${test.title}`,\n              );\n              continue;\n            }\n\n            try {\n              // Connect to all servers for this test using the client manager (like chat route)\n              console.log(`🔌 Connecting to servers for ${test.title}...`);\n              for (const [serverName, serverConfig] of Object.entries(\n                serverConfigs,\n              )) {\n                console.log(`   Connecting to ${serverName}...`);\n                await clientManager.connectToServer(serverName, serverConfig);\n                console.log(`   ✅ Connected to ${serverName}`);\n              }\n\n              console.log(\n                `🤖 Creating model ${test.model.provider}:${test.model.id}...`,\n              );\n              const model = createModel(test.model);\n\n              console.log(`🛠️  Getting tools for ${test.title}...`);\n\n              // Get available tools and create the tool structure like chat.ts\n              const allTools = clientManager.getAvailableTools();\n              const toolsByServer: Record<string, any> = {};\n\n              // Group tools by server for the agent (like chat route)\n              for (const tool of allTools) {\n                if (!toolsByServer[tool.serverId]) {\n                  toolsByServer[tool.serverId] = {};\n                }\n                toolsByServer[tool.serverId][tool.name] = {\n                  description: tool.description,\n                  inputSchema: tool.inputSchema,\n                  execute: async (params: any) => {\n                    const result = await clientManager.executeToolDirect(\n                      `${tool.serverId}:${tool.name}`,\n                      params,\n                    );\n                    return result.result;\n                  },\n                };\n              }\n\n              console.log(\n                `✅ Got ${allTools.length} total tools across ${Object.keys(toolsByServer).length} servers`,\n              );\n              // Map unique server IDs back to original names for readability using client manager helper\n              console.log(\n                `🔍 Servers:`,\n                clientManager.mapIdsToOriginalNames(Object.keys(toolsByServer)),\n              );\n\n              const agent = new Agent({\n                name: `TestAgent-${test.id}`,\n                instructions:\n                  \"You are a helpful assistant with access to MCP tools\",\n                model,\n              });\n\n              console.log(`💬 Starting agent stream for ${test.title}...`);\n              const streamOptions: any = {\n                maxSteps: 10,\n                toolsets: toolsByServer,\n                onStepFinish: ({\n                  text,\n                  toolCalls,\n                  toolResults,\n                }: {\n                  text: string;\n                  toolCalls?: any[];\n                  toolResults?: any[];\n                }) => {\n                  if (toolCalls && toolCalls.length) {\n                    console.log(\n                      `🛠️  Tool calls:`,\n                      toolCalls.map((c: any) => c?.name || c?.toolName),\n                    );\n                  }\n                  // Accumulate tool names\n                  (toolCalls || []).forEach((c: any) => {\n                    const toolName = c?.name || c?.toolName;\n                    if (toolName) {\n                      calledTools.add(toolName);\n                    }\n                  });\n                },\n              };\n              // Only set toolChoice if explicitly configured, don't force \"required\"\n              const tAny = test as any;\n              if (tAny?.advancedConfig?.toolChoice) {\n                streamOptions.toolChoice = tAny.advancedConfig.toolChoice;\n              }\n              const stream = await agent.stream(\n                [{ role: \"user\", content: test.prompt || \"\" }] as any,\n                streamOptions,\n              );\n\n              // Drain the stream\n              console.log(`📄 Draining text stream for ${test.title}...`);\n              for await (const _ of stream.textStream) {\n                // no-op\n              }\n              console.log(`✅ Stream completed for ${test.title}`);\n\n              const called = Array.from(calledTools);\n              const missing = Array.from(expectedSet).filter(\n                (t) => !calledTools.has(t),\n              );\n              const unexpected = called.filter((t) => !expectedSet.has(t));\n              const passed = missing.length === 0 && unexpected.length === 0;\n\n              console.log(\n                `📊 Test ${test.title} result: ${passed ? \"PASSED\" : \"FAILED\"}`,\n              );\n              if (!passed) failed = true;\n\n              controller.enqueue(\n                encoder.encode(\n                  `data: ${JSON.stringify({\n                    type: \"result\",\n                    testId: test.id,\n                    passed,\n                    calledTools: called,\n                    missingTools: missing,\n                    unexpectedTools: unexpected,\n                  })}\\n\\n`,\n                ),\n              );\n            } catch (err) {\n              console.error(`❌ Test ${test.title} failed:`, err);\n              failed = true;\n              controller.enqueue(\n                encoder.encode(\n                  `data: ${JSON.stringify({\n                    type: \"result\",\n                    testId: test.id,\n                    passed: false,\n                    error: (err as Error)?.message,\n                  })}\\n\\n`,\n                ),\n              );\n            } finally {\n              console.log(`🔌 Disconnecting servers for ${test.title}...`);\n              for (const serverName of Object.keys(serverConfigs)) {\n                try {\n                  await clientManager.disconnectFromServer(serverName);\n                  console.log(`   ✅ Disconnected from ${serverName}`);\n                } catch (disconnectErr) {\n                  console.log(\n                    `   ⚠️  Disconnect error from ${serverName}:`,\n                    disconnectErr,\n                  );\n                }\n              }\n              console.log(`✅ Test ${test.title} cleanup complete`);\n            }\n          }\n\n          controller.enqueue(\n            encoder.encode(\n              `data: ${JSON.stringify({\n                type: \"run_complete\",\n                passed: !failed,\n              })}\\n\\n`,\n            ),\n          );\n          controller.enqueue(encoder.encode(`data: [DONE]\\n\\n`));\n          controller.close();\n        },\n      });\n\n      return new Response(readableStream, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n          \"Cache-Control\": \"no-cache\",\n          Connection: \"keep-alive\",\n        },\n      });\n    } catch (err) {\n      return c.json(\n        { success: false, error: (err as Error)?.message || \"Unknown error\" },\n        500,\n      );\n    }\n  });\n\n  return tests;\n}\n","import { MCPClient, MastraMCPServerDefinition } from \"@mastra/mcp\";\nimport { validateServerConfig } from \"../utils/mcp-utils\";\n\nexport type ConnectionStatus =\n  | \"disconnected\"\n  | \"connecting\"\n  | \"connected\"\n  | \"error\";\n\nexport interface DiscoveredTool {\n  name: string;\n  description?: string;\n  inputSchema: any;\n  outputSchema?: any;\n  serverId: string;\n}\n\nexport interface DiscoveredResource {\n  uri: string;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  serverId: string;\n}\n\nexport interface DiscoveredPrompt {\n  name: string;\n  description?: string;\n  arguments?: Record<string, any>;\n  serverId: string;\n}\n\nexport interface ChatMessage {\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n}\n\nexport interface ChatResponse {\n  text?: string;\n  toolCalls?: any[];\n  toolResults?: any[];\n}\n\nexport interface ToolResult {\n  result: any;\n}\n\nexport interface ElicitationRequest {\n  message: string;\n  requestedSchema: any;\n}\n\nexport interface ElicitationResponse {\n  [key: string]: unknown;\n  action: \"accept\" | \"decline\" | \"cancel\";\n  content?: any;\n  _meta?: any;\n}\n\nexport interface ResourceContent {\n  contents: any[];\n}\n\nexport interface PromptResult {\n  content: any;\n}\n\nfunction generateUniqueServerId(serverId: string) {\n  // Generate unique server ID that avoids collisions\n  const normalizedBase = serverId\n    .toLowerCase()\n    .replace(/[\\s\\-]+/g, \"_\")\n    .replace(/[^a-z0-9_]/g, \"\");\n  const timestamp = Date.now().toString(36);\n  const random = Math.random().toString(36).substring(2, 8);\n  return `${normalizedBase}_${timestamp}_${random}`;\n}\n\nclass MCPJamClientManager {\n  private mcpClients: Map<string, MCPClient> = new Map();\n  private statuses: Map<string, ConnectionStatus> = new Map();\n  private configs: Map<string, MastraMCPServerDefinition> = new Map();\n\n  // Map original server names to unique IDs\n  private serverIdMapping: Map<string, string> = new Map();\n\n  // Track in-flight connections to avoid duplicate concurrent connects\n  private pendingConnections: Map<string, Promise<void>> = new Map();\n\n  private toolRegistry: Map<string, DiscoveredTool> = new Map();\n  private resourceRegistry: Map<string, DiscoveredResource> = new Map();\n  private promptRegistry: Map<string, DiscoveredPrompt> = new Map();\n\n  // Store for pending elicitation requests with Promise resolvers\n  private pendingElicitations: Map<\n    string,\n    {\n      resolve: (response: ElicitationResponse) => void;\n      reject: (error: any) => void;\n    }\n  > = new Map();\n\n  // Optional callback for handling elicitation requests\n  private elicitationCallback?: (request: {\n    requestId: string;\n    message: string;\n    schema: any;\n  }) => Promise<ElicitationResponse>;\n\n  // Helper method to get unique ID for a server name\n  private getServerUniqueId(serverName: string): string | undefined {\n    return this.serverIdMapping.get(serverName);\n  }\n\n  // Public method to get server ID for external use (like frontend)\n  getServerIdForName(serverName: string): string | undefined {\n    return this.serverIdMapping.get(serverName);\n  }\n\n  // Public method to get original server name from a unique server ID\n  getOriginalNameForId(uniqueServerId: string): string | undefined {\n    for (const [originalName, uid] of this.serverIdMapping.entries()) {\n      if (uid === uniqueServerId) return originalName;\n    }\n    return undefined;\n  }\n\n  // Convenience: map an array of unique IDs to their original names (fallback to ID if not found)\n  mapIdsToOriginalNames(uniqueIds: string[]): string[] {\n    return uniqueIds.map((id) => this.getOriginalNameForId(id) || id);\n  }\n\n  async connectToServer(serverId: string, serverConfig: any): Promise<void> {\n    // If a connection is already in-flight for this server name, wait for it\n    const pending = this.pendingConnections.get(serverId);\n    if (pending) {\n      await pending;\n      return;\n    }\n\n    const connectPromise = (async () => {\n      // Reuse existing unique ID for this server name if present; otherwise generate and map one\n      let id = this.serverIdMapping.get(serverId);\n      if (!id) {\n        id = generateUniqueServerId(serverId);\n        this.serverIdMapping.set(serverId, id);\n      }\n\n      // If already connected, no-op\n      if (this.mcpClients.has(id)) return;\n\n      // Validate server configuration\n      const validation = validateServerConfig(serverConfig);\n      if (!validation.success) {\n        this.statuses.set(id, \"error\");\n        throw new Error(validation.error!.message);\n      }\n\n      this.configs.set(id, validation.config!);\n      this.statuses.set(id, \"connecting\");\n\n      const client = new MCPClient({\n        id: `mcpjam-${id}`,\n        servers: { [id]: validation.config! },\n      });\n\n      try {\n        // touch the server to verify connection\n        await client.getTools();\n        this.mcpClients.set(id, client);\n        this.statuses.set(id, \"connected\");\n\n        // Register elicitation handler for this server\n        if (client.elicitation?.onRequest) {\n          client.elicitation.onRequest(\n            id,\n            async (elicitationRequest: ElicitationRequest) => {\n              return await this.handleElicitationRequest(elicitationRequest);\n            },\n          );\n        }\n\n        await this.discoverServerResources(id);\n      } catch (err) {\n        this.statuses.set(id, \"error\");\n        try {\n          await client.disconnect();\n        } catch {}\n        this.mcpClients.delete(id);\n        throw err;\n      }\n    })().finally(() => {\n      this.pendingConnections.delete(serverId);\n    });\n\n    this.pendingConnections.set(serverId, connectPromise);\n    await connectPromise;\n  }\n\n  async disconnectFromServer(serverId: string): Promise<void> {\n    const id = this.getServerUniqueId(serverId);\n    if (!id) return; // Server not found\n\n    const client = this.mcpClients.get(id);\n    if (client) {\n      try {\n        await client.disconnect();\n      } catch {}\n    }\n    this.mcpClients.delete(id);\n    this.statuses.set(id, \"disconnected\");\n    this.serverIdMapping.delete(serverId); // Clean up the mapping\n\n    // purge registries for this server\n    for (const key of Array.from(this.toolRegistry.keys())) {\n      const item = this.toolRegistry.get(key)!;\n      if (item.serverId === id) this.toolRegistry.delete(key);\n    }\n    for (const key of Array.from(this.resourceRegistry.keys())) {\n      const item = this.resourceRegistry.get(key)!;\n      if (item.serverId === id) this.resourceRegistry.delete(key);\n    }\n    for (const key of Array.from(this.promptRegistry.keys())) {\n      const item = this.promptRegistry.get(key)!;\n      if (item.serverId === id) this.promptRegistry.delete(key);\n    }\n  }\n\n  getConnectionStatus(serverId: string): ConnectionStatus {\n    const id = this.getServerUniqueId(serverId);\n    return id ? this.statuses.get(id) || \"disconnected\" : \"disconnected\";\n  }\n\n  getConnectedServers(): Record<\n    string,\n    { status: ConnectionStatus; config?: any }\n  > {\n    const servers: Record<string, { status: ConnectionStatus; config?: any }> =\n      {};\n\n    // Return data keyed by the original server names provided by callers\n    for (const [originalName, uniqueId] of this.serverIdMapping.entries()) {\n      servers[originalName] = {\n        status: this.statuses.get(uniqueId) || \"disconnected\",\n        config: this.configs.get(uniqueId),\n      };\n    }\n\n    return servers;\n  }\n\n  async discoverAllResources(): Promise<void> {\n    const serverIds = Array.from(this.mcpClients.keys());\n    await Promise.all(serverIds.map((id) => this.discoverServerResources(id)));\n  }\n\n  private async discoverServerResources(serverId: string): Promise<void> {\n    // serverId is already the unique ID when called from connectToServer\n    const client = this.mcpClients.get(serverId);\n    if (!client) return;\n\n    // Tools - use toolsets instead of getTools for consistency\n    const toolsets = await client.getToolsets();\n    const flattenedTools: Record<string, any> = {};\n    Object.values(toolsets).forEach((serverTools: any) => {\n      Object.assign(flattenedTools, serverTools);\n    });\n\n    for (const [name, tool] of Object.entries<any>(flattenedTools)) {\n      this.toolRegistry.set(`${serverId}:${name}`, {\n        name,\n        description: tool.description,\n        inputSchema: tool.inputSchema,\n        outputSchema: (tool as any).outputSchema,\n        serverId: serverId,\n      });\n    }\n\n    // Resources\n    try {\n      const res = await client.resources.list();\n      for (const [, list] of Object.entries<any>(res)) {\n        for (const r of list as any[]) {\n          this.resourceRegistry.set(`${serverId}:${r.uri}`, {\n            uri: r.uri,\n            name: r.name,\n            description: r.description,\n            mimeType: r.mimeType,\n            serverId: serverId,\n          });\n        }\n      }\n    } catch {}\n\n    // Prompts\n    try {\n      const prompts = await client.prompts.list();\n      for (const [, list] of Object.entries<any>(prompts)) {\n        for (const p of list as any[]) {\n          this.promptRegistry.set(`${serverId}:${p.name}`, {\n            name: p.name,\n            description: p.description,\n            arguments: p.arguments,\n            serverId: serverId,\n          });\n        }\n      }\n    } catch {}\n  }\n\n  getAvailableTools(): DiscoveredTool[] {\n    return Array.from(this.toolRegistry.values());\n  }\n\n  async getToolsetsForServer(serverId: string): Promise<Record<string, any>> {\n    const id = this.getServerUniqueId(serverId);\n    if (!id) {\n      throw new Error(`No MCP client available for server: ${serverId}`);\n    }\n    const client = this.mcpClients.get(id);\n    if (!client) {\n      throw new Error(`No MCP client available for server: ${serverId}`);\n    }\n\n    // Get toolsets like in the chat route - this gives us server-prefixed tools\n    const toolsets = await client.getToolsets();\n\n    // Flatten toolsets to get un-prefixed tool names like in chat route\n    const flattenedTools: Record<string, any> = {};\n    Object.values(toolsets).forEach((serverTools: any) => {\n      Object.assign(flattenedTools, serverTools);\n    });\n\n    return flattenedTools;\n  }\n  getAvailableResources(): DiscoveredResource[] {\n    return Array.from(this.resourceRegistry.values());\n  }\n\n  getResourcesForServer(serverId: string): DiscoveredResource[] {\n    const id = this.getServerUniqueId(serverId);\n    if (!id) return [];\n    return Array.from(this.resourceRegistry.values()).filter(\n      (r) => r.serverId === id,\n    );\n  }\n\n  getAvailablePrompts(): DiscoveredPrompt[] {\n    return Array.from(this.promptRegistry.values());\n  }\n\n  getPromptsForServer(serverId: string): DiscoveredPrompt[] {\n    const id = this.getServerUniqueId(serverId);\n    if (!id) return [];\n    return Array.from(this.promptRegistry.values()).filter(\n      (p) => p.serverId === id,\n    );\n  }\n\n  async executeToolDirect(\n    toolName: string,\n    parameters: Record<string, any> = {},\n  ): Promise<ToolResult> {\n    // toolName may include server prefix \"serverId:tool\"\n    let serverId = \"\";\n    let name = toolName;\n\n    if (toolName.includes(\":\")) {\n      const [sid, n] = toolName.split(\":\", 2);\n      // Resolve provided server identifier (original name or unique ID) to the unique ID\n      const mappedId = this.getServerUniqueId(sid);\n      serverId = mappedId || (this.mcpClients.has(sid) ? sid : \"\");\n      name = n;\n    } else {\n      // Find which server has this tool by checking un-prefixed name\n      for (const tool of this.toolRegistry.values()) {\n        if (tool.name === toolName) {\n          serverId = tool.serverId;\n          name = toolName;\n          break;\n        }\n      }\n    }\n\n    // If not found in registry, try to find it using toolsets from all connected servers\n    if (!serverId) {\n      for (const [clientServerId, client] of this.mcpClients.entries()) {\n        try {\n          const toolsets = await client.getToolsets();\n          // Flatten toolsets to check for the tool\n          const flattenedTools: Record<string, any> = {};\n          Object.values(toolsets).forEach((serverTools: any) => {\n            Object.assign(flattenedTools, serverTools);\n          });\n\n          if (flattenedTools[toolName]) {\n            serverId = clientServerId;\n            name = toolName;\n            break;\n          }\n        } catch {\n          // Continue to next server if this one fails\n        }\n      }\n    }\n\n    if (!serverId) {\n      throw new Error(`Tool not found in any connected server: ${toolName}`);\n    }\n\n    const client = this.mcpClients.get(serverId);\n    if (!client)\n      throw new Error(`No MCP client available for server: ${serverId}`);\n\n    // Use toolsets to get the actual tool (since tools might be prefixed in getTools())\n    const toolsets = await client.getToolsets();\n    const flattenedTools: Record<string, any> = {};\n    Object.values(toolsets).forEach((serverTools: any) => {\n      Object.assign(flattenedTools, serverTools);\n    });\n\n    const tool = flattenedTools[name];\n    if (!tool)\n      throw new Error(`Tool '${name}' not found in server '${serverId}'`);\n\n    // Inspect input schema to choose the most likely argument shape, but be robust and\n    // fall back to the alternate shape on invalid-arguments errors.\n    const schema: any = (tool as any).inputSchema;\n    const hasContextProperty =\n      schema &&\n      typeof schema === \"object\" &&\n      (schema as any).properties &&\n      Object.prototype.hasOwnProperty.call(\n        (schema as any).properties,\n        \"context\",\n      );\n    const requiresContext =\n      hasContextProperty ||\n      (schema &&\n        Array.isArray((schema as any).required) &&\n        (schema as any).required.includes(\"context\"));\n\n    const contextWrapped = { context: parameters || {} };\n    const direct = parameters || {};\n    const attempts = requiresContext\n      ? [contextWrapped, direct]\n      : [direct, contextWrapped];\n\n    let lastError: any = undefined;\n    for (const args of attempts) {\n      try {\n        const result = await tool.execute(args);\n        return { result };\n      } catch (err: any) {\n        lastError = err;\n      }\n    }\n    throw lastError;\n  }\n\n  async getResource(\n    resourceUri: string,\n    serverId: string,\n  ): Promise<ResourceContent> {\n    // resourceUri may include server prefix\n    let uri = resourceUri;\n    // Resolve provided server identifier (original name or unique ID) to the unique ID\n    const mappedId = this.getServerUniqueId(serverId);\n    const resolvedServerId =\n      mappedId || (this.mcpClients.has(serverId) ? serverId : undefined);\n\n    if (!resolvedServerId) {\n      throw new Error(`No MCP client available for server: ${serverId}`);\n    }\n\n    const client = this.mcpClients.get(resolvedServerId);\n    if (!client) throw new Error(\"No MCP client available\");\n    const content = await client.resources.read(resolvedServerId, uri);\n    return { contents: content?.contents || [] };\n  }\n\n  async getPrompt(\n    promptName: string,\n    serverId: string,\n    args?: Record<string, any>,\n  ): Promise<PromptResult> {\n    // Resolve provided server identifier (original name or unique ID) to the unique ID\n    const mappedId = this.getServerUniqueId(serverId);\n    const resolvedServerId =\n      mappedId || (this.mcpClients.has(serverId) ? serverId : undefined);\n\n    if (!resolvedServerId) {\n      throw new Error(`No MCP client available for server: ${serverId}`);\n    }\n\n    const client = this.mcpClients.get(resolvedServerId);\n    if (!client) throw new Error(\"No MCP client available\");\n    const content = await client.prompts.get({\n      serverName: resolvedServerId,\n      name: promptName,\n      args: args || {},\n    });\n    return { content };\n  }\n\n  /**\n   * Handles elicitation requests from MCP servers during direct tool execution\n   */\n  private async handleElicitationRequest(\n    elicitationRequest: ElicitationRequest,\n  ): Promise<ElicitationResponse> {\n    const requestId = `elicit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Create a promise that will be resolved when the user responds\n    return new Promise<ElicitationResponse>((resolve, reject) => {\n      this.pendingElicitations.set(requestId, { resolve, reject });\n\n      // If there's an active elicitation callback, use it\n      if (this.elicitationCallback) {\n        this.elicitationCallback({\n          requestId,\n          message: elicitationRequest.message,\n          schema: elicitationRequest.requestedSchema,\n        })\n          .then(resolve)\n          .catch(reject);\n      } else {\n        // If no callback is set, reject with details for the tools route to handle\n        const error = new Error(\"ELICITATION_REQUIRED\");\n        (error as any).elicitationRequest = {\n          requestId,\n          message: elicitationRequest.message,\n          schema: elicitationRequest.requestedSchema,\n        };\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Responds to a pending elicitation request\n   */\n  respondToElicitation(\n    requestId: string,\n    response: ElicitationResponse,\n  ): boolean {\n    const pending = this.pendingElicitations.get(requestId);\n    if (!pending) {\n      return false;\n    }\n\n    pending.resolve(response);\n    this.pendingElicitations.delete(requestId);\n    return true;\n  }\n\n  /**\n   * Gets the pending elicitations map for external access\n   */\n  getPendingElicitations(): Map<\n    string,\n    {\n      resolve: (response: ElicitationResponse) => void;\n      reject: (error: any) => void;\n    }\n  > {\n    return this.pendingElicitations;\n  }\n\n  /**\n   * Sets a callback to handle elicitation requests\n   */\n  setElicitationCallback(\n    callback: (request: {\n      requestId: string;\n      message: string;\n      schema: any;\n    }) => Promise<ElicitationResponse>,\n  ): void {\n    this.elicitationCallback = callback;\n  }\n\n  /**\n   * Clears the elicitation callback\n   */\n  clearElicitationCallback(): void {\n    this.elicitationCallback = undefined;\n  }\n}\n\n// Export the class directly instead of singleton\nexport { MCPJamClientManager };\nexport default MCPJamClientManager;\n","import { MastraMCPServerDefinition, MCPClient } from \"@mastra/mcp\";\n\n// Hono-compatible error response type\nexport interface HonoErrorResponse {\n  message: string;\n  status: number;\n}\n\nexport interface ValidationResult {\n  success: boolean;\n  config?: MastraMCPServerDefinition;\n  error?: HonoErrorResponse;\n}\n\nexport interface MultipleValidationResult {\n  success: boolean;\n  validConfigs?: Record<string, MastraMCPServerDefinition>;\n  errors?: Record<string, string>;\n  error?: HonoErrorResponse;\n}\n\nexport function validateServerConfig(serverConfig: any): ValidationResult {\n  if (!serverConfig) {\n    return {\n      success: false,\n      error: {\n        message: \"Server configuration is required\",\n        status: 400,\n      },\n    };\n  }\n\n  // Validate and prepare config\n  const config = { ...serverConfig };\n\n  // Validate and convert URL if provided\n  if (config.url) {\n    try {\n      // Convert string URL to URL object if needed and strip query/hash\n      if (typeof config.url === \"string\") {\n        const parsed = new URL(config.url);\n        parsed.search = \"\";\n        parsed.hash = \"\";\n        config.url = parsed;\n      } else if (typeof config.url === \"object\" && !config.url.href) {\n        return {\n          success: false,\n          error: {\n            message: \"Invalid URL configuration\",\n            status: 400,\n          },\n        };\n      }\n\n      // Handle OAuth authentication for HTTP servers\n      if (config.oauth?.access_token) {\n        const authHeaders = {\n          Authorization: `Bearer ${config.oauth.access_token}`,\n          ...(config.requestInit?.headers || {}),\n        };\n\n        config.requestInit = {\n          ...config.requestInit,\n          headers: authHeaders,\n        };\n\n        // For SSE connections, add eventSourceInit with OAuth headers\n        config.eventSourceInit = {\n          fetch(input: Request | URL | string, init?: RequestInit) {\n            const headers = new Headers(init?.headers || {});\n\n            // Add OAuth authorization header\n            headers.set(\n              \"Authorization\",\n              `Bearer ${config.oauth!.access_token}`,\n            );\n\n            // Copy other headers from requestInit\n            if (config.requestInit?.headers) {\n              const requestHeaders = new Headers(config.requestInit.headers);\n              requestHeaders.forEach((value, key) => {\n                if (key.toLowerCase() !== \"authorization\") {\n                  headers.set(key, value);\n                }\n              });\n            }\n\n            return fetch(input, {\n              ...init,\n              headers,\n            });\n          },\n        };\n      } else if (config.requestInit?.headers) {\n        // For SSE connections without OAuth, add eventSourceInit if requestInit has custom headers\n        config.eventSourceInit = {\n          fetch(input: Request | URL | string, init?: RequestInit) {\n            const headers = new Headers(init?.headers || {});\n\n            // Copy headers from requestInit\n            const requestHeaders = new Headers(config.requestInit.headers);\n            requestHeaders.forEach((value, key) => {\n              headers.set(key, value);\n            });\n\n            return fetch(input, {\n              ...init,\n              headers,\n            });\n          },\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: `Invalid URL format: ${error}`,\n          status: 400,\n        },\n      };\n    }\n  }\n\n  return {\n    success: true,\n    config,\n  };\n}\n\nexport function createMCPClient(\n  config: MastraMCPServerDefinition,\n  id: string,\n): MCPClient {\n  return new MCPClient({\n    id,\n    servers: {\n      server: config,\n    },\n  });\n}\n\nexport interface MultipleValidationResult {\n  success: boolean;\n  validConfigs?: Record<string, MastraMCPServerDefinition>;\n  serverNameMapping?: Record<string, string>; // serverID -> originalName\n  errors?: Record<string, string>;\n  error?: HonoErrorResponse;\n}\n\n// Generate unique server ID that avoids collisions\nfunction generateUniqueServerID(serverName: string): string {\n  // Use normalized name as base + timestamp + random suffix to ensure uniqueness\n  const normalizedBase = normalizeServerConfigName(serverName);\n  const timestamp = Date.now().toString(36);\n  const random = Math.random().toString(36).substring(2, 8);\n  return `${normalizedBase}_${timestamp}_${random}`;\n}\n\nexport const validateMultipleServerConfigs = (\n  serverConfigs: Record<string, MastraMCPServerDefinition>,\n): MultipleValidationResult => {\n  if (!serverConfigs || Object.keys(serverConfigs).length === 0) {\n    return {\n      success: false,\n      error: {\n        message: \"At least one server configuration is required\",\n        status: 400,\n      },\n    };\n  }\n\n  const validConfigs: Record<string, MastraMCPServerDefinition> = {};\n  const serverNameMapping: Record<string, string> = {};\n  const errors: Record<string, string> = {};\n  let hasErrors = false;\n\n  // Validate each server configuration\n  for (const [serverName, serverConfig] of Object.entries(serverConfigs)) {\n    const validationResult = validateServerConfig(serverConfig);\n\n    if (validationResult.success && validationResult.config) {\n      // Generate unique server ID to avoid collisions from normalized names\n      const serverID = generateUniqueServerID(serverName);\n      validConfigs[serverID] = validationResult.config;\n      serverNameMapping[serverID] = serverName; // Map serverID back to original name\n    } else {\n      hasErrors = true;\n      let errorMessage = \"Configuration validation failed\";\n      if (validationResult.error) {\n        errorMessage = validationResult.error.message;\n      }\n      // Use original server name for error keys since this is for user display\n      errors[serverName] = errorMessage;\n    }\n  }\n\n  // If all configs are valid, return success\n  if (!hasErrors) {\n    return {\n      success: true,\n      validConfigs,\n      serverNameMapping,\n    };\n  }\n\n  // If some configs are valid but others failed, return partial success\n  if (Object.keys(validConfigs).length > 0) {\n    return {\n      success: false,\n      validConfigs,\n      serverNameMapping,\n      errors,\n    };\n  }\n\n  // If all configs failed, return error\n  return {\n    success: false,\n    errors,\n    error: {\n      message: \"All server configurations failed validation\",\n      status: 400,\n    },\n  };\n};\n\nexport function createMCPClientWithMultipleConnections(\n  serverConfigs: Record<string, MastraMCPServerDefinition>,\n): MCPClient {\n  // Custom MCPClient wrapper to fix double prefixing issue\n  const originalMCPClient = new MCPClient({\n    id: `chat-${Date.now()}`,\n    servers: serverConfigs,\n  });\n\n  // Override getTools method to fix double prefixing\n  const originalGetTools = originalMCPClient.getTools.bind(originalMCPClient);\n  originalMCPClient.getTools = async () => {\n    const tools = await originalGetTools();\n    const fixedTools: Record<string, any> = {};\n\n    for (const [toolName, toolConfig] of Object.entries(tools)) {\n      // Check if tool name has double prefix pattern (serverName_serverName_actualTool)\n      const parts = toolName.split(\"_\");\n      if (parts.length >= 3 && parts[0] === parts[1]) {\n        // Remove the duplicate prefix: \"asana_asana_list_workspaces\" -> \"asana_list_workspaces\"\n        const fixedName = parts.slice(1).join(\"_\");\n        fixedTools[fixedName] = toolConfig;\n      } else {\n        fixedTools[toolName] = toolConfig;\n      }\n    }\n\n    return fixedTools;\n  };\n\n  return originalMCPClient;\n}\n\nexport function normalizeServerConfigName(serverName: string): string {\n  // Convert to lowercase and replace spaces/hyphens with underscores\n  return serverName\n    .toLowerCase()\n    .replace(/[\\s\\-]+/g, \"_\")\n    .replace(/[^a-z0-9_]/g, \"\");\n}\n\nexport function createErrorResponse(\n  message: string,\n  details?: string,\n  status: number = 500,\n): HonoErrorResponse {\n  return {\n    message: details ? `${message}: ${details}` : message,\n    status,\n  };\n}\n","import type { EnvironmentFile } from \"../../schemas/environment-schema.js\";\n\nexport function resolveEnvironmentVariables(\n  env: EnvironmentFile,\n): EnvironmentFile {\n  return {\n    ...env,\n    mcpServers: Object.fromEntries(\n      Object.entries(env.mcpServers).map(([name, config]) => [\n        name,\n        resolveServerConfig(config),\n      ]),\n    ),\n    providerApiKeys: env.providerApiKeys\n      ? {\n          anthropic: resolveTemplate(env.providerApiKeys.anthropic),\n          openai: resolveTemplate(env.providerApiKeys.openai),\n          deepseek: resolveTemplate(env.providerApiKeys.deepseek),\n        }\n      : undefined,\n  };\n}\n\nfunction resolveServerConfig(config: any): any {\n  if (\"command\" in config) {\n    // STDIO server\n    return {\n      ...config,\n      env: config.env\n        ? Object.fromEntries(\n            Object.entries(config.env).map(([key, value]) => [\n              key,\n              resolveTemplate(value as string),\n            ]),\n          )\n        : undefined,\n    };\n  } else {\n    // HTTP server - handle simple headers format like the UI\n    return {\n      ...config,\n      headers: config.headers\n        ? Object.fromEntries(\n            Object.entries(config.headers).map(([key, value]) => [\n              key,\n              resolveTemplate(value as string),\n            ]),\n          )\n        : undefined,\n    };\n  }\n}\n\nfunction resolveTemplate(value: string | undefined): string | undefined {\n  if (!value) return value;\n  // Collapse whitespace in env var values to avoid broken multi-line exports\n  const collapseWhitespace = (s: string) =>\n    s.replace(/[\\r\\n]+/g, \"\").replace(/\\s{2,}/g, \"\");\n\n  return value.replace(/\\$\\{([^}]+)\\}/g, (match, envVar) => {\n    const raw = process.env[envVar];\n    const resolved = raw ? collapseWhitespace(raw) : raw;\n    if (resolved === undefined) {\n      console.warn(`⚠️  Warning: Environment variable ${envVar} is not set`);\n      return match;\n    }\n    return resolved;\n  });\n}\n"],"mappings":"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","names":["Command","z","Hono","MCPClient","MCPClient","tool","client","toolsets","flattenedTools","resolve","createModel","c","resolve","Hono","Command"]}