module.exports = {

"[project]/.next-internal/server/app/api/mcp/connect/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/node:process [external] (node:process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}}),
"[externals]/node:stream [external] (node:stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}}),
"[externals]/node:crypto [external] (node:crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/string_decoder [external] (string_decoder, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/async_hooks [external] (async_hooks, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("async_hooks", () => require("async_hooks"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/mcp-utils.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createErrorResponse": ()=>createErrorResponse,
    "createMCPClient": ()=>createMCPClient,
    "createMCPClientWithMultipleConnections": ()=>createMCPClientWithMultipleConnections,
    "normalizeServerConfigName": ()=>normalizeServerConfigName,
    "validateMultipleServerConfigs": ()=>validateMultipleServerConfigs,
    "validateServerConfig": ()=>validateServerConfig
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$mcp$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/mcp/dist/index.js [app-route] (ecmascript)");
;
;
function validateServerConfig(serverConfig) {
    if (!serverConfig) {
        return {
            success: false,
            error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Server configuration is required"
            }, {
                status: 400
            })
        };
    }
    // Validate and prepare config
    const config = {
        ...serverConfig
    };
    // Validate and convert URL if provided
    if (config.url) {
        try {
            // Convert string URL to URL object if needed
            if (typeof config.url === "string") {
                config.url = new URL(config.url);
            } else if (typeof config.url === "object" && !config.url.href) {
                return {
                    success: false,
                    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        error: "Invalid URL configuration"
                    }, {
                        status: 400
                    })
                };
            }
            // Handle OAuth authentication for HTTP servers
            if (config.oauth?.access_token) {
                const authHeaders = {
                    Authorization: `Bearer ${config.oauth.access_token}`,
                    ...config.requestInit?.headers || {}
                };
                config.requestInit = {
                    ...config.requestInit,
                    headers: authHeaders
                };
                // For SSE connections, add eventSourceInit with OAuth headers
                config.eventSourceInit = {
                    fetch (input, init) {
                        const headers = new Headers(init?.headers || {});
                        // Add OAuth authorization header
                        headers.set("Authorization", `Bearer ${config.oauth.access_token}`);
                        // Copy other headers from requestInit
                        if (config.requestInit?.headers) {
                            const requestHeaders = new Headers(config.requestInit.headers);
                            requestHeaders.forEach((value, key)=>{
                                if (key.toLowerCase() !== "authorization") {
                                    headers.set(key, value);
                                }
                            });
                        }
                        return fetch(input, {
                            ...init,
                            headers
                        });
                    }
                };
            } else if (config.requestInit?.headers) {
                // For SSE connections without OAuth, add eventSourceInit if requestInit has custom headers
                config.eventSourceInit = {
                    fetch (input, init) {
                        const headers = new Headers(init?.headers || {});
                        // Copy headers from requestInit
                        const requestHeaders = new Headers(config.requestInit.headers);
                        requestHeaders.forEach((value, key)=>{
                            headers.set(key, value);
                        });
                        return fetch(input, {
                            ...init,
                            headers
                        });
                    }
                };
            }
        } catch (error) {
            return {
                success: false,
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: `Invalid URL format: ${error}`
                }, {
                    status: 400
                })
            };
        }
    }
    return {
        success: true,
        config
    };
}
const validateMultipleServerConfigs = (serverConfigs)=>{
    if (!serverConfigs || Object.keys(serverConfigs).length === 0) {
        return {
            success: false,
            error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "At least one server configuration is required"
            }, {
                status: 400
            })
        };
    }
    const validConfigs = {};
    const errors = {};
    let hasErrors = false;
    // Validate each server configuration
    for (const [serverName, serverConfig] of Object.entries(serverConfigs)){
        const validationResult = validateServerConfig(serverConfig);
        if (validationResult.success && validationResult.config) {
            validConfigs[serverName] = validationResult.config;
        } else {
            hasErrors = true;
            // Extract error message from the NextResponse
            let errorMessage = "Validation failed";
            if (validationResult.error) {
                try {
                    const errorBody = validationResult.error.body;
                    if (errorBody && typeof errorBody === "object" && "error" in errorBody) {
                        errorMessage = errorBody.error;
                    }
                } catch  {
                    errorMessage = "Validation failed";
                }
            }
            errors[serverName] = errorMessage;
        }
    }
    // If all configs are valid, return success
    if (!hasErrors) {
        return {
            success: true,
            validConfigs
        };
    }
    // If some configs are valid but others failed, return partial success
    if (Object.keys(validConfigs).length > 0) {
        return {
            success: false,
            validConfigs,
            errors
        };
    }
    // If all configs failed, return error
    return {
        success: false,
        errors,
        error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "All server configurations failed validation",
            details: errors
        }, {
            status: 400
        })
    };
};
function createMCPClient(config, id) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$mcp$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MCPClient"]({
        id,
        servers: {
            server: config
        }
    });
}
function createMCPClientWithMultipleConnections(serverConfigs) {
    // Normalize server config names
    const normalizedConfigs = {};
    for (const [serverName, config] of Object.entries(serverConfigs)){
        const normalizedName = normalizeServerConfigName(serverName);
        normalizedConfigs[normalizedName] = config;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$mcp$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MCPClient"]({
        id: `chat-${Date.now()}`,
        servers: normalizedConfigs
    });
}
function normalizeServerConfigName(serverName) {
    // Convert to lowercase and replace spaces/hyphens with underscores
    return serverName.toLowerCase().replace(/[\s\-]+/g, "_").replace(/[^a-z0-9_]/g, "");
}
function createErrorResponse(message, details, status = 500) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        error: message,
        details: details || "Unknown error"
    }, {
        status
    });
}
}),
"[project]/src/app/api/mcp/connect/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/mcp-utils.ts [app-route] (ecmascript)");
;
;
async function POST(request) {
    const { serverConfig } = await request.json();
    const validation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateServerConfig"])(serverConfig);
    if (!validation.success) {
        return validation.error;
    }
    let client;
    try {
        client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createMCPClient"])(validation.config, `test-${Date.now()}`);
    } catch (error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: `Failed to create a MCP client. Please double check your server configuration: ${JSON.stringify(serverConfig)}`,
            details: error instanceof Error ? error.message : "Unknown error"
        }, {
            status: 500
        });
    }
    try {
        await client.getTools();
        await client.disconnect();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true
        });
    } catch (error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: `MCP configuration is invalid. Please double check your server configuration: ${JSON.stringify(serverConfig)}`,
            details: error instanceof Error ? error.message : "Unknown error"
        }, {
            status: 500
        });
    }
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__d7be282d._.js.map