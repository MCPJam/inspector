{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/mcp-utils.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { MCPClient } from \"@mastra/mcp\";\nimport { MastraMCPServerDefinition } from \"./types\";\n\nexport interface ValidationResult {\n  success: boolean;\n  config?: MastraMCPServerDefinition;\n  error?: NextResponse;\n}\n\nexport interface MultipleValidationResult {\n  success: boolean;\n  validConfigs?: Record<string, MastraMCPServerDefinition>;\n  errors?: Record<string, string>;\n  error?: NextResponse;\n}\n\nexport function validateServerConfig(serverConfig: any): ValidationResult {\n  if (!serverConfig) {\n    return {\n      success: false,\n      error: NextResponse.json(\n        { error: \"Server configuration is required\" },\n        { status: 400 },\n      ),\n    };\n  }\n\n  // Validate and prepare config\n  const config = { ...serverConfig };\n\n  // Validate and convert URL if provided\n  if (config.url) {\n    try {\n      // Convert string URL to URL object if needed\n      if (typeof config.url === \"string\") {\n        config.url = new URL(config.url);\n      } else if (typeof config.url === \"object\" && !config.url.href) {\n        return {\n          success: false,\n          error: NextResponse.json(\n            { error: \"Invalid URL configuration\" },\n            { status: 400 },\n          ),\n        };\n      }\n\n      // Handle OAuth authentication for HTTP servers\n      if (config.oauth?.access_token) {\n        const authHeaders = {\n          Authorization: `Bearer ${config.oauth.access_token}`,\n          ...(config.requestInit?.headers || {}),\n        };\n\n        config.requestInit = {\n          ...config.requestInit,\n          headers: authHeaders,\n        };\n\n        // For SSE connections, add eventSourceInit with OAuth headers\n        config.eventSourceInit = {\n          fetch(input: Request | URL | string, init?: RequestInit) {\n            const headers = new Headers(init?.headers || {});\n\n            // Add OAuth authorization header\n            headers.set(\n              \"Authorization\",\n              `Bearer ${config.oauth!.access_token}`,\n            );\n\n            // Copy other headers from requestInit\n            if (config.requestInit?.headers) {\n              const requestHeaders = new Headers(config.requestInit.headers);\n              requestHeaders.forEach((value, key) => {\n                if (key.toLowerCase() !== \"authorization\") {\n                  headers.set(key, value);\n                }\n              });\n            }\n\n            return fetch(input, {\n              ...init,\n              headers,\n            });\n          },\n        };\n      } else if (config.requestInit?.headers) {\n        // For SSE connections without OAuth, add eventSourceInit if requestInit has custom headers\n        config.eventSourceInit = {\n          fetch(input: Request | URL | string, init?: RequestInit) {\n            const headers = new Headers(init?.headers || {});\n\n            // Copy headers from requestInit\n            const requestHeaders = new Headers(config.requestInit.headers);\n            requestHeaders.forEach((value, key) => {\n              headers.set(key, value);\n            });\n\n            return fetch(input, {\n              ...init,\n              headers,\n            });\n          },\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: NextResponse.json(\n          { error: `Invalid URL format: ${error}` },\n          { status: 400 },\n        ),\n      };\n    }\n  }\n\n  return {\n    success: true,\n    config,\n  };\n}\n\nexport const validateMultipleServerConfigs = (\n  serverConfigs: Record<string, MastraMCPServerDefinition>,\n): MultipleValidationResult => {\n  if (!serverConfigs || Object.keys(serverConfigs).length === 0) {\n    return {\n      success: false,\n      error: NextResponse.json(\n        { error: \"At least one server configuration is required\" },\n        { status: 400 },\n      ),\n    };\n  }\n\n  const validConfigs: Record<string, MastraMCPServerDefinition> = {};\n  const errors: Record<string, string> = {};\n  let hasErrors = false;\n\n  // Validate each server configuration\n  for (const [serverName, serverConfig] of Object.entries(serverConfigs)) {\n    const validationResult = validateServerConfig(serverConfig);\n\n    if (validationResult.success && validationResult.config) {\n      validConfigs[serverName] = validationResult.config;\n    } else {\n      hasErrors = true;\n      // Extract error message from the NextResponse\n      let errorMessage = \"Validation failed\";\n      if (validationResult.error) {\n        try {\n          const errorBody = validationResult.error.body;\n          if (\n            errorBody &&\n            typeof errorBody === \"object\" &&\n            \"error\" in errorBody\n          ) {\n            errorMessage = errorBody.error as string;\n          }\n        } catch {\n          errorMessage = \"Validation failed\";\n        }\n      }\n      errors[serverName] = errorMessage;\n    }\n  }\n\n  // If all configs are valid, return success\n  if (!hasErrors) {\n    return {\n      success: true,\n      validConfigs,\n    };\n  }\n\n  // If some configs are valid but others failed, return partial success\n  if (Object.keys(validConfigs).length > 0) {\n    return {\n      success: false,\n      validConfigs,\n      errors,\n    };\n  }\n\n  // If all configs failed, return error\n  return {\n    success: false,\n    errors,\n    error: NextResponse.json(\n      {\n        error: \"All server configurations failed validation\",\n        details: errors,\n      },\n      { status: 400 },\n    ),\n  };\n};\n\nexport function createMCPClient(\n  config: MastraMCPServerDefinition,\n  id: string,\n): MCPClient {\n  return new MCPClient({\n    id,\n    servers: {\n      server: config,\n    },\n  });\n}\n\nexport function createMCPClientWithMultipleConnections(\n  serverConfigs: Record<string, MastraMCPServerDefinition>,\n): MCPClient {\n  // Normalize server config names\n  const normalizedConfigs: Record<string, MastraMCPServerDefinition> = {};\n  for (const [serverName, config] of Object.entries(serverConfigs)) {\n    const normalizedName = normalizeServerConfigName(serverName);\n    normalizedConfigs[normalizedName] = config;\n  }\n\n  return new MCPClient({\n    id: `chat-${Date.now()}`,\n    servers: normalizedConfigs,\n  });\n}\n\nexport function normalizeServerConfigName(serverName: string): string {\n  // Convert to lowercase and replace spaces/hyphens with underscores\n  return serverName\n    .toLowerCase()\n    .replace(/[\\s\\-]+/g, \"_\")\n    .replace(/[^a-z0-9_]/g, \"\");\n}\n\nexport function createErrorResponse(\n  message: string,\n  details?: string,\n  status: number = 500,\n): NextResponse {\n  return NextResponse.json(\n    {\n      error: message,\n      details: details || \"Unknown error\",\n    },\n    { status },\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 368, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/app/api/mcp/tools/route.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport {\n  validateServerConfig,\n  createMCPClient,\n  createErrorResponse,\n} from \"@/lib/mcp-utils\";\nimport type { Tool } from \"@mastra/core/tools\";\nimport { z } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\n\n// Store for pending elicitation requests\nconst pendingElicitations = new Map<\n  string,\n  {\n    resolve: (response: any) => void;\n    reject: (error: any) => void;\n  }\n>();\n\nexport async function POST(request: NextRequest) {\n  let client: any = null;\n  let encoder: TextEncoder | null = null;\n  let streamController: ReadableStreamDefaultController | null = null;\n  let action: string | undefined;\n  let toolName: string | undefined;\n\n  try {\n    const requestData = await request.json();\n    action = requestData.action;\n    toolName = requestData.toolName;\n    const { serverConfig, parameters, requestId, response } = requestData;\n\n    if (!action || ![\"list\", \"execute\", \"respond\"].includes(action)) {\n      return createErrorResponse(\n        \"Invalid action\",\n        \"Action must be 'list', 'execute', or 'respond'\",\n      );\n    }\n\n    // Handle elicitation response\n    if (action === \"respond\") {\n      if (!requestId) {\n        return createErrorResponse(\n          \"Missing requestId\",\n          \"requestId is required for respond action\",\n        );\n      }\n\n      const pending = pendingElicitations.get(requestId);\n      if (!pending) {\n        return createErrorResponse(\n          \"Invalid requestId\",\n          \"No pending elicitation found for this requestId\",\n        );\n      }\n\n      // Resolve the pending elicitation with user's response\n      pending.resolve(response);\n      pendingElicitations.delete(requestId);\n\n      return new Response(JSON.stringify({ success: true }), {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    const validation = validateServerConfig(serverConfig);\n    if (!validation.success) {\n      return validation.error!;\n    }\n\n    encoder = new TextEncoder();\n    const readableStream = new ReadableStream({\n      async start(controller) {\n        streamController = controller;\n\n        try {\n          const clientId = `tools-${action}-${Date.now()}`;\n          client = createMCPClient(validation.config!, clientId);\n\n          if (action === \"list\") {\n            // Stream tools list\n            controller.enqueue(\n              encoder!.encode(\n                `data: ${JSON.stringify({\n                  type: \"tools_loading\",\n                  message: \"Fetching tools from server...\",\n                })}\\n\\n`,\n              ),\n            );\n\n            const tools: Record<string, Tool> = await client.getTools();\n\n            // Convert from Zod to JSON Schema\n            const toolsWithJsonSchema: Record<string, any> = Object.fromEntries(\n              Object.entries(tools).map(([toolName, tool]) => {\n                return [\n                  toolName,\n                  {\n                    ...tool,\n                    inputSchema: zodToJsonSchema(\n                      tool.inputSchema as unknown as z.ZodType<any>,\n                    ),\n                  },\n                ];\n              }),\n            );\n\n            controller.enqueue(\n              encoder!.encode(\n                `data: ${JSON.stringify({\n                  type: \"tools_list\",\n                  tools: toolsWithJsonSchema,\n                })}\\n\\n`,\n              ),\n            );\n          } else if (action === \"execute\") {\n            // Stream tool execution\n            if (!toolName) {\n              controller.enqueue(\n                encoder!.encode(\n                  `data: ${JSON.stringify({\n                    type: \"tool_error\",\n                    error: \"Tool name is required for execution\",\n                  })}\\n\\n`,\n                ),\n              );\n              return;\n            }\n\n            controller.enqueue(\n              encoder!.encode(\n                `data: ${JSON.stringify({\n                  type: \"tool_executing\",\n                  toolName,\n                  parameters: parameters || {},\n                  message: \"Executing tool...\",\n                })}\\n\\n`,\n              ),\n            );\n\n            const tools = await client.getTools();\n            const tool = tools[toolName];\n\n            if (!tool) {\n              controller.enqueue(\n                encoder!.encode(\n                  `data: ${JSON.stringify({\n                    type: \"tool_error\",\n                    error: `Tool '${toolName}' not found`,\n                  })}\\n\\n`,\n                ),\n              );\n              return;\n            }\n\n            const toolArgs =\n              parameters && typeof parameters === \"object\" ? parameters : {};\n\n            // Set up elicitation handler\n            const elicitationHandler = async (elicitationRequest: any) => {\n              const requestId = `elicit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n              // Stream elicitation request to client\n              if (streamController && encoder) {\n                streamController.enqueue(\n                  encoder.encode(\n                    `data: ${JSON.stringify({\n                      type: \"elicitation_request\",\n                      requestId,\n                      message: elicitationRequest.message,\n                      schema: elicitationRequest.requestedSchema,\n                      timestamp: new Date(),\n                    })}\\n\\n`,\n                  ),\n                );\n              }\n\n              // Return a promise that will be resolved when user responds\n              return new Promise((resolve, reject) => {\n                pendingElicitations.set(requestId, { resolve, reject });\n\n                // Set a timeout to clean up if no response\n                setTimeout(() => {\n                  if (pendingElicitations.has(requestId)) {\n                    pendingElicitations.delete(requestId);\n                    reject(new Error(\"Elicitation timeout\"));\n                  }\n                }, 300000); // 5 minute timeout\n              });\n            };\n\n            // Register elicitation handler with the client\n            if (client.elicitation && client.elicitation.onRequest) {\n              const serverName = \"server\"; // See createMCPClient() function. The name of the server is \"server\"\n              client.elicitation.onRequest(serverName, elicitationHandler);\n            }\n\n            const result = await tool.execute({\n              context: toolArgs,\n            });\n\n            controller.enqueue(\n              encoder!.encode(\n                `data: ${JSON.stringify({\n                  type: \"tool_result\",\n                  toolName,\n                  result,\n                })}\\n\\n`,\n              ),\n            );\n\n            // Stream elicitation completion if there were any\n            controller.enqueue(\n              encoder!.encode(\n                `data: ${JSON.stringify({\n                  type: \"elicitation_complete\",\n                  toolName,\n                })}\\n\\n`,\n              ),\n            );\n          }\n\n          controller.enqueue(encoder!.encode(`data: [DONE]\\n\\n`));\n        } catch (error) {\n          const errorMsg =\n            error instanceof Error ? error.message : \"Unknown error\";\n\n          controller.enqueue(\n            encoder!.encode(\n              `data: ${JSON.stringify({\n                type: \"tool_error\",\n                error: errorMsg,\n              })}\\n\\n`,\n            ),\n          );\n        } finally {\n          await client.disconnect();\n          controller.close();\n        }\n      },\n    });\n\n    return new Response(readableStream, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n      },\n    });\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : \"Unknown error\";\n\n    // Clean up client on error\n    if (client) {\n      try {\n        await client.disconnect();\n      } catch (cleanupError) {\n        // Ignore cleanup errors\n      }\n    }\n\n    return createErrorResponse(\"Failed to process tools request\", errorMsg);\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}