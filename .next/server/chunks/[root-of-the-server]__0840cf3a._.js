module.exports = {

"[project]/.next-internal/server/app/api/mcp/tools/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/node:process [external] (node:process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}}),
"[externals]/node:stream [external] (node:stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}}),
"[externals]/node:crypto [external] (node:crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/string_decoder [external] (string_decoder, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/async_hooks [external] (async_hooks, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("async_hooks", () => require("async_hooks"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/mcp-utils.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createErrorResponse": ()=>createErrorResponse,
    "createMCPClient": ()=>createMCPClient,
    "createMCPClientWithMultipleConnections": ()=>createMCPClientWithMultipleConnections,
    "normalizeServerConfigName": ()=>normalizeServerConfigName,
    "validateMultipleServerConfigs": ()=>validateMultipleServerConfigs,
    "validateServerConfig": ()=>validateServerConfig
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$mcp$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/mcp/dist/index.js [app-route] (ecmascript)");
;
;
function validateServerConfig(serverConfig) {
    if (!serverConfig) {
        return {
            success: false,
            error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Server configuration is required"
            }, {
                status: 400
            })
        };
    }
    // Validate and prepare config
    const config = {
        ...serverConfig
    };
    // Validate and convert URL if provided
    if (config.url) {
        try {
            // Convert string URL to URL object if needed
            if (typeof config.url === "string") {
                config.url = new URL(config.url);
            } else if (typeof config.url === "object" && !config.url.href) {
                return {
                    success: false,
                    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        error: "Invalid URL configuration"
                    }, {
                        status: 400
                    })
                };
            }
            // Handle OAuth authentication for HTTP servers
            if (config.oauth?.access_token) {
                const authHeaders = {
                    Authorization: `Bearer ${config.oauth.access_token}`,
                    ...config.requestInit?.headers || {}
                };
                config.requestInit = {
                    ...config.requestInit,
                    headers: authHeaders
                };
                // For SSE connections, add eventSourceInit with OAuth headers
                config.eventSourceInit = {
                    fetch (input, init) {
                        const headers = new Headers(init?.headers || {});
                        // Add OAuth authorization header
                        headers.set("Authorization", `Bearer ${config.oauth.access_token}`);
                        // Copy other headers from requestInit
                        if (config.requestInit?.headers) {
                            const requestHeaders = new Headers(config.requestInit.headers);
                            requestHeaders.forEach((value, key)=>{
                                if (key.toLowerCase() !== "authorization") {
                                    headers.set(key, value);
                                }
                            });
                        }
                        return fetch(input, {
                            ...init,
                            headers
                        });
                    }
                };
            } else if (config.requestInit?.headers) {
                // For SSE connections without OAuth, add eventSourceInit if requestInit has custom headers
                config.eventSourceInit = {
                    fetch (input, init) {
                        const headers = new Headers(init?.headers || {});
                        // Copy headers from requestInit
                        const requestHeaders = new Headers(config.requestInit.headers);
                        requestHeaders.forEach((value, key)=>{
                            headers.set(key, value);
                        });
                        return fetch(input, {
                            ...init,
                            headers
                        });
                    }
                };
            }
        } catch (error) {
            return {
                success: false,
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: `Invalid URL format: ${error}`
                }, {
                    status: 400
                })
            };
        }
    }
    return {
        success: true,
        config
    };
}
const validateMultipleServerConfigs = (serverConfigs)=>{
    if (!serverConfigs || Object.keys(serverConfigs).length === 0) {
        return {
            success: false,
            error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "At least one server configuration is required"
            }, {
                status: 400
            })
        };
    }
    const validConfigs = {};
    const errors = {};
    let hasErrors = false;
    // Validate each server configuration
    for (const [serverName, serverConfig] of Object.entries(serverConfigs)){
        const validationResult = validateServerConfig(serverConfig);
        if (validationResult.success && validationResult.config) {
            validConfigs[serverName] = validationResult.config;
        } else {
            hasErrors = true;
            // Extract error message from the NextResponse
            let errorMessage = "Validation failed";
            if (validationResult.error) {
                try {
                    const errorBody = validationResult.error.body;
                    if (errorBody && typeof errorBody === "object" && "error" in errorBody) {
                        errorMessage = errorBody.error;
                    }
                } catch  {
                    errorMessage = "Validation failed";
                }
            }
            errors[serverName] = errorMessage;
        }
    }
    // If all configs are valid, return success
    if (!hasErrors) {
        return {
            success: true,
            validConfigs
        };
    }
    // If some configs are valid but others failed, return partial success
    if (Object.keys(validConfigs).length > 0) {
        return {
            success: false,
            validConfigs,
            errors
        };
    }
    // If all configs failed, return error
    return {
        success: false,
        errors,
        error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "All server configurations failed validation",
            details: errors
        }, {
            status: 400
        })
    };
};
function createMCPClient(config, id) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$mcp$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MCPClient"]({
        id,
        servers: {
            server: config
        }
    });
}
function createMCPClientWithMultipleConnections(serverConfigs) {
    // Normalize server config names
    const normalizedConfigs = {};
    for (const [serverName, config] of Object.entries(serverConfigs)){
        const normalizedName = normalizeServerConfigName(serverName);
        normalizedConfigs[normalizedName] = config;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$mcp$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MCPClient"]({
        id: `chat-${Date.now()}`,
        servers: normalizedConfigs
    });
}
function normalizeServerConfigName(serverName) {
    // Convert to lowercase and replace spaces/hyphens with underscores
    return serverName.toLowerCase().replace(/[\s\-]+/g, "_").replace(/[^a-z0-9_]/g, "");
}
function createErrorResponse(message, details, status = 500) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        error: message,
        details: details || "Unknown error"
    }, {
        status
    });
}
}),
"[project]/src/app/api/mcp/tools/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/mcp-utils.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$zodToJsonSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js [app-route] (ecmascript)");
;
;
// Store for pending elicitation requests
const pendingElicitations = new Map();
async function POST(request) {
    let client = null;
    let encoder = null;
    let streamController = null;
    let action;
    let toolName;
    try {
        const requestData = await request.json();
        action = requestData.action;
        toolName = requestData.toolName;
        const { serverConfig, parameters, requestId, response } = requestData;
        if (!action || ![
            "list",
            "execute",
            "respond"
        ].includes(action)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createErrorResponse"])("Invalid action", "Action must be 'list', 'execute', or 'respond'");
        }
        // Handle elicitation response
        if (action === "respond") {
            if (!requestId) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createErrorResponse"])("Missing requestId", "requestId is required for respond action");
            }
            const pending = pendingElicitations.get(requestId);
            if (!pending) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createErrorResponse"])("Invalid requestId", "No pending elicitation found for this requestId");
            }
            // Resolve the pending elicitation with user's response
            pending.resolve(response);
            pendingElicitations.delete(requestId);
            return new Response(JSON.stringify({
                success: true
            }), {
                headers: {
                    "Content-Type": "application/json"
                }
            });
        }
        const validation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateServerConfig"])(serverConfig);
        if (!validation.success) {
            return validation.error;
        }
        encoder = new TextEncoder();
        const readableStream = new ReadableStream({
            async start (controller) {
                streamController = controller;
                try {
                    const clientId = `tools-${action}-${Date.now()}`;
                    client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createMCPClient"])(validation.config, clientId);
                    if (action === "list") {
                        // Stream tools list
                        controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                            type: "tools_loading",
                            message: "Fetching tools from server..."
                        })}\n\n`));
                        const tools = await client.getTools();
                        // Convert from Zod to JSON Schema
                        const toolsWithJsonSchema = Object.fromEntries(Object.entries(tools).map(([toolName, tool])=>{
                            return [
                                toolName,
                                {
                                    ...tool,
                                    inputSchema: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$zodToJsonSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["zodToJsonSchema"])(tool.inputSchema)
                                }
                            ];
                        }));
                        controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                            type: "tools_list",
                            tools: toolsWithJsonSchema
                        })}\n\n`));
                    } else if (action === "execute") {
                        // Stream tool execution
                        if (!toolName) {
                            controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                                type: "tool_error",
                                error: "Tool name is required for execution"
                            })}\n\n`));
                            return;
                        }
                        controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                            type: "tool_executing",
                            toolName,
                            parameters: parameters || {},
                            message: "Executing tool..."
                        })}\n\n`));
                        const tools = await client.getTools();
                        const tool = tools[toolName];
                        if (!tool) {
                            controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                                type: "tool_error",
                                error: `Tool '${toolName}' not found`
                            })}\n\n`));
                            return;
                        }
                        const toolArgs = parameters && typeof parameters === "object" ? parameters : {};
                        // Set up elicitation handler
                        const elicitationHandler = async (elicitationRequest)=>{
                            const requestId = `elicit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                            // Stream elicitation request to client
                            if (streamController && encoder) {
                                streamController.enqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: "elicitation_request",
                                    requestId,
                                    message: elicitationRequest.message,
                                    schema: elicitationRequest.requestedSchema,
                                    timestamp: new Date()
                                })}\n\n`));
                            }
                            // Return a promise that will be resolved when user responds
                            return new Promise((resolve, reject)=>{
                                pendingElicitations.set(requestId, {
                                    resolve,
                                    reject
                                });
                                // Set a timeout to clean up if no response
                                setTimeout(()=>{
                                    if (pendingElicitations.has(requestId)) {
                                        pendingElicitations.delete(requestId);
                                        reject(new Error("Elicitation timeout"));
                                    }
                                }, 300000); // 5 minute timeout
                            });
                        };
                        // Register elicitation handler with the client
                        if (client.elicitation && client.elicitation.onRequest) {
                            const serverName = "server"; // See createMCPClient() function. The name of the server is "server"
                            client.elicitation.onRequest(serverName, elicitationHandler);
                        }
                        const result = await tool.execute({
                            context: toolArgs
                        });
                        controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                            type: "tool_result",
                            toolName,
                            result
                        })}\n\n`));
                        // Stream elicitation completion if there were any
                        controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                            type: "elicitation_complete",
                            toolName
                        })}\n\n`));
                    }
                    controller.enqueue(encoder.encode(`data: [DONE]\n\n`));
                } catch (error) {
                    const errorMsg = error instanceof Error ? error.message : "Unknown error";
                    controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                        type: "tool_error",
                        error: errorMsg
                    })}\n\n`));
                } finally{
                    await client.disconnect();
                    controller.close();
                }
            }
        });
        return new Response(readableStream, {
            headers: {
                "Content-Type": "text/event-stream",
                "Cache-Control": "no-cache",
                Connection: "keep-alive"
            }
        });
    } catch (error) {
        const errorMsg = error instanceof Error ? error.message : "Unknown error";
        // Clean up client on error
        if (client) {
            try {
                await client.disconnect();
            } catch (cleanupError) {
            // Ignore cleanup errors
            }
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mcp$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createErrorResponse"])("Failed to process tools request", errorMsg);
    }
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__0840cf3a._.js.map