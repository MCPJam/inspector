{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport const getInitials = (str: string): string => {\n  if (typeof str !== \"string\" || !str.trim()) return \"?\";\n\n  return (\n    str\n      .trim()\n      .split(/\\s+/)\n      .filter(Boolean)\n      .map((word) => word[0])\n      .join(\"\")\n      .toUpperCase() || \"?\"\n  );\n};\n\nexport function formatCurrency(\n  amount: number,\n  opts?: {\n    currency?: string;\n    locale?: string;\n    minimumFractionDigits?: number;\n    maximumFractionDigits?: number;\n    noDecimals?: boolean;\n  },\n) {\n  const {\n    currency = \"USD\",\n    locale = \"en-US\",\n    minimumFractionDigits,\n    maximumFractionDigits,\n    noDecimals,\n  } = opts ?? {};\n\n  const formatOptions: Intl.NumberFormatOptions = {\n    style: \"currency\",\n    currency,\n    minimumFractionDigits: noDecimals ? 0 : minimumFractionDigits,\n    maximumFractionDigits: noDecimals ? 0 : maximumFractionDigits,\n  };\n\n  return new Intl.NumberFormat(locale, formatOptions).format(amount);\n}\n\nexport function formatTimeRemaining(timeLeftMs: number): string {\n  if (timeLeftMs <= 0) return \"Expired\";\n\n  const days = Math.floor(timeLeftMs / (1000 * 60 * 60 * 24));\n  const hours = Math.floor(\n    (timeLeftMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60),\n  );\n  const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));\n  const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);\n\n  const parts = [];\n  if (days > 0) parts.push(`${days}d`);\n  if (hours > 0) parts.push(`${hours}h`);\n  if (minutes > 0) parts.push(`${minutes}m`);\n  if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`);\n\n  return parts.join(\" \") + \" remaining\";\n}\n\nexport function getTimeBreakdown(timeLeftMs: number) {\n  const days = Math.floor(timeLeftMs / (1000 * 60 * 60 * 24));\n  const hours = Math.floor(\n    (timeLeftMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60),\n  );\n  const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));\n  const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);\n\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    isExpired: timeLeftMs <= 0,\n    isExpiringSoon: timeLeftMs <= 300000, // 5 minutes\n  };\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,qIAAA,CAAA,OAAI,AAAD,EAAE;AACtB;AAEO,MAAM,cAAc,CAAC;IAC1B,IAAI,OAAO,QAAQ,YAAY,CAAC,IAAI,IAAI,IAAI,OAAO;IAEnD,OACE,IACG,IAAI,GACJ,KAAK,CAAC,OACN,MAAM,CAAC,SACP,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,EAAE,EACrB,IAAI,CAAC,IACL,WAAW,MAAM;AAExB;AAEO,SAAS,eACd,MAAc,EACd,IAMC;IAED,MAAM,EACJ,WAAW,KAAK,EAChB,SAAS,OAAO,EAChB,qBAAqB,EACrB,qBAAqB,EACrB,UAAU,EACX,GAAG,QAAQ,CAAC;IAEb,MAAM,gBAA0C;QAC9C,OAAO;QACP;QACA,uBAAuB,aAAa,IAAI;QACxC,uBAAuB,aAAa,IAAI;IAC1C;IAEA,OAAO,IAAI,KAAK,YAAY,CAAC,QAAQ,eAAe,MAAM,CAAC;AAC7D;AAEO,SAAS,oBAAoB,UAAkB;IACpD,IAAI,cAAc,GAAG,OAAO;IAE5B,MAAM,OAAO,KAAK,KAAK,CAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE;IACzD,MAAM,QAAQ,KAAK,KAAK,CACtB,AAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE,IAAK,CAAC,OAAO,KAAK,EAAE;IAExD,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,KAAK,EAAE,IAAK,CAAC,OAAO,EAAE;IACvE,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,EAAE,IAAK;IAExD,MAAM,QAAQ,EAAE;IAChB,IAAI,OAAO,GAAG,MAAM,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;IACnC,IAAI,QAAQ,GAAG,MAAM,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC;IACrC,IAAI,UAAU,GAAG,MAAM,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAC;IACzC,IAAI,UAAU,KAAK,MAAM,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAC;IAE/D,OAAO,MAAM,IAAI,CAAC,OAAO;AAC3B;AAEO,SAAS,iBAAiB,UAAkB;IACjD,MAAM,OAAO,KAAK,KAAK,CAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE;IACzD,MAAM,QAAQ,KAAK,KAAK,CACtB,AAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE,IAAK,CAAC,OAAO,KAAK,EAAE;IAExD,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,KAAK,EAAE,IAAK,CAAC,OAAO,EAAE;IACvE,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,EAAE,IAAK;IAExD,OAAO;QACL;QACA;QACA;QACA;QACA,WAAW,cAAc;QACzB,gBAAgB,cAAc;IAChC;AACF","debugId":null}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/chat-utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\nimport { ChatMessage } from \"./chat-types\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function generateId(): string {\n  return Math.random().toString(36).substr(2, 9);\n}\n\nexport function sanitizeText(text: string): string {\n  // Basic sanitization - in production you might want more robust sanitization\n  return text.trim();\n}\n\nexport function formatTimestamp(date: Date): string {\n  return new Intl.DateTimeFormat(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  }).format(date);\n}\n\nexport function formatMessageDate(date: Date): string {\n  const now = new Date();\n  const diffInMs = now.getTime() - date.getTime();\n  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n\n  if (diffInDays === 0) {\n    return formatTimestamp(date);\n  } else if (diffInDays === 1) {\n    return `Yesterday ${formatTimestamp(date)}`;\n  } else if (diffInDays < 7) {\n    return `${diffInDays} days ago`;\n  } else {\n    return new Intl.DateTimeFormat(\"en-US\", {\n      month: \"short\",\n      day: \"numeric\",\n      year: date.getFullYear() !== now.getFullYear() ? \"numeric\" : undefined,\n    }).format(date);\n  }\n}\n\nexport function createMessage(\n  role: \"user\" | \"assistant\",\n  content: string,\n  attachments?: any[],\n): ChatMessage {\n  return {\n    id: generateId(),\n    role,\n    content,\n    timestamp: new Date(),\n    attachments,\n    metadata: {\n      createdAt: new Date().toISOString(),\n    },\n  };\n}\n\nexport function isValidFileType(file: File): boolean {\n  const allowedTypes = [\n    \"text/plain\",\n    \"application/pdf\",\n    \"image/jpeg\",\n    \"image/jpg\",\n    \"image/png\",\n    \"image/gif\",\n    \"image/webp\",\n    \"application/json\",\n    \"text/csv\",\n    \"application/vnd.ms-excel\",\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  ];\n\n  return allowedTypes.includes(file.type);\n}\n\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return \"0 B\";\n\n  const k = 1024;\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n}\n\nexport function truncateText(text: string, maxLength: number): string {\n  if (text.length <= maxLength) return text;\n  return text.substring(0, maxLength) + \"...\";\n}\n\nexport function scrollToBottom(element?: Element | null) {\n  if (element) {\n    element.scrollTop = element.scrollHeight;\n  } else {\n    window.scrollTo(0, document.body.scrollHeight);\n  }\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number,\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;;;AAGO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,qIAAA,CAAA,OAAI,AAAD,EAAE;AACtB;AAEO,SAAS;IACd,OAAO,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG;AAC9C;AAEO,SAAS,aAAa,IAAY;IACvC,6EAA6E;IAC7E,OAAO,KAAK,IAAI;AAClB;AAEO,SAAS,gBAAgB,IAAU;IACxC,OAAO,IAAI,KAAK,cAAc,CAAC,SAAS;QACtC,MAAM;QACN,QAAQ;QACR,QAAQ;IACV,GAAG,MAAM,CAAC;AACZ;AAEO,SAAS,kBAAkB,IAAU;IAC1C,MAAM,MAAM,IAAI;IAChB,MAAM,WAAW,IAAI,OAAO,KAAK,KAAK,OAAO;IAC7C,MAAM,aAAa,KAAK,KAAK,CAAC,WAAW,CAAC,OAAO,KAAK,KAAK,EAAE;IAE7D,IAAI,eAAe,GAAG;QACpB,OAAO,gBAAgB;IACzB,OAAO,IAAI,eAAe,GAAG;QAC3B,OAAO,CAAC,UAAU,EAAE,gBAAgB,OAAO;IAC7C,OAAO,IAAI,aAAa,GAAG;QACzB,OAAO,GAAG,WAAW,SAAS,CAAC;IACjC,OAAO;QACL,OAAO,IAAI,KAAK,cAAc,CAAC,SAAS;YACtC,OAAO;YACP,KAAK;YACL,MAAM,KAAK,WAAW,OAAO,IAAI,WAAW,KAAK,YAAY;QAC/D,GAAG,MAAM,CAAC;IACZ;AACF;AAEO,SAAS,cACd,IAA0B,EAC1B,OAAe,EACf,WAAmB;IAEnB,OAAO;QACL,IAAI;QACJ;QACA;QACA,WAAW,IAAI;QACf;QACA,UAAU;YACR,WAAW,IAAI,OAAO,WAAW;QACnC;IACF;AACF;AAEO,SAAS,gBAAgB,IAAU;IACxC,MAAM,eAAe;QACnB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,OAAO,aAAa,QAAQ,CAAC,KAAK,IAAI;AACxC;AAEO,SAAS,eAAe,KAAa;IAC1C,IAAI,UAAU,GAAG,OAAO;IAExB,MAAM,IAAI;IACV,MAAM,QAAQ;QAAC;QAAK;QAAM;QAAM;KAAK;IACrC,MAAM,IAAI,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,SAAS,KAAK,GAAG,CAAC;IAEhD,OAAO,WAAW,CAAC,QAAQ,KAAK,GAAG,CAAC,GAAG,EAAE,EAAE,OAAO,CAAC,MAAM,MAAM,KAAK,CAAC,EAAE;AACzE;AAEO,SAAS,aAAa,IAAY,EAAE,SAAiB;IAC1D,IAAI,KAAK,MAAM,IAAI,WAAW,OAAO;IACrC,OAAO,KAAK,SAAS,CAAC,GAAG,aAAa;AACxC;AAEO,SAAS,eAAe,OAAwB;IACrD,IAAI,SAAS;QACX,QAAQ,SAAS,GAAG,QAAQ,YAAY;IAC1C,OAAO;QACL,OAAO,QAAQ,CAAC,GAAG,SAAS,IAAI,CAAC,YAAY;IAC/C;AACF;AAEO,SAAS,SACd,IAAO,EACP,IAAY;IAEZ,IAAI;IACJ,OAAO,CAAC,GAAG;QACT,aAAa;QACb,UAAU,WAAW,IAAM,QAAQ,OAAO;IAC5C;AACF","debugId":null}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/types.ts"],"sourcesContent":["import { LogHandler } from \"@mastra/mcp\";\nimport { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport { StreamableHTTPClientTransportOptions } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type { ClientCapabilities } from \"@modelcontextprotocol/sdk/types.js\";\n\n// Shared model definitions\nexport type ModelProvider = \"anthropic\" | \"openai\" | \"ollama\";\n\nexport interface ModelDefinition {\n  id: Model | string;\n  name: string;\n  provider: ModelProvider;\n}\n\nexport enum Model {\n  CLAUDE_OPUS_4_0 = \"claude-opus-4-0\",\n  CLAUDE_SONNET_4_0 = \"claude-sonnet-4-0\",\n  CLAUDE_3_7_SONNET_LATEST = \"claude-3-7-sonnet-latest\",\n  CLAUDE_3_5_SONNET_LATEST = \"claude-3-5-sonnet-latest\",\n  CLAUDE_3_5_HAIKU_LATEST = \"claude-3-5-haiku-latest\",\n  O3_MINI = \"o3-mini\",\n  O3 = \"o3\",\n  O4_MINI = \"o4-mini\",\n  GPT_4_1 = \"gpt-4.1\",\n  GPT_4_1_MINI = \"gpt-4.1-mini\",\n  GPT_4_1_NANO = \"gpt-4.1-nano\",\n  GPT_4O = \"gpt-4o\",\n  GPT_4O_MINI = \"gpt-4o-mini\",\n  GPT_4_TURBO = \"gpt-4-turbo\",\n  GPT_4 = \"gpt-4\",\n  GPT_3_5_TURBO = \"gpt-3.5-turbo\",\n  O1 = \"o1\",\n}\n\nexport const SUPPORTED_MODELS: ModelDefinition[] = [\n  {\n    id: Model.CLAUDE_OPUS_4_0,\n    name: \"Claude Opus 4\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_SONNET_4_0,\n    name: \"Claude Sonnet 4\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_3_7_SONNET_LATEST,\n    name: \"Claude Sonnet 3.7\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_3_5_SONNET_LATEST,\n    name: \"Claude Sonnet 3.5\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_3_5_HAIKU_LATEST,\n    name: \"Claude Haiku 3.5\",\n    provider: \"anthropic\",\n  },\n  { id: Model.O3_MINI, name: \"O3 Mini\", provider: \"openai\" },\n  { id: Model.O3, name: \"O3\", provider: \"openai\" },\n  { id: Model.O4_MINI, name: \"O4 Mini\", provider: \"openai\" },\n  { id: Model.GPT_4_1, name: \"GPT-4.1\", provider: \"openai\" },\n  { id: Model.GPT_4_1_MINI, name: \"GPT-4.1 Mini\", provider: \"openai\" },\n  { id: Model.GPT_4_1_NANO, name: \"GPT-4.1 Nano\", provider: \"openai\" },\n  { id: Model.GPT_4O, name: \"GPT-4o\", provider: \"openai\" },\n  { id: Model.GPT_4O_MINI, name: \"GPT-4o Mini\", provider: \"openai\" },\n  { id: Model.GPT_4_TURBO, name: \"GPT-4 Turbo\", provider: \"openai\" },\n  { id: Model.GPT_4, name: \"GPT-4\", provider: \"openai\" },\n  { id: Model.GPT_3_5_TURBO, name: \"GPT-3.5 Turbo\", provider: \"openai\" },\n  { id: Model.O1, name: \"O1\", provider: \"openai\" },\n];\n\n// Helper function to get model by ID\nexport const getModelById = (id: string): ModelDefinition | undefined => {\n  return SUPPORTED_MODELS.find((model) => model.id === id);\n};\n\n// Helper function to check if model is supported\nexport const isModelSupported = (id: string): boolean => {\n  return SUPPORTED_MODELS.some((model) => model.id === id);\n};\n\nexport type BaseServerOptions = {\n  name?: string;\n  logger?: LogHandler;\n  timeout?: number;\n  capabilities?: ClientCapabilities;\n  enableServerLogs?: boolean;\n};\n\nexport type StdioServerDefinition = BaseServerOptions & {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n  url?: never;\n  requestInit?: never;\n  eventSourceInit?: never;\n  reconnectionOptions?: never;\n  sessionId?: never;\n  oauth?: never;\n};\n\nexport type HttpServerDefinition = BaseServerOptions & {\n  url: URL;\n  command?: never;\n  args?: never;\n  env?: never;\n  requestInit?: StreamableHTTPClientTransportOptions[\"requestInit\"];\n  eventSourceInit?: SSEClientTransportOptions[\"eventSourceInit\"];\n  reconnectionOptions?: StreamableHTTPClientTransportOptions[\"reconnectionOptions\"];\n  sessionId?: StreamableHTTPClientTransportOptions[\"sessionId\"];\n  oauth?: any;\n};\n\nexport interface ServerFormData {\n  name: string;\n  type: \"stdio\" | \"http\";\n  command?: string;\n  args?: string[];\n  url?: string;\n  headers?: Record<string, string>;\n  env?: Record<string, string>;\n  useOAuth?: boolean;\n  oauthScopes?: string[];\n}\n\nexport type MastraMCPServerDefinition =\n  | StdioServerDefinition\n  | HttpServerDefinition;\n\nexport interface OauthTokens {\n  client_id: string;\n  client_secret: string;\n  access_token: string;\n  refresh_token: string;\n  expires_in: number;\n  scope: string;\n}\n"],"names":[],"mappings":";;;;;;AAcO,IAAA,AAAK,+BAAA;;;;;;;;;;;;;;;;;;WAAA;;AAoBL,MAAM,mBAAsC;IACjD;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QAAE,EAAE;QAAiB,MAAM;QAAW,UAAU;IAAS;IACzD;QAAE,EAAE;QAAY,MAAM;QAAM,UAAU;IAAS;IAC/C;QAAE,EAAE;QAAiB,MAAM;QAAW,UAAU;IAAS;IACzD;QAAE,EAAE;QAAiB,MAAM;QAAW,UAAU;IAAS;IACzD;QAAE,EAAE;QAAsB,MAAM;QAAgB,UAAU;IAAS;IACnE;QAAE,EAAE;QAAsB,MAAM;QAAgB,UAAU;IAAS;IACnE;QAAE,EAAE;QAAgB,MAAM;QAAU,UAAU;IAAS;IACvD;QAAE,EAAE;QAAqB,MAAM;QAAe,UAAU;IAAS;IACjE;QAAE,EAAE;QAAqB,MAAM;QAAe,UAAU;IAAS;IACjE;QAAE,EAAE;QAAe,MAAM;QAAS,UAAU;IAAS;IACrD;QAAE,EAAE;QAAuB,MAAM;QAAiB,UAAU;IAAS;IACrE;QAAE,EAAE;QAAY,MAAM;QAAM,UAAU;IAAS;CAChD;AAGM,MAAM,eAAe,CAAC;IAC3B,OAAO,iBAAiB,IAAI,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;AACvD;AAGO,MAAM,mBAAmB,CAAC;IAC/B,OAAO,iBAAiB,IAAI,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;AACvD","debugId":null}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/ollama-utils.ts"],"sourcesContent":["interface OllamaModel {\n  name: string;\n  modified_at: string;\n  size: number;\n  digest: string;\n  details: {\n    format: string;\n    family: string;\n    families: string[] | null;\n    parameter_size: string;\n    quantization_level: string;\n  };\n}\n\ninterface OllamaModelsResponse {\n  models: OllamaModel[];\n}\n\nexport class OllamaClient {\n  private baseUrl: string;\n\n  constructor(baseUrl: string = \"http://localhost:11434\") {\n    this.baseUrl = baseUrl;\n  }\n\n  setBaseUrl(baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n\n  async isOllamaRunning(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/version`, {\n        method: \"GET\",\n        signal: AbortSignal.timeout(3000), // 3 second timeout\n      });\n      return response.ok;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async getAvailableModels(): Promise<string[]> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/tags`, {\n        method: \"GET\",\n        signal: AbortSignal.timeout(5000), // 5 second timeout\n      });\n\n      if (!response.ok) {\n        return [];\n      }\n\n      const data: OllamaModelsResponse = await response.json();\n      return data.models.map((model) => model.name);\n    } catch (error) {\n      console.warn(\"Failed to fetch Ollama models:\", error);\n      return [];\n    }\n  }\n\n  async checkModelExists(modelName: string): Promise<boolean> {\n    const availableModels = await this.getAvailableModels();\n    return availableModels.some(\n      (model) => model === modelName || model.startsWith(`${modelName}:`),\n    );\n  }\n\n  async getFilteredAvailableModels(\n    supportedModels: string[],\n  ): Promise<string[]> {\n    const availableModels = await this.getAvailableModels();\n\n    return supportedModels.filter((supportedModel) =>\n      availableModels.some(\n        (availableModel) =>\n          availableModel === supportedModel ||\n          availableModel.startsWith(`${supportedModel}:`),\n      ),\n    );\n  }\n}\n\n// Create a singleton instance\nexport const ollamaClient = new OllamaClient();\n\n// Utility functions\nexport const detectOllamaModels = async (\n  baseUrl?: string,\n): Promise<{\n  isRunning: boolean;\n  availableModels: string[];\n}> => {\n  // Use a temporary client with the provided base URL if given\n  const client = baseUrl ? new OllamaClient(baseUrl) : ollamaClient;\n\n  const isRunning = await client.isOllamaRunning();\n\n  if (!isRunning) {\n    return { isRunning: false, availableModels: [] };\n  }\n\n  const availableModels = await client.getAvailableModels();\n\n  return {\n    isRunning: true,\n    availableModels,\n  };\n};\n"],"names":[],"mappings":";;;;;AAkBO,MAAM;IACH,QAAgB;IAExB,YAAY,UAAkB,wBAAwB,CAAE;QACtD,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,WAAW,OAAe,EAAE;QAC1B,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,MAAM,kBAAoC;QACxC,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;gBAC1D,QAAQ;gBACR,QAAQ,YAAY,OAAO,CAAC;YAC9B;YACA,OAAO,SAAS,EAAE;QACpB,EAAE,OAAO,OAAO;YACd,OAAO;QACT;IACF;IAEA,MAAM,qBAAwC;QAC5C,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;gBACvD,QAAQ;gBACR,QAAQ,YAAY,OAAO,CAAC;YAC9B;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBAChB,OAAO,EAAE;YACX;YAEA,MAAM,OAA6B,MAAM,SAAS,IAAI;YACtD,OAAO,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC,QAAU,MAAM,IAAI;QAC9C,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,kCAAkC;YAC/C,OAAO,EAAE;QACX;IACF;IAEA,MAAM,iBAAiB,SAAiB,EAAoB;QAC1D,MAAM,kBAAkB,MAAM,IAAI,CAAC,kBAAkB;QACrD,OAAO,gBAAgB,IAAI,CACzB,CAAC,QAAU,UAAU,aAAa,MAAM,UAAU,CAAC,GAAG,UAAU,CAAC,CAAC;IAEtE;IAEA,MAAM,2BACJ,eAAyB,EACN;QACnB,MAAM,kBAAkB,MAAM,IAAI,CAAC,kBAAkB;QAErD,OAAO,gBAAgB,MAAM,CAAC,CAAC,iBAC7B,gBAAgB,IAAI,CAClB,CAAC,iBACC,mBAAmB,kBACnB,eAAe,UAAU,CAAC,GAAG,eAAe,CAAC,CAAC;IAGtD;AACF;AAGO,MAAM,eAAe,IAAI;AAGzB,MAAM,qBAAqB,OAChC;IAKA,6DAA6D;IAC7D,MAAM,SAAS,UAAU,IAAI,aAAa,WAAW;IAErD,MAAM,YAAY,MAAM,OAAO,eAAe;IAE9C,IAAI,CAAC,WAAW;QACd,OAAO;YAAE,WAAW;YAAO,iBAAiB,EAAE;QAAC;IACjD;IAEA,MAAM,kBAAkB,MAAM,OAAO,kBAAkB;IAEvD,OAAO;QACL,WAAW;QACX;IACF;AACF","debugId":null}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/date-utils.ts"],"sourcesContent":["import { format, parseISO } from \"date-fns\";\n\nexport const formatDate = (\n  date: string | Date,\n  formatString = \"HH:mm:ss.SSS\",\n): string => {\n  const dateToFormat = typeof date === \"string\" ? parseISO(date) : date;\n  return format(dateToFormat, formatString);\n};\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAEO,MAAM,aAAa,CACxB,MACA,eAAe,cAAc;IAE7B,MAAM,eAAe,OAAO,SAAS,WAAW,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ;IACjE,OAAO,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,cAAc;AAC9B","debugId":null}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/theme-utils.ts"],"sourcesContent":["export function updateThemeMode(value: \"light\" | \"dark\") {\n  const doc = document.documentElement;\n  doc.classList.add(\"disable-transitions\");\n  doc.classList.toggle(\"dark\", value === \"dark\");\n  requestAnimationFrame(() => {\n    doc.classList.remove(\"disable-transitions\");\n  });\n}\n\nexport function updateThemePreset(value: string) {\n  document.documentElement.setAttribute(\"data-theme-preset\", value);\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,gBAAgB,KAAuB;IACrD,MAAM,MAAM,SAAS,eAAe;IACpC,IAAI,SAAS,CAAC,GAAG,CAAC;IAClB,IAAI,SAAS,CAAC,MAAM,CAAC,QAAQ,UAAU;IACvC,sBAAsB;QACpB,IAAI,SAAS,CAAC,MAAM,CAAC;IACvB;AACF;AAEO,SAAS,kBAAkB,KAAa;IAC7C,SAAS,eAAe,CAAC,YAAY,CAAC,qBAAqB;AAC7D","debugId":null}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/mcp-oauth.ts"],"sourcesContent":["/**\n * Clean OAuth implementation using only the official MCP SDK\n */\n\nimport {\n  auth,\n  OAuthClientProvider,\n} from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport { HttpServerDefinition } from \"./types\";\n\nexport interface MCPOAuthOptions {\n  serverName: string;\n  serverUrl: string;\n  scopes?: string[];\n}\n\nexport interface OAuthResult {\n  success: boolean;\n  serverConfig?: HttpServerDefinition;\n  error?: string;\n}\n\n/**\n * Simple localStorage-based OAuth provider for MCP\n */\nclass MCPOAuthProvider implements OAuthClientProvider {\n  private serverName: string;\n  private redirectUri: string;\n\n  constructor(serverName: string) {\n    this.serverName = serverName;\n    this.redirectUri = `${window.location.origin}/oauth/callback`;\n  }\n\n  get redirectUrl(): string {\n    return this.redirectUri;\n  }\n\n  get clientMetadata() {\n    return {\n      client_name: `MCP Inspector - ${this.serverName}`,\n      client_uri: \"https://github.com/modelcontextprotocol/inspector\",\n      redirect_uris: [this.redirectUri],\n      grant_types: [\"authorization_code\", \"refresh_token\"],\n      response_types: [\"code\"],\n      token_endpoint_auth_method: \"client_secret_post\",\n      scope: \"mcp:*\",\n    };\n  }\n\n  clientInformation() {\n    const stored = localStorage.getItem(`mcp-client-${this.serverName}`);\n    return stored ? JSON.parse(stored) : undefined;\n  }\n\n  async saveClientInformation(clientInformation: any) {\n    localStorage.setItem(\n      `mcp-client-${this.serverName}`,\n      JSON.stringify(clientInformation),\n    );\n  }\n\n  tokens() {\n    const stored = localStorage.getItem(`mcp-tokens-${this.serverName}`);\n    return stored ? JSON.parse(stored) : undefined;\n  }\n\n  async saveTokens(tokens: any) {\n    localStorage.setItem(\n      `mcp-tokens-${this.serverName}`,\n      JSON.stringify(tokens),\n    );\n  }\n\n  async redirectToAuthorization(authorizationUrl: URL) {\n    // Store server name for callback recovery\n    console.log(\"Setting mcp-oauth-pending to:\", this.serverName);\n    localStorage.setItem(\"mcp-oauth-pending\", this.serverName);\n    window.location.href = authorizationUrl.toString();\n  }\n\n  async saveCodeVerifier(codeVerifier: string) {\n    localStorage.setItem(`mcp-verifier-${this.serverName}`, codeVerifier);\n  }\n\n  codeVerifier(): string {\n    const verifier = localStorage.getItem(`mcp-verifier-${this.serverName}`);\n    if (!verifier) {\n      throw new Error(\"Code verifier not found\");\n    }\n    return verifier;\n  }\n\n  async invalidateCredentials(scope: \"all\" | \"client\" | \"tokens\" | \"verifier\") {\n    switch (scope) {\n      case \"all\":\n        localStorage.removeItem(`mcp-tokens-${this.serverName}`);\n        localStorage.removeItem(`mcp-client-${this.serverName}`);\n        localStorage.removeItem(`mcp-verifier-${this.serverName}`);\n        break;\n      case \"client\":\n        localStorage.removeItem(`mcp-client-${this.serverName}`);\n        break;\n      case \"tokens\":\n        localStorage.removeItem(`mcp-tokens-${this.serverName}`);\n        break;\n      case \"verifier\":\n        localStorage.removeItem(`mcp-verifier-${this.serverName}`);\n        break;\n    }\n  }\n}\n\n/**\n * Initiates OAuth flow for an MCP server\n */\nexport async function initiateOAuth(\n  options: MCPOAuthOptions,\n): Promise<OAuthResult> {\n  try {\n    const provider = new MCPOAuthProvider(options.serverName);\n\n    // Store server URL for callback recovery\n    localStorage.setItem(\n      `mcp-serverUrl-${options.serverName}`,\n      options.serverUrl,\n    );\n    localStorage.setItem(\"mcp-oauth-pending\", options.serverName);\n\n    const result = await auth(provider, {\n      serverUrl: options.serverUrl,\n      scope: options.scopes?.join(\" \") || \"mcp:*\",\n    });\n\n    if (result === \"REDIRECT\") {\n      return {\n        success: true,\n      };\n    }\n\n    if (result === \"AUTHORIZED\") {\n      const tokens = provider.tokens();\n      if (tokens) {\n        const serverConfig = createServerConfig(options.serverUrl, tokens);\n        return {\n          success: true,\n          serverConfig,\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: \"OAuth flow failed\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown OAuth error\",\n    };\n  }\n}\n\n/**\n * Handles OAuth callback and completes the flow\n */\nexport async function handleOAuthCallback(\n  authorizationCode: string,\n): Promise<OAuthResult & { serverName?: string }> {\n  try {\n    // Get pending server name from localStorage\n    const serverName = localStorage.getItem(\"mcp-oauth-pending\");\n    if (!serverName) {\n      throw new Error(\"No pending OAuth flow found\");\n    }\n\n    // Get server URL\n    const serverUrl = localStorage.getItem(`mcp-serverUrl-${serverName}`);\n    if (!serverUrl) {\n      throw new Error(\"Server URL not found for OAuth callback\");\n    }\n\n    const provider = new MCPOAuthProvider(serverName);\n\n    const result = await auth(provider, {\n      serverUrl,\n      authorizationCode,\n      scope: \"mcp:*\",\n    });\n\n    if (result === \"AUTHORIZED\") {\n      const tokens = provider.tokens();\n      if (tokens) {\n        // Clean up pending state\n        localStorage.removeItem(\"mcp-oauth-pending\");\n\n        const serverConfig = createServerConfig(serverUrl, tokens);\n        return {\n          success: true,\n          serverConfig,\n          serverName, // Return server name so caller doesn't need to look it up\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: \"Token exchange failed\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown callback error\",\n    };\n  }\n}\n\n/**\n * Gets stored tokens for a server\n */\nexport function getStoredTokens(serverName: string): any {\n  const stored = localStorage.getItem(`mcp-tokens-${serverName}`);\n  return stored ? JSON.parse(stored) : undefined;\n}\n\n/**\n * Waits for tokens to be available with timeout\n */\nexport async function waitForTokens(\n  serverName: string,\n  timeoutMs: number = 5000,\n): Promise<any> {\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeoutMs) {\n    const tokens = getStoredTokens(serverName);\n    if (tokens?.access_token) {\n      return tokens;\n    }\n    await new Promise((resolve) => setTimeout(resolve, 100));\n  }\n\n  throw new Error(`Timeout waiting for tokens for server: ${serverName}`);\n}\n\n/**\n * Refreshes OAuth tokens for a server using the refresh token\n */\nexport async function refreshOAuthTokens(\n  serverName: string,\n): Promise<OAuthResult> {\n  try {\n    const provider = new MCPOAuthProvider(serverName);\n    const existingTokens = provider.tokens();\n\n    if (!existingTokens?.refresh_token) {\n      return {\n        success: false,\n        error: \"No refresh token available\",\n      };\n    }\n\n    // Get server URL\n    const serverUrl = localStorage.getItem(`mcp-serverUrl-${serverName}`);\n    if (!serverUrl) {\n      return {\n        success: false,\n        error: \"Server URL not found for token refresh\",\n      };\n    }\n\n    const result = await auth(provider, {\n      serverUrl,\n      scope: \"mcp:*\",\n    });\n\n    if (result === \"AUTHORIZED\") {\n      const tokens = provider.tokens();\n      if (tokens) {\n        const serverConfig = createServerConfig(serverUrl, tokens);\n        return {\n          success: true,\n          serverConfig,\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: \"Token refresh failed\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown refresh error\",\n    };\n  }\n}\n\n/**\n * Clears all OAuth data for a server\n */\nexport function clearOAuthData(serverName: string): void {\n  localStorage.removeItem(`mcp-tokens-${serverName}`);\n  localStorage.removeItem(`mcp-client-${serverName}`);\n  localStorage.removeItem(`mcp-verifier-${serverName}`);\n  localStorage.removeItem(`mcp-serverUrl-${serverName}`);\n}\n\n/**\n * Creates MCP server configuration with OAuth tokens\n */\nfunction createServerConfig(\n  serverUrl: string,\n  tokens: any,\n): HttpServerDefinition {\n  return {\n    url: new URL(serverUrl),\n    requestInit: {\n      headers: tokens.access_token\n        ? {\n            Authorization: `Bearer ${tokens.access_token}`,\n          }\n        : {},\n    },\n    oauth: tokens,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 654, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-logger.ts"],"sourcesContent":["import { useCallback, useMemo, useState, useEffect } from \"react\";\n\nexport type LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  context: string;\n  message: string;\n  data?: unknown;\n  error?: Error;\n}\n\nexport interface LoggerConfig {\n  level: LogLevel;\n  enableConsole: boolean;\n  maxBufferSize: number;\n}\n\nexport const LOG_LEVELS: Record<LogLevel, number> = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4,\n};\n\nconst LOG_COLORS: Record<LogLevel, string> = {\n  error: \"#ef4444\",\n  warn: \"#f59e0b\",\n  info: \"#3b82f6\",\n  debug: \"#8b5cf6\",\n  trace: \"#6b7280\",\n};\n\n// Global logger state\nclass LoggerState {\n  private config: LoggerConfig = {\n    level: \"info\",\n    enableConsole: true,\n    maxBufferSize: 1000,\n  };\n\n  private buffer: LogEntry[] = [];\n  private listeners: Set<() => void> = new Set();\n\n  setConfig(config: Partial<LoggerConfig>) {\n    this.config = { ...this.config, ...config };\n    this.notifyListeners();\n  }\n\n  getConfig(): LoggerConfig {\n    return { ...this.config };\n  }\n\n  addEntry(entry: LogEntry) {\n    this.buffer.push(entry);\n\n    // Maintain buffer size limit\n    if (this.buffer.length > this.config.maxBufferSize) {\n      this.buffer = this.buffer.slice(-this.config.maxBufferSize);\n    }\n\n    this.notifyListeners();\n  }\n\n  getEntries(): LogEntry[] {\n    return [...this.buffer];\n  }\n\n  getFilteredEntries(level?: LogLevel, context?: string): LogEntry[] {\n    let entries = this.buffer;\n\n    if (level) {\n      entries = entries.filter((entry) => entry.level === level);\n    }\n\n    if (context) {\n      const contextLower = context.toLowerCase();\n      entries = entries.filter((entry) =>\n        entry.context.toLowerCase().includes(contextLower),\n      );\n    }\n\n    return entries;\n  }\n\n  clearBuffer() {\n    this.buffer = [];\n    this.notifyListeners();\n  }\n\n  subscribe(listener: () => void) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  private notifyListeners() {\n    this.listeners.forEach((listener) => listener());\n  }\n\n  shouldLog(level: LogLevel): boolean {\n    return LOG_LEVELS[level] <= LOG_LEVELS[this.config.level];\n  }\n}\n\nconst loggerState = new LoggerState();\n\n// Set initial config based on environment\nif (typeof window !== \"undefined\") {\n  const isDevelopment = process.env.NODE_ENV === \"development\";\n  loggerState.setConfig({\n    level: isDevelopment ? \"debug\" : \"info\",\n    enableConsole: true,\n  });\n}\n\nexport interface Logger {\n  error: (message: string, data?: unknown, error?: Error) => void;\n  warn: (message: string, data?: unknown) => void;\n  info: (message: string, data?: unknown) => void;\n  debug: (message: string, data?: unknown) => void;\n  trace: (message: string, data?: unknown) => void;\n  context: string;\n}\n\nexport function useLogger(context: string = \"Unknown\"): Logger {\n  const createLogFunction = useCallback(\n    (level: LogLevel) => (message: string, data?: unknown, error?: Error) => {\n      if (!loggerState.shouldLog(level)) {\n        return;\n      }\n\n      const timestamp = new Date().toISOString();\n      const entry: LogEntry = {\n        timestamp,\n        level,\n        context,\n        message,\n        data,\n        error,\n      };\n\n      loggerState.addEntry(entry);\n\n      // Console output if enabled\n      const config = loggerState.getConfig();\n      if (config.enableConsole) {\n        outputToConsole(entry);\n      }\n    },\n    [context],\n  );\n\n  const logger = useMemo(\n    () => ({\n      error: createLogFunction(\"error\"),\n      warn: createLogFunction(\"warn\"),\n      info: createLogFunction(\"info\"),\n      debug: createLogFunction(\"debug\"),\n      trace: createLogFunction(\"trace\"),\n      context,\n    }),\n    [createLogFunction, context],\n  );\n\n  return logger;\n}\n\nfunction outputToConsole(entry: LogEntry) {\n  const { timestamp, level, context, message, data, error } = entry;\n  const time = new Date(timestamp).toLocaleTimeString();\n  const color = LOG_COLORS[level];\n\n  const contextStyle = `color: ${color}; font-weight: bold;`;\n  const messageStyle = `color: ${color};`;\n\n  const args: unknown[] = [\n    `%c[${time}] %c${level.toUpperCase()} %c[${context}] %c${message}`,\n    \"color: #6b7280;\",\n    contextStyle,\n    \"color: #6b7280;\",\n    messageStyle,\n  ];\n\n  if (data !== undefined) {\n    args.push(\"\\nData:\", data);\n  }\n\n  if (error) {\n    args.push(\"\\nError:\", error);\n  }\n\n  const consoleMethod =\n    level === \"error\"\n      ? console.error\n      : level === \"warn\"\n        ? console.warn\n        : level === \"debug\"\n          ? console.debug\n          : console.log;\n\n  consoleMethod(...args);\n}\n\n// Global logger utilities\nexport const LoggerUtils = {\n  setLevel: (level: LogLevel) => {\n    loggerState.setConfig({ level });\n  },\n\n  getLevel: (): LogLevel => {\n    return loggerState.getConfig().level;\n  },\n\n  setConsoleEnabled: (enabled: boolean) => {\n    loggerState.setConfig({ enableConsole: enabled });\n  },\n\n  isConsoleEnabled: (): boolean => {\n    return loggerState.getConfig().enableConsole;\n  },\n\n  getAllEntries: (): LogEntry[] => {\n    return loggerState.getEntries();\n  },\n\n  getFilteredEntries: (level?: LogLevel, context?: string): LogEntry[] => {\n    return loggerState.getFilteredEntries(level, context);\n  },\n\n  clearLogs: () => {\n    loggerState.clearBuffer();\n  },\n\n  subscribeToLogs: (callback: () => void) => {\n    return loggerState.subscribe(callback);\n  },\n\n  getConfig: () => {\n    return loggerState.getConfig();\n  },\n\n  setConfig: (config: Partial<LoggerConfig>) => {\n    loggerState.setConfig(config);\n  },\n};\n\n// Hook for components that need to observe log changes\nexport function useLoggerState() {\n  const [, forceUpdate] = useState({});\n\n  useEffect(() => {\n    const unsubscribe = loggerState.subscribe(() => {\n      forceUpdate({});\n    });\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  return {\n    entries: loggerState.getEntries(),\n    config: loggerState.getConfig(),\n    setConfig: loggerState.setConfig.bind(loggerState),\n    clearBuffer: loggerState.clearBuffer.bind(loggerState),\n    getFilteredEntries: loggerState.getFilteredEntries.bind(loggerState),\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 856, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-ai-provider-keys.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from \"react\";\n\nexport interface ProviderTokens {\n  anthropic: string;\n  openai: string;\n  ollama: string;\n  ollamaBaseUrl: string;\n}\n\nexport interface useAiProviderKeysReturn {\n  tokens: ProviderTokens;\n  setToken: (provider: keyof ProviderTokens, token: string) => void;\n  clearToken: (provider: keyof ProviderTokens) => void;\n  clearAllTokens: () => void;\n  hasToken: (provider: keyof ProviderTokens) => boolean;\n  getToken: (provider: keyof ProviderTokens) => string;\n  getOllamaBaseUrl: () => string;\n  setOllamaBaseUrl: (url: string) => void;\n}\n\nconst STORAGE_KEY = \"mcp-inspector-provider-tokens\";\n\nconst defaultTokens: ProviderTokens = {\n  anthropic: \"\",\n  openai: \"\",\n  ollama: \"local\", // Ollama runs locally, no API key needed\n  ollamaBaseUrl: \"http://localhost:11434\",\n};\n\nexport function useAiProviderKeys(): useAiProviderKeysReturn {\n  const [tokens, setTokens] = useState<ProviderTokens>(defaultTokens);\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Load tokens from localStorage on mount\n  useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (stored) {\n          const parsedTokens = JSON.parse(stored) as ProviderTokens;\n          setTokens(parsedTokens);\n        }\n      } catch (error) {\n        console.warn(\n          \"Failed to load provider tokens from localStorage:\",\n          error,\n        );\n      }\n      setIsInitialized(true);\n    }\n  }, []);\n\n  // Save tokens to localStorage whenever they change\n  useEffect(() => {\n    if (isInitialized && typeof window !== \"undefined\") {\n      try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(tokens));\n      } catch (error) {\n        console.warn(\"Failed to save provider tokens to localStorage:\", error);\n      }\n    }\n  }, [tokens, isInitialized]);\n\n  const setToken = useCallback(\n    (provider: keyof ProviderTokens, token: string) => {\n      setTokens((prev) => ({\n        ...prev,\n        [provider]: token,\n      }));\n    },\n    [],\n  );\n\n  const clearToken = useCallback((provider: keyof ProviderTokens) => {\n    setTokens((prev) => ({\n      ...prev,\n      [provider]: \"\",\n    }));\n  }, []);\n\n  const clearAllTokens = useCallback(() => {\n    setTokens(defaultTokens);\n  }, []);\n\n  const hasToken = useCallback(\n    (provider: keyof ProviderTokens) => {\n      return Boolean(tokens[provider]?.trim());\n    },\n    [tokens],\n  );\n\n  const getToken = useCallback(\n    (provider: keyof ProviderTokens) => {\n      return tokens[provider] || \"\";\n    },\n    [tokens],\n  );\n\n  const getOllamaBaseUrl = useCallback(() => {\n    return tokens.ollamaBaseUrl || defaultTokens.ollamaBaseUrl;\n  }, [tokens.ollamaBaseUrl]);\n\n  const setOllamaBaseUrl = useCallback((url: string) => {\n    setTokens((prev) => ({\n      ...prev,\n      ollamaBaseUrl: url,\n    }));\n  }, []);\n\n  return {\n    tokens,\n    setToken,\n    clearToken,\n    clearAllTokens,\n    hasToken,\n    getToken,\n    getOllamaBaseUrl,\n    setOllamaBaseUrl,\n  };\n}\n"],"names":[],"mappings":";;;AAEA;AAFA;;AAsBA,MAAM,cAAc;AAEpB,MAAM,gBAAgC;IACpC,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,eAAe;AACjB;AAEO,SAAS;IACd,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAkB;IACrD,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAEnD,yCAAyC;IACzC,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR;;IAeF,GAAG,EAAE;IAEL,mDAAmD;IACnD,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR;;IAOF,GAAG;QAAC;QAAQ;KAAc;IAE1B,MAAM,WAAW,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EACzB,CAAC,UAAgC;QAC/B,UAAU,CAAC,OAAS,CAAC;gBACnB,GAAG,IAAI;gBACP,CAAC,SAAS,EAAE;YACd,CAAC;IACH,GACA,EAAE;IAGJ,MAAM,aAAa,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,CAAC;QAC9B,UAAU,CAAC,OAAS,CAAC;gBACnB,GAAG,IAAI;gBACP,CAAC,SAAS,EAAE;YACd,CAAC;IACH,GAAG,EAAE;IAEL,MAAM,iBAAiB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE;QACjC,UAAU;IACZ,GAAG,EAAE;IAEL,MAAM,WAAW,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EACzB,CAAC;QACC,OAAO,QAAQ,MAAM,CAAC,SAAS,EAAE;IACnC,GACA;QAAC;KAAO;IAGV,MAAM,WAAW,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EACzB,CAAC;QACC,OAAO,MAAM,CAAC,SAAS,IAAI;IAC7B,GACA;QAAC;KAAO;IAGV,MAAM,mBAAmB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE;QACnC,OAAO,OAAO,aAAa,IAAI,cAAc,aAAa;IAC5D,GAAG;QAAC,OAAO,aAAa;KAAC;IAEzB,MAAM,mBAAmB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,CAAC;QACpC,UAAU,CAAC,OAAS,CAAC;gBACnB,GAAG,IAAI;gBACP,eAAe;YACjB,CAAC;IACH,GAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 936, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-chat.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { ChatMessage, ChatState, Attachment } from \"@/lib/chat-types\";\nimport { createMessage } from \"@/lib/chat-utils\";\nimport {\n  MastraMCPServerDefinition,\n  Model,\n  ModelDefinition,\n  SUPPORTED_MODELS,\n} from \"@/lib/types\";\nimport { useAiProviderKeys } from \"@/hooks/use-ai-provider-keys\";\nimport { detectOllamaModels } from \"@/lib/ollama-utils\";\n\ninterface ElicitationRequest {\n  requestId: string;\n  message: string;\n  schema: any;\n  timestamp: string;\n}\n\ninterface UseChatOptions {\n  initialMessages?: ChatMessage[];\n  serverConfigs?: Record<string, MastraMCPServerDefinition>;\n  systemPrompt?: string;\n  onMessageSent?: (message: ChatMessage) => void;\n  onMessageReceived?: (message: ChatMessage) => void;\n  onError?: (error: string) => void;\n  onModelChange?: (model: ModelDefinition) => void;\n}\n\nexport function useChat(options: UseChatOptions = {}) {\n  const { getToken, hasToken, tokens, getOllamaBaseUrl } = useAiProviderKeys();\n\n  const {\n    initialMessages = [],\n    serverConfigs,\n    systemPrompt,\n    onMessageSent,\n    onMessageReceived,\n    onError,\n    onModelChange,\n  } = options;\n\n  const [state, setState] = useState<ChatState>({\n    messages: initialMessages,\n    isLoading: false,\n    connectionStatus: \"disconnected\",\n  });\n  const [input, setInput] = useState(\"\");\n  const [status, setStatus] = useState<\"idle\" | \"error\">(\"idle\");\n  const [model, setModel] = useState<ModelDefinition | null>(null);\n  const [ollamaModels, setOllamaModels] = useState<ModelDefinition[]>([]);\n  const [isOllamaRunning, setIsOllamaRunning] = useState(false);\n  const [elicitationRequest, setElicitationRequest] = useState<ElicitationRequest | null>(null);\n  const [elicitationLoading, setElicitationLoading] = useState(false);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const messagesRef = useRef(state.messages);\n  console.log(\"model\", model);\n  useEffect(() => {\n    messagesRef.current = state.messages;\n  }, [state.messages]);\n\n  // Check for Ollama models on mount and periodically\n  useEffect(() => {\n    const checkOllama = async () => {\n      const { isRunning, availableModels } =\n        await detectOllamaModels(getOllamaBaseUrl());\n      setIsOllamaRunning(isRunning);\n\n      // Convert string model names to ModelDefinition objects\n      const ollamaModelDefinitions: ModelDefinition[] = availableModels.map(\n        (modelName) => ({\n          id: modelName,\n          name: modelName,\n          provider: \"ollama\" as const,\n        }),\n      );\n\n      setOllamaModels(ollamaModelDefinitions);\n    };\n\n    checkOllama();\n\n    // Check every 30 seconds for Ollama availability\n    const interval = setInterval(checkOllama, 30000);\n\n    return () => clearInterval(interval);\n  }, [getOllamaBaseUrl]);\n\n  useEffect(() => {\n    // Only set a model if we don't have one or the current model is not available\n    if (!model || !availableModels.some((m) => m.id === model.id)) {\n      if (isOllamaRunning && ollamaModels.length > 0) {\n        setModel(ollamaModels[0]);\n      } else if (hasToken(\"anthropic\")) {\n        const claudeModel = SUPPORTED_MODELS.find(\n          (m) => m.id === Model.CLAUDE_3_5_SONNET_LATEST,\n        );\n        if (claudeModel) setModel(claudeModel);\n      } else if (hasToken(\"openai\")) {\n        const gptModel = SUPPORTED_MODELS.find((m) => m.id === Model.GPT_4O);\n        if (gptModel) setModel(gptModel);\n      } else {\n        setModel(null);\n      }\n    }\n  }, [tokens, ollamaModels, isOllamaRunning, hasToken, model]);\n\n  const currentApiKey = useMemo(() => {\n    if (model) {\n      if (model.provider === \"ollama\") {\n        // For Ollama, return \"local\" if it's running and the model is available\n        return isOllamaRunning &&\n          ollamaModels.some(\n            (om) => om.id === model.id || om.id.startsWith(`${model.id}:`),\n          )\n          ? \"local\"\n          : \"\";\n      }\n      return getToken(model.provider);\n    }\n    return \"\";\n  }, [model, getToken, isOllamaRunning, ollamaModels]);\n\n  const handleModelChange = useCallback(\n    (newModel: ModelDefinition) => {\n      setModel(newModel);\n      if (onModelChange) {\n        onModelChange(newModel);\n      }\n    },\n    [onModelChange],\n  );\n\n  // Available models with API keys or local Ollama models\n  const availableModels = useMemo(() => {\n    const availableModelsList: ModelDefinition[] = [];\n\n    // Add supported models only if the provider has a valid API key\n    for (const model of SUPPORTED_MODELS) {\n      if (model.provider === \"anthropic\" && hasToken(\"anthropic\")) {\n        availableModelsList.push(model);\n      } else if (model.provider === \"openai\" && hasToken(\"openai\")) {\n        availableModelsList.push(model);\n      }\n    }\n\n    // Add Ollama models if Ollama is running\n    if (isOllamaRunning && ollamaModels.length > 0) {\n      availableModelsList.push(...ollamaModels);\n    }\n\n    return availableModelsList;\n  }, [isOllamaRunning, ollamaModels, hasToken]);\n\n  const handleStreamingEvent = useCallback(\n    (\n      parsed: any,\n      assistantMessage: ChatMessage,\n      assistantContent: { current: string },\n      toolCalls: { current: any[] },\n      toolResults: { current: any[] },\n    ) => {\n      // Handle text content\n      if (\n        (parsed.type === \"text\" || (!parsed.type && parsed.content)) &&\n        parsed.content\n      ) {\n        assistantContent.current += parsed.content;\n        setState((prev) => ({\n          ...prev,\n          messages: prev.messages.map((msg) =>\n            msg.id === assistantMessage.id\n              ? { ...msg, content: assistantContent.current }\n              : msg,\n          ),\n        }));\n        return;\n      }\n\n      // Handle tool calls\n      if (\n        (parsed.type === \"tool_call\" || (!parsed.type && parsed.toolCall)) &&\n        parsed.toolCall\n      ) {\n        const toolCall = parsed.toolCall;\n        toolCalls.current = [...toolCalls.current, toolCall];\n        setState((prev) => ({\n          ...prev,\n          messages: prev.messages.map((msg) =>\n            msg.id === assistantMessage.id\n              ? { ...msg, toolCalls: [...toolCalls.current] }\n              : msg,\n          ),\n        }));\n        return;\n      }\n\n      // Handle tool results\n      if (\n        (parsed.type === \"tool_result\" ||\n          (!parsed.type && parsed.toolResult)) &&\n        parsed.toolResult\n      ) {\n        const toolResult = parsed.toolResult;\n        toolResults.current = [...toolResults.current, toolResult];\n\n        // Update the corresponding tool call status\n        toolCalls.current = toolCalls.current.map((tc) =>\n          tc.id === toolResult.toolCallId\n            ? {\n                ...tc,\n                status: toolResult.error ? \"error\" : \"completed\",\n              }\n            : tc,\n        );\n\n        setState((prev) => ({\n          ...prev,\n          messages: prev.messages.map((msg) =>\n            msg.id === assistantMessage.id\n              ? {\n                  ...msg,\n                  toolCalls: [...toolCalls.current],\n                  toolResults: [...toolResults.current],\n                }\n              : msg,\n          ),\n        }));\n        return;\n      }\n\n      // Handle elicitation requests\n      if (parsed.type === \"elicitation_request\") {\n        setElicitationRequest({\n          requestId: parsed.requestId,\n          message: parsed.message,\n          schema: parsed.schema,\n          timestamp: parsed.timestamp,\n        });\n        return;\n      }\n\n      // Handle elicitation completion\n      if (parsed.type === \"elicitation_complete\") {\n        setElicitationRequest(null);\n        return;\n      }\n\n      // Handle errors\n      if (\n        (parsed.type === \"error\" || (!parsed.type && parsed.error)) &&\n        parsed.error\n      ) {\n        throw new Error(parsed.error);\n      }\n    },\n    [],\n  );\n\n  const sendChatRequest = useCallback(\n    async (userMessage: ChatMessage) => {\n      if (!serverConfigs || !model || !currentApiKey) {\n        throw new Error(\n          \"Missing required configuration: serverConfig, model, and apiKey are required\",\n        );\n      }\n\n      const assistantMessage = createMessage(\"assistant\", \"\");\n\n      setState((prev) => ({\n        ...prev,\n        messages: [...prev.messages, assistantMessage],\n      }));\n\n      try {\n        const response = await fetch(\"/api/mcp/chat\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Accept: \"text/event-stream\",\n          },\n          body: JSON.stringify({\n            serverConfigs,\n            model,\n            apiKey: currentApiKey,\n            systemPrompt,\n            messages: messagesRef.current.concat(userMessage),\n            ollamaBaseUrl: getOllamaBaseUrl(),\n          }),\n          signal: abortControllerRef.current?.signal,\n        });\n\n        if (!response.ok) {\n          const errorText = await response.text();\n          let errorData;\n          try {\n            errorData = JSON.parse(errorText);\n          } catch {\n            throw new Error(`Chat request failed: ${response.status}`);\n          }\n          throw new Error(errorData.error || \"Chat request failed\");\n        }\n\n        // Handle streaming response\n        const reader = response.body?.getReader();\n        const decoder = new TextDecoder();\n        const assistantContent = { current: \"\" };\n        const toolCalls = { current: [] as any[] };\n        const toolResults = { current: [] as any[] };\n        let buffer = \"\";\n        let isDone = false;\n\n        if (reader) {\n          while (!isDone) {\n            const { done, value } = await reader.read();\n            if (done) break;\n\n            buffer += decoder.decode(value, { stream: true });\n            const lines = buffer.split(\"\\n\");\n\n            // Keep the last incomplete line in the buffer\n            buffer = lines.pop() || \"\";\n\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const data = line.slice(6).trim();\n                if (data === \"[DONE]\") {\n                  isDone = true;\n                  setState((prev) => ({\n                    ...prev,\n                    isLoading: false,\n                  }));\n                  break;\n                }\n\n                if (data) {\n                  try {\n                    const parsed = JSON.parse(data);\n                    handleStreamingEvent(\n                      parsed,\n                      assistantMessage,\n                      assistantContent,\n                      toolCalls,\n                      toolResults,\n                    );\n                  } catch (parseError) {\n                    console.warn(\"Failed to parse SSE data:\", data, parseError);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // Ensure we have some content, even if empty\n        if (!assistantContent.current && !toolCalls.current.length) {\n          console.warn(\"No content received from stream\");\n        }\n\n        if (onMessageReceived) {\n          const finalMessage = {\n            ...assistantMessage,\n            content: assistantContent.current,\n          };\n          onMessageReceived(finalMessage);\n        }\n      } catch (error) {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n        }));\n        throw error;\n      }\n    },\n    [\n      serverConfigs,\n      model,\n      currentApiKey,\n      systemPrompt,\n      onMessageReceived,\n      handleStreamingEvent,\n      getOllamaBaseUrl,\n    ],\n  );\n\n  const sendMessage = useCallback(\n    async (content: string, attachments?: Attachment[]) => {\n      if (!content.trim() || state.isLoading) return;\n\n      const userMessage = createMessage(\"user\", content, attachments);\n\n      setState((prev) => ({\n        ...prev,\n        messages: [...prev.messages, userMessage],\n        isLoading: true,\n        error: undefined,\n      }));\n\n      if (onMessageSent) {\n        onMessageSent(userMessage);\n      }\n\n      // Create abort controller for this request\n      abortControllerRef.current = new AbortController();\n\n      try {\n        await sendChatRequest(userMessage);\n        setStatus(\"idle\");\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"An error occurred\";\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: errorMessage,\n        }));\n        setStatus(\"error\");\n\n        if (onError) {\n          onError(errorMessage);\n        }\n      }\n    },\n    [state.isLoading, onMessageSent, sendChatRequest, onError],\n  );\n\n  const stopGeneration = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    setState((prev) => ({\n      ...prev,\n      isLoading: false,\n    }));\n    setStatus(\"idle\");\n  }, []);\n\n  const regenerateMessage = useCallback(\n    async (messageId: string) => {\n      // Find the message and the user message before it\n      const messages = messagesRef.current;\n      const messageIndex = messages.findIndex((m) => m.id === messageId);\n      if (messageIndex === -1 || messageIndex === 0) return;\n\n      const userMessage = messages[messageIndex - 1];\n      if (userMessage.role !== \"user\") return;\n\n      // Remove the assistant message and regenerate\n      setState((prev) => ({\n        ...prev,\n        messages: prev.messages.slice(0, messageIndex),\n        isLoading: true,\n      }));\n\n      abortControllerRef.current = new AbortController();\n\n      try {\n        await sendChatRequest(userMessage);\n        setStatus(\"idle\");\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"An error occurred\";\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: errorMessage,\n        }));\n        setStatus(\"error\");\n\n        if (onError) {\n          onError(errorMessage);\n        }\n      }\n    },\n    [sendChatRequest, onError],\n  );\n\n  const deleteMessage = useCallback((messageId: string) => {\n    setState((prev) => ({\n      ...prev,\n      messages: prev.messages.filter((msg) => msg.id !== messageId),\n    }));\n  }, []);\n\n  const clearChat = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      messages: [],\n      error: undefined,\n    }));\n    setInput(\"\");\n  }, []);\n\n  const handleElicitationResponse = useCallback(\n    async (\n      action: \"accept\" | \"decline\" | \"cancel\",\n      parameters?: Record<string, any>,\n    ) => {\n      if (!elicitationRequest) {\n        console.warn(\"Cannot handle elicitation response: no active request\");\n        return;\n      }\n\n      setElicitationLoading(true);\n\n      try {\n        let responseData = null;\n        if (action === \"accept\") {\n          responseData = {\n            action: \"accept\",\n            content: parameters || {},\n          };\n        } else {\n          responseData = {\n            action,\n          };\n        }\n\n        const response = await fetch(\"/api/mcp/chat\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            action: \"elicitation_response\",\n            requestId: elicitationRequest.requestId,\n            response: responseData,\n          }),\n        });\n\n        if (!response.ok) {\n          const errorMsg = `HTTP error! status: ${response.status}`;\n          throw new Error(errorMsg);\n        }\n\n        setElicitationRequest(null);\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        console.error(\"Error responding to elicitation request:\", errorMessage);\n        \n        if (onError) {\n          onError(\"Error responding to elicitation request\");\n        }\n      } finally {\n        setElicitationLoading(false);\n      }\n    },\n    [elicitationRequest, onError],\n  );\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return {\n    // State\n    messages: state.messages,\n    isLoading: state.isLoading,\n    error: state.error,\n    connectionStatus: state.connectionStatus,\n    status,\n    input,\n    setInput,\n    model,\n    availableModels,\n    hasValidApiKey: Boolean(currentApiKey),\n    elicitationRequest,\n    elicitationLoading,\n\n    // Actions\n    sendMessage,\n    stopGeneration,\n    regenerateMessage,\n    deleteMessage,\n    clearChat,\n    setModel: handleModelChange,\n    handleElicitationResponse,\n  };\n}\n"],"names":[],"mappings":";;;AAEA;AAEA;AACA;AAMA;AACA;AAZA;;;;;;AA+BO,SAAS,QAAQ,UAA0B,CAAC,CAAC;IAClD,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,gBAAgB,EAAE,GAAG,CAAA,GAAA,6IAAA,CAAA,oBAAiB,AAAD;IAEzE,MAAM,EACJ,kBAAkB,EAAE,EACpB,aAAa,EACb,YAAY,EACZ,aAAa,EACb,iBAAiB,EACjB,OAAO,EACP,aAAa,EACd,GAAG;IAEJ,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAa;QAC5C,UAAU;QACV,WAAW;QACX,kBAAkB;IACpB;IACA,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACnC,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAoB;IACvD,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAA0B;IAC3D,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAqB,EAAE;IACtE,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACvD,MAAM,CAAC,oBAAoB,sBAAsB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAA6B;IACxF,MAAM,CAAC,oBAAoB,sBAAsB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAC7D,MAAM,qBAAqB,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAA0B;IAC1D,MAAM,cAAc,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAE,MAAM,QAAQ;IACzC,QAAQ,GAAG,CAAC,SAAS;IACrB,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,YAAY,OAAO,GAAG,MAAM,QAAQ;IACtC,GAAG;QAAC,MAAM,QAAQ;KAAC;IAEnB,oDAAoD;IACpD,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,cAAc;YAClB,MAAM,EAAE,SAAS,EAAE,eAAe,EAAE,GAClC,MAAM,CAAA,GAAA,6HAAA,CAAA,qBAAkB,AAAD,EAAE;YAC3B,mBAAmB;YAEnB,wDAAwD;YACxD,MAAM,yBAA4C,gBAAgB,GAAG,CACnE,CAAC,YAAc,CAAC;oBACd,IAAI;oBACJ,MAAM;oBACN,UAAU;gBACZ,CAAC;YAGH,gBAAgB;QAClB;QAEA;QAEA,iDAAiD;QACjD,MAAM,WAAW,YAAY,aAAa;QAE1C,OAAO,IAAM,cAAc;IAC7B,GAAG;QAAC;KAAiB;IAErB,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,8EAA8E;QAC9E,IAAI,CAAC,SAAS,CAAC,gBAAgB,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK,MAAM,EAAE,GAAG;YAC7D,IAAI,mBAAmB,aAAa,MAAM,GAAG,GAAG;gBAC9C,SAAS,YAAY,CAAC,EAAE;YAC1B,OAAO,IAAI,SAAS,cAAc;gBAChC,MAAM,cAAc,mHAAA,CAAA,mBAAgB,CAAC,IAAI,CACvC,CAAC,IAAM,EAAE,EAAE,KAAK,mHAAA,CAAA,QAAK,CAAC,wBAAwB;gBAEhD,IAAI,aAAa,SAAS;YAC5B,OAAO,IAAI,SAAS,WAAW;gBAC7B,MAAM,WAAW,mHAAA,CAAA,mBAAgB,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK,mHAAA,CAAA,QAAK,CAAC,MAAM;gBACnE,IAAI,UAAU,SAAS;YACzB,OAAO;gBACL,SAAS;YACX;QACF;IACF,GAAG;QAAC;QAAQ;QAAc;QAAiB;QAAU;KAAM;IAE3D,MAAM,gBAAgB,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QAC5B,IAAI,OAAO;YACT,IAAI,MAAM,QAAQ,KAAK,UAAU;gBAC/B,wEAAwE;gBACxE,OAAO,mBACL,aAAa,IAAI,CACf,CAAC,KAAO,GAAG,EAAE,KAAK,MAAM,EAAE,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,GAAG,MAAM,EAAE,CAAC,CAAC,CAAC,KAE7D,UACA;YACN;YACA,OAAO,SAAS,MAAM,QAAQ;QAChC;QACA,OAAO;IACT,GAAG;QAAC;QAAO;QAAU;QAAiB;KAAa;IAEnD,MAAM,oBAAoB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAClC,CAAC;QACC,SAAS;QACT,IAAI,eAAe;YACjB,cAAc;QAChB;IACF,GACA;QAAC;KAAc;IAGjB,wDAAwD;IACxD,MAAM,kBAAkB,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QAC9B,MAAM,sBAAyC,EAAE;QAEjD,gEAAgE;QAChE,KAAK,MAAM,SAAS,mHAAA,CAAA,mBAAgB,CAAE;YACpC,IAAI,MAAM,QAAQ,KAAK,eAAe,SAAS,cAAc;gBAC3D,oBAAoB,IAAI,CAAC;YAC3B,OAAO,IAAI,MAAM,QAAQ,KAAK,YAAY,SAAS,WAAW;gBAC5D,oBAAoB,IAAI,CAAC;YAC3B;QACF;QAEA,yCAAyC;QACzC,IAAI,mBAAmB,aAAa,MAAM,GAAG,GAAG;YAC9C,oBAAoB,IAAI,IAAI;QAC9B;QAEA,OAAO;IACT,GAAG;QAAC;QAAiB;QAAc;KAAS;IAE5C,MAAM,uBAAuB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EACrC,CACE,QACA,kBACA,kBACA,WACA;QAEA,sBAAsB;QACtB,IACE,CAAC,OAAO,IAAI,KAAK,UAAW,CAAC,OAAO,IAAI,IAAI,OAAO,OAAO,AAAC,KAC3D,OAAO,OAAO,EACd;YACA,iBAAiB,OAAO,IAAI,OAAO,OAAO;YAC1C,SAAS,CAAC,OAAS,CAAC;oBAClB,GAAG,IAAI;oBACP,UAAU,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC,MAC3B,IAAI,EAAE,KAAK,iBAAiB,EAAE,GAC1B;4BAAE,GAAG,GAAG;4BAAE,SAAS,iBAAiB,OAAO;wBAAC,IAC5C;gBAER,CAAC;YACD;QACF;QAEA,oBAAoB;QACpB,IACE,CAAC,OAAO,IAAI,KAAK,eAAgB,CAAC,OAAO,IAAI,IAAI,OAAO,QAAQ,AAAC,KACjE,OAAO,QAAQ,EACf;YACA,MAAM,WAAW,OAAO,QAAQ;YAChC,UAAU,OAAO,GAAG;mBAAI,UAAU,OAAO;gBAAE;aAAS;YACpD,SAAS,CAAC,OAAS,CAAC;oBAClB,GAAG,IAAI;oBACP,UAAU,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC,MAC3B,IAAI,EAAE,KAAK,iBAAiB,EAAE,GAC1B;4BAAE,GAAG,GAAG;4BAAE,WAAW;mCAAI,UAAU,OAAO;6BAAC;wBAAC,IAC5C;gBAER,CAAC;YACD;QACF;QAEA,sBAAsB;QACtB,IACE,CAAC,OAAO,IAAI,KAAK,iBACd,CAAC,OAAO,IAAI,IAAI,OAAO,UAAU,AAAC,KACrC,OAAO,UAAU,EACjB;YACA,MAAM,aAAa,OAAO,UAAU;YACpC,YAAY,OAAO,GAAG;mBAAI,YAAY,OAAO;gBAAE;aAAW;YAE1D,4CAA4C;YAC5C,UAAU,OAAO,GAAG,UAAU,OAAO,CAAC,GAAG,CAAC,CAAC,KACzC,GAAG,EAAE,KAAK,WAAW,UAAU,GAC3B;oBACE,GAAG,EAAE;oBACL,QAAQ,WAAW,KAAK,GAAG,UAAU;gBACvC,IACA;YAGN,SAAS,CAAC,OAAS,CAAC;oBAClB,GAAG,IAAI;oBACP,UAAU,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC,MAC3B,IAAI,EAAE,KAAK,iBAAiB,EAAE,GAC1B;4BACE,GAAG,GAAG;4BACN,WAAW;mCAAI,UAAU,OAAO;6BAAC;4BACjC,aAAa;mCAAI,YAAY,OAAO;6BAAC;wBACvC,IACA;gBAER,CAAC;YACD;QACF;QAEA,8BAA8B;QAC9B,IAAI,OAAO,IAAI,KAAK,uBAAuB;YACzC,sBAAsB;gBACpB,WAAW,OAAO,SAAS;gBAC3B,SAAS,OAAO,OAAO;gBACvB,QAAQ,OAAO,MAAM;gBACrB,WAAW,OAAO,SAAS;YAC7B;YACA;QACF;QAEA,gCAAgC;QAChC,IAAI,OAAO,IAAI,KAAK,wBAAwB;YAC1C,sBAAsB;YACtB;QACF;QAEA,gBAAgB;QAChB,IACE,CAAC,OAAO,IAAI,KAAK,WAAY,CAAC,OAAO,IAAI,IAAI,OAAO,KAAK,AAAC,KAC1D,OAAO,KAAK,EACZ;YACA,MAAM,IAAI,MAAM,OAAO,KAAK;QAC9B;IACF,GACA,EAAE;IAGJ,MAAM,kBAAkB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAChC,OAAO;QACL,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,eAAe;YAC9C,MAAM,IAAI,MACR;QAEJ;QAEA,MAAM,mBAAmB,CAAA,GAAA,2HAAA,CAAA,gBAAa,AAAD,EAAE,aAAa;QAEpD,SAAS,CAAC,OAAS,CAAC;gBAClB,GAAG,IAAI;gBACP,UAAU;uBAAI,KAAK,QAAQ;oBAAE;iBAAiB;YAChD,CAAC;QAED,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,iBAAiB;gBAC5C,QAAQ;gBACR,SAAS;oBACP,gBAAgB;oBAChB,QAAQ;gBACV;gBACA,MAAM,KAAK,SAAS,CAAC;oBACnB;oBACA;oBACA,QAAQ;oBACR;oBACA,UAAU,YAAY,OAAO,CAAC,MAAM,CAAC;oBACrC,eAAe;gBACjB;gBACA,QAAQ,mBAAmB,OAAO,EAAE;YACtC;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBAChB,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,IAAI;gBACJ,IAAI;oBACF,YAAY,KAAK,KAAK,CAAC;gBACzB,EAAE,OAAM;oBACN,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,SAAS,MAAM,EAAE;gBAC3D;gBACA,MAAM,IAAI,MAAM,UAAU,KAAK,IAAI;YACrC;YAEA,4BAA4B;YAC5B,MAAM,SAAS,SAAS,IAAI,EAAE;YAC9B,MAAM,UAAU,IAAI;YACpB,MAAM,mBAAmB;gBAAE,SAAS;YAAG;YACvC,MAAM,YAAY;gBAAE,SAAS,EAAE;YAAU;YACzC,MAAM,cAAc;gBAAE,SAAS,EAAE;YAAU;YAC3C,IAAI,SAAS;YACb,IAAI,SAAS;YAEb,IAAI,QAAQ;gBACV,MAAO,CAAC,OAAQ;oBACd,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO,IAAI;oBACzC,IAAI,MAAM;oBAEV,UAAU,QAAQ,MAAM,CAAC,OAAO;wBAAE,QAAQ;oBAAK;oBAC/C,MAAM,QAAQ,OAAO,KAAK,CAAC;oBAE3B,8CAA8C;oBAC9C,SAAS,MAAM,GAAG,MAAM;oBAExB,KAAK,MAAM,QAAQ,MAAO;wBACxB,IAAI,KAAK,UAAU,CAAC,WAAW;4BAC7B,MAAM,OAAO,KAAK,KAAK,CAAC,GAAG,IAAI;4BAC/B,IAAI,SAAS,UAAU;gCACrB,SAAS;gCACT,SAAS,CAAC,OAAS,CAAC;wCAClB,GAAG,IAAI;wCACP,WAAW;oCACb,CAAC;gCACD;4BACF;4BAEA,IAAI,MAAM;gCACR,IAAI;oCACF,MAAM,SAAS,KAAK,KAAK,CAAC;oCAC1B,qBACE,QACA,kBACA,kBACA,WACA;gCAEJ,EAAE,OAAO,YAAY;oCACnB,QAAQ,IAAI,CAAC,6BAA6B,MAAM;gCAClD;4BACF;wBACF;oBACF;gBACF;YACF;YAEA,6CAA6C;YAC7C,IAAI,CAAC,iBAAiB,OAAO,IAAI,CAAC,UAAU,OAAO,CAAC,MAAM,EAAE;gBAC1D,QAAQ,IAAI,CAAC;YACf;YAEA,IAAI,mBAAmB;gBACrB,MAAM,eAAe;oBACnB,GAAG,gBAAgB;oBACnB,SAAS,iBAAiB,OAAO;gBACnC;gBACA,kBAAkB;YACpB;QACF,EAAE,OAAO,OAAO;YACd,SAAS,CAAC,OAAS,CAAC;oBAClB,GAAG,IAAI;oBACP,WAAW;gBACb,CAAC;YACD,MAAM;QACR;IACF,GACA;QACE;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAGH,MAAM,cAAc,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAC5B,OAAO,SAAiB;QACtB,IAAI,CAAC,QAAQ,IAAI,MAAM,MAAM,SAAS,EAAE;QAExC,MAAM,cAAc,CAAA,GAAA,2HAAA,CAAA,gBAAa,AAAD,EAAE,QAAQ,SAAS;QAEnD,SAAS,CAAC,OAAS,CAAC;gBAClB,GAAG,IAAI;gBACP,UAAU;uBAAI,KAAK,QAAQ;oBAAE;iBAAY;gBACzC,WAAW;gBACX,OAAO;YACT,CAAC;QAED,IAAI,eAAe;YACjB,cAAc;QAChB;QAEA,2CAA2C;QAC3C,mBAAmB,OAAO,GAAG,IAAI;QAEjC,IAAI;YACF,MAAM,gBAAgB;YACtB,UAAU;QACZ,EAAE,OAAO,OAAO;YACd,MAAM,eACJ,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAC3C,SAAS,CAAC,OAAS,CAAC;oBAClB,GAAG,IAAI;oBACP,WAAW;oBACX,OAAO;gBACT,CAAC;YACD,UAAU;YAEV,IAAI,SAAS;gBACX,QAAQ;YACV;QACF;IACF,GACA;QAAC,MAAM,SAAS;QAAE;QAAe;QAAiB;KAAQ;IAG5D,MAAM,iBAAiB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE;QACjC,IAAI,mBAAmB,OAAO,EAAE;YAC9B,mBAAmB,OAAO,CAAC,KAAK;QAClC;QACA,SAAS,CAAC,OAAS,CAAC;gBAClB,GAAG,IAAI;gBACP,WAAW;YACb,CAAC;QACD,UAAU;IACZ,GAAG,EAAE;IAEL,MAAM,oBAAoB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAClC,OAAO;QACL,kDAAkD;QAClD,MAAM,WAAW,YAAY,OAAO;QACpC,MAAM,eAAe,SAAS,SAAS,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;QACxD,IAAI,iBAAiB,CAAC,KAAK,iBAAiB,GAAG;QAE/C,MAAM,cAAc,QAAQ,CAAC,eAAe,EAAE;QAC9C,IAAI,YAAY,IAAI,KAAK,QAAQ;QAEjC,8CAA8C;QAC9C,SAAS,CAAC,OAAS,CAAC;gBAClB,GAAG,IAAI;gBACP,UAAU,KAAK,QAAQ,CAAC,KAAK,CAAC,GAAG;gBACjC,WAAW;YACb,CAAC;QAED,mBAAmB,OAAO,GAAG,IAAI;QAEjC,IAAI;YACF,MAAM,gBAAgB;YACtB,UAAU;QACZ,EAAE,OAAO,OAAO;YACd,MAAM,eACJ,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAC3C,SAAS,CAAC,OAAS,CAAC;oBAClB,GAAG,IAAI;oBACP,WAAW;oBACX,OAAO;gBACT,CAAC;YACD,UAAU;YAEV,IAAI,SAAS;gBACX,QAAQ;YACV;QACF;IACF,GACA;QAAC;QAAiB;KAAQ;IAG5B,MAAM,gBAAgB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,CAAC;QACjC,SAAS,CAAC,OAAS,CAAC;gBAClB,GAAG,IAAI;gBACP,UAAU,KAAK,QAAQ,CAAC,MAAM,CAAC,CAAC,MAAQ,IAAI,EAAE,KAAK;YACrD,CAAC;IACH,GAAG,EAAE;IAEL,MAAM,YAAY,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE;QAC5B,SAAS,CAAC,OAAS,CAAC;gBAClB,GAAG,IAAI;gBACP,UAAU,EAAE;gBACZ,OAAO;YACT,CAAC;QACD,SAAS;IACX,GAAG,EAAE;IAEL,MAAM,4BAA4B,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAC1C,OACE,QACA;QAEA,IAAI,CAAC,oBAAoB;YACvB,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,sBAAsB;QAEtB,IAAI;YACF,IAAI,eAAe;YACnB,IAAI,WAAW,UAAU;gBACvB,eAAe;oBACb,QAAQ;oBACR,SAAS,cAAc,CAAC;gBAC1B;YACF,OAAO;gBACL,eAAe;oBACb;gBACF;YACF;YAEA,MAAM,WAAW,MAAM,MAAM,iBAAiB;gBAC5C,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;gBACA,MAAM,KAAK,SAAS,CAAC;oBACnB,QAAQ;oBACR,WAAW,mBAAmB,SAAS;oBACvC,UAAU;gBACZ;YACF;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBAChB,MAAM,WAAW,CAAC,oBAAoB,EAAE,SAAS,MAAM,EAAE;gBACzD,MAAM,IAAI,MAAM;YAClB;YAEA,sBAAsB;QACxB,EAAE,OAAO,KAAK;YACZ,MAAM,eACJ,eAAe,QAAQ,IAAI,OAAO,GAAG;YACvC,QAAQ,KAAK,CAAC,4CAA4C;YAE1D,IAAI,SAAS;gBACX,QAAQ;YACV;QACF,SAAU;YACR,sBAAsB;QACxB;IACF,GACA;QAAC;QAAoB;KAAQ;IAG/B,qBAAqB;IACrB,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,OAAO;YACL,IAAI,mBAAmB,OAAO,EAAE;gBAC9B,mBAAmB,OAAO,CAAC,KAAK;YAClC;QACF;IACF,GAAG,EAAE;IAEL,OAAO;QACL,QAAQ;QACR,UAAU,MAAM,QAAQ;QACxB,WAAW,MAAM,SAAS;QAC1B,OAAO,MAAM,KAAK;QAClB,kBAAkB,MAAM,gBAAgB;QACxC;QACA;QACA;QACA;QACA;QACA,gBAAgB,QAAQ;QACxB;QACA;QAEA,UAAU;QACV;QACA;QACA;QACA;QACA;QACA,UAAU;QACV;IACF;AACF","debugId":null}},
    {"offset": {"line": 1427, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-mobile.ts"],"sourcesContent":["import * as React from \"react\";\n\nconst MOBILE_BREAKPOINT = 768;\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(\n    undefined,\n  );\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    };\n    mql.addEventListener(\"change\", onChange);\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    return () => mql.removeEventListener(\"change\", onChange);\n  }, []);\n\n  return !!isMobile;\n}\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,oBAAoB;AAEnB,SAAS;IACd,MAAM,CAAC,UAAU,YAAY,GAAG,qMAAA,CAAA,WAAc,CAC5C;IAGF,qMAAA,CAAA,YAAe,CAAC;QACd,MAAM,MAAM,OAAO,UAAU,CAAC,CAAC,YAAY,EAAE,oBAAoB,EAAE,GAAG,CAAC;QACvE,MAAM,WAAW;YACf,YAAY,OAAO,UAAU,GAAG;QAClC;QACA,IAAI,gBAAgB,CAAC,UAAU;QAC/B,YAAY,OAAO,UAAU,GAAG;QAChC,OAAO,IAAM,IAAI,mBAAmB,CAAC,UAAU;IACjD,GAAG,EAAE;IAEL,OAAO,CAAC,CAAC;AACX","debugId":null}},
    {"offset": {"line": 1450, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-app-state.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from \"react\";\nimport { toast } from \"sonner\";\nimport {\n  initiateOAuth,\n  handleOAuthCallback,\n  getStoredTokens,\n  clearOAuthData,\n  refreshOAuthTokens,\n} from \"@/lib/mcp-oauth\";\nimport {\n  MastraMCPServerDefinition,\n  StdioServerDefinition,\n  HttpServerDefinition,\n  OauthTokens,\n} from \"@/lib/types\";\nimport { useLogger } from \"./use-logger\";\n\nexport interface ServerWithName {\n  name: string;\n  config: MastraMCPServerDefinition;\n  oauthTokens?: OauthTokens;\n  lastConnectionTime: Date;\n  connectionStatus:\n    | \"connected\"\n    | \"connecting\"\n    | \"failed\"\n    | \"disconnected\"\n    | \"oauth-flow\";\n  retryCount: number;\n  lastError?: string;\n}\n\nexport interface AppState {\n  servers: Record<string, ServerWithName>;\n  selectedServer: string;\n  selectedMultipleServers: string[]; // Array of selected server names for multi-select mode\n  isMultiSelectMode: boolean; // Flag to enable/disable multi-select mode\n}\n\nexport interface ServerFormData {\n  name: string;\n  type: \"stdio\" | \"http\";\n  command?: string;\n  args?: string[];\n  url?: string;\n  headers?: Record<string, string>;\n  env?: Record<string, string>;\n  useOAuth?: boolean;\n  oauthScopes?: string[];\n}\n\nconst STORAGE_KEY = \"mcp-inspector-state\";\n\nexport function useAppState() {\n  const logger = useLogger(\"Connections\");\n\n  const [appState, setAppState] = useState<AppState>({\n    servers: {},\n    selectedServer: \"none\",\n    selectedMultipleServers: [],\n    isMultiSelectMode: false,\n  });\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [reconnectionTimeouts, setReconnectionTimeouts] = useState<\n    Record<string, NodeJS.Timeout>\n  >({});\n\n  // Load state from localStorage on mount\n  useEffect(() => {\n    const savedState = localStorage.getItem(STORAGE_KEY);\n    if (savedState) {\n      try {\n        const parsed = JSON.parse(savedState);\n        // Ensure all loaded servers have the new fields with defaults\n        const updatedServers = Object.fromEntries(\n          Object.entries(parsed.servers || {}).map(\n            ([name, server]: [string, any]) => [\n              name,\n              {\n                ...server,\n                connectionStatus: server.connectionStatus || \"disconnected\",\n                retryCount: server.retryCount || 0,\n                lastConnectionTime: server.lastConnectionTime\n                  ? new Date(server.lastConnectionTime)\n                  : new Date(),\n              },\n            ],\n          ),\n        );\n        setAppState({\n          servers: updatedServers,\n          selectedServer: parsed.selectedServer || \"none\",\n          selectedMultipleServers: parsed.selectedMultipleServers || [],\n          isMultiSelectMode: parsed.isMultiSelectMode || false,\n        });\n      } catch (error) {\n        logger.error(\"Failed to parse saved state\", {\n          error: error instanceof Error ? error.message : \"Unknown error\",\n        });\n      }\n    }\n    setIsLoading(false);\n  }, []);\n\n  // Save state to localStorage whenever it changes\n  useEffect(() => {\n    if (!isLoading) {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));\n    }\n  }, [appState, isLoading]);\n\n  const setSelectedMultipleServersToAllServers = useCallback(() => {\n    setAppState((prev) => ({\n      ...prev,\n      selectedMultipleServers: Object.keys(appState.servers),\n    }));\n  }, [appState.servers]);\n\n  // Check for OAuth callback completion on mount\n  useEffect(() => {\n    if (!isLoading) {\n      const urlParams = new URLSearchParams(window.location.search);\n      const code = urlParams.get(\"code\");\n      const error = urlParams.get(\"error\");\n\n      if (code) {\n        handleOAuthCallbackComplete(code);\n      } else if (error) {\n        toast.error(`OAuth authorization failed: ${error}`);\n      }\n    }\n  }, [isLoading]);\n\n  const convertFormToMCPConfig = useCallback(\n    (formData: ServerFormData): MastraMCPServerDefinition => {\n      if (formData.type === \"stdio\") {\n        return {\n          command: formData.command!,\n          args: formData.args,\n          env: formData.env,\n        } as StdioServerDefinition;\n      } else {\n        return {\n          url: new URL(formData.url!),\n          requestInit: { headers: formData.headers || {} },\n        } as HttpServerDefinition;\n      }\n    },\n    [],\n  );\n\n  const handleConnect = useCallback(\n    async (formData: ServerFormData) => {\n      // Validate form data first\n      console.log(\"handleConnectFormData\", formData);\n      if (formData.type === \"stdio\") {\n        if (!formData.command || formData.command.trim() === \"\") {\n          toast.error(\"Command is required for STDIO connections\");\n          return;\n        }\n      } else {\n        if (!formData.url || formData.url.trim() === \"\") {\n          toast.error(\"URL is required for HTTP connections\");\n          return;\n        }\n\n        try {\n          new URL(formData.url);\n        } catch (urlError) {\n          toast.error(`Invalid URL format: ${formData.url} ${urlError}`);\n          return;\n        }\n      }\n\n      // Convert form data to MCP config\n      const mcpConfig = convertFormToMCPConfig(formData);\n\n      // Immediately create server with 'connecting' state for responsive UI\n      setAppState((prev) => ({\n        ...prev,\n        servers: {\n          ...prev.servers,\n          [formData.name]: {\n            name: formData.name,\n            config: mcpConfig,\n            lastConnectionTime: new Date(),\n            connectionStatus: \"connecting\" as const,\n            retryCount: 0,\n          },\n        },\n        selectedServer: formData.name,\n      }));\n\n      try {\n        // Handle OAuth flow for HTTP servers\n        if (formData.type === \"http\" && formData.useOAuth && formData.url) {\n          // Mark as OAuth flow in progress\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [formData.name]: {\n                ...prev.servers[formData.name],\n                connectionStatus: \"oauth-flow\" as const,\n              },\n            },\n          }));\n\n          const oauthResult = await initiateOAuth({\n            serverName: formData.name,\n            serverUrl: formData.url,\n            scopes: formData.oauthScopes || [\"mcp:*\"],\n          });\n\n          if (oauthResult.success) {\n            if (oauthResult.serverConfig) {\n              // Already authorized, test connection immediately\n              try {\n                const response = await fetch(\"/api/mcp/connect\", {\n                  method: \"POST\",\n                  headers: { \"Content-Type\": \"application/json\" },\n                  body: JSON.stringify({\n                    serverConfig: oauthResult.serverConfig,\n                  }),\n                });\n\n                const connectionResult = await response.json();\n\n                if (connectionResult.success) {\n                  setAppState((prev) => ({\n                    ...prev,\n                    servers: {\n                      ...prev.servers,\n                      [formData.name]: {\n                        ...prev.servers[formData.name],\n                        config: oauthResult.serverConfig!,\n                        connectionStatus: \"connected\" as const,\n                        oauthTokens: getStoredTokens(formData.name),\n                        lastError: undefined,\n                      },\n                    },\n                  }));\n                  toast.success(`Connected successfully with OAuth!`);\n                } else {\n                  setAppState((prev) => ({\n                    ...prev,\n                    servers: {\n                      ...prev.servers,\n                      [formData.name]: {\n                        ...prev.servers[formData.name],\n                        connectionStatus: \"failed\" as const,\n                        lastError:\n                          connectionResult.error ||\n                          \"OAuth connection test failed\",\n                      },\n                    },\n                  }));\n                  toast.error(\n                    `OAuth succeeded but connection failed: ${connectionResult.error}`,\n                  );\n                }\n              } catch (error) {\n                const errorMessage =\n                  error instanceof Error ? error.message : \"Unknown error\";\n                setAppState((prev) => ({\n                  ...prev,\n                  servers: {\n                    ...prev.servers,\n                    [formData.name]: {\n                      ...prev.servers[formData.name],\n                      connectionStatus: \"failed\" as const,\n                      lastError: errorMessage,\n                    },\n                  },\n                }));\n                toast.error(\n                  `OAuth succeeded but connection test threw error: ${errorMessage}`,\n                );\n              }\n              return;\n            } else {\n              // Redirect needed - keep oauth-flow status\n              toast.success(\n                \"OAuth flow initiated. You will be redirected to authorize access.\",\n              );\n              return;\n            }\n          } else {\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [formData.name]: {\n                  ...prev.servers[formData.name],\n                  connectionStatus: \"failed\" as const,\n                  retryCount: 0,\n                  lastError: oauthResult.error || \"OAuth initialization failed\",\n                },\n              },\n            }));\n            toast.error(`OAuth initialization failed: ${oauthResult.error}`);\n            return;\n          }\n        }\n\n        // For non-OAuth connections, test connection using the stateless endpoint\n        const response = await fetch(\"/api/mcp/connect\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            serverConfig: mcpConfig,\n          }),\n        });\n\n        const result = await response.json();\n\n        if (result.success) {\n          // Update existing server to connected state\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [formData.name]: {\n                ...prev.servers[formData.name],\n                connectionStatus: \"connected\" as const,\n                lastConnectionTime: new Date(),\n                retryCount: 0,\n                lastError: undefined,\n              },\n            },\n          }));\n          logger.info(\"Connection successful\", {\n            serverName: formData.name,\n          });\n          toast.success(`Connected successfully!`);\n        } else {\n          // Update existing server to failed state\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [formData.name]: {\n                ...prev.servers[formData.name],\n                connectionStatus: \"failed\" as const,\n                retryCount: 0,\n                lastError: result.error,\n              },\n            },\n          }));\n          logger.error(\"Connection failed\", {\n            serverName: formData.name,\n            error: result.error,\n          });\n          toast.error(`Failed to connect to ${formData.name}`);\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n\n        // Update existing server to failed state\n        setAppState((prev) => ({\n          ...prev,\n          servers: {\n            ...prev.servers,\n            [formData.name]: {\n              ...prev.servers[formData.name],\n              connectionStatus: \"failed\" as const,\n              retryCount: 0,\n              lastError: errorMessage,\n            },\n          },\n        }));\n        logger.error(\"Connection failed\", {\n          serverName: formData.name,\n          error: errorMessage,\n        });\n\n        toast.error(`Network error: ${errorMessage}`);\n      }\n    },\n    [convertFormToMCPConfig],\n  );\n\n  const handleOAuthCallbackComplete = useCallback(\n    async (code: string) => {\n      // Clean up URL parameters immediately\n      window.history.replaceState({}, document.title, window.location.pathname);\n\n      try {\n        const result = await handleOAuthCallback(code);\n        console.log(\"OAuth callback result:\", result);\n\n        if (result.success && result.serverConfig && result.serverName) {\n          const serverName = result.serverName;\n\n          // Check if server exists and is in oauth-flow state\n          const existingServer = appState.servers[serverName];\n          if (\n            !existingServer ||\n            existingServer.connectionStatus !== \"oauth-flow\"\n          ) {\n            // Create new server entry if it doesn't exist or wasn't in oauth flow\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  name: serverName,\n                  config: result.serverConfig!,\n                  oauthTokens: getStoredTokens(serverName),\n                  lastConnectionTime: new Date(),\n                  connectionStatus: \"connecting\" as const,\n                  retryCount: 0,\n                },\n              },\n              selectedServer: serverName,\n            }));\n          } else {\n            // Update existing server to connecting with OAuth config\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  ...prev.servers[serverName],\n                  config: result.serverConfig!,\n                  oauthTokens: getStoredTokens(serverName),\n                  connectionStatus: \"connecting\" as const,\n                  lastError: undefined,\n                },\n              },\n              selectedServer: serverName,\n            }));\n          }\n\n          // Test the connection\n          try {\n            const response = await fetch(\"/api/mcp/connect\", {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({\n                serverConfig: result.serverConfig,\n              }),\n            });\n\n            const connectionResult = await response.json();\n\n            if (connectionResult.success) {\n              setAppState((prev) => ({\n                ...prev,\n                servers: {\n                  ...prev.servers,\n                  [serverName]: {\n                    ...prev.servers[serverName],\n                    connectionStatus: \"connected\" as const,\n                    lastConnectionTime: new Date(),\n                    lastError: undefined,\n                  },\n                },\n              }));\n\n              logger.info(\"OAuth connection successful\", { serverName });\n              toast.success(\n                `OAuth connection successful! Connected to ${serverName}.`,\n              );\n            } else {\n              setAppState((prev) => ({\n                ...prev,\n                servers: {\n                  ...prev.servers,\n                  [serverName]: {\n                    ...prev.servers[serverName],\n                    connectionStatus: \"failed\" as const,\n                    lastError:\n                      connectionResult.error ||\n                      \"Connection test failed after OAuth\",\n                  },\n                },\n              }));\n\n              logger.error(\"OAuth connection test failed\", {\n                serverName,\n                error: connectionResult.error,\n              });\n              toast.error(\n                `OAuth succeeded but connection test failed: ${connectionResult.error}`,\n              );\n            }\n          } catch (connectionError) {\n            const errorMessage =\n              connectionError instanceof Error\n                ? connectionError.message\n                : \"Unknown connection error\";\n\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  ...prev.servers[serverName],\n                  connectionStatus: \"failed\" as const,\n                  lastError: errorMessage,\n                },\n              },\n            }));\n\n            logger.error(\"OAuth connection test error\", {\n              serverName,\n              error: errorMessage,\n            });\n            toast.error(\n              `OAuth succeeded but connection test failed: ${errorMessage}`,\n            );\n          }\n        } else {\n          throw new Error(result.error || \"OAuth callback failed\");\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n        toast.error(`Error completing OAuth flow: ${errorMessage}`);\n        logger.error(\"OAuth callback failed\", { error: errorMessage });\n      }\n    },\n    [appState.servers, logger],\n  );\n\n  const getValidAccessToken = useCallback(\n    async (serverName: string): Promise<string | null> => {\n      const server = appState.servers[serverName];\n      if (!server?.oauthTokens) {\n        return null;\n      }\n\n      // The SDK handles token refresh automatically\n      return server.oauthTokens.access_token || null;\n    },\n    [appState.servers],\n  );\n\n  const handleDisconnect = useCallback(async (serverName: string) => {\n    logger.info(\"Disconnecting from server\", { serverName });\n\n    // Clear OAuth data\n    clearOAuthData(serverName);\n\n    // Remove server from state (no API call needed for stateless architecture)\n    setAppState((prev: AppState) => {\n      const newServers = { ...prev.servers };\n      delete newServers[serverName];\n\n      return {\n        ...prev,\n        servers: newServers,\n        selectedServer:\n          prev.selectedServer === serverName ? \"none\" : prev.selectedServer,\n        selectedMultipleServers: prev.selectedMultipleServers.filter(\n          (name) => name !== serverName,\n        ),\n      };\n    });\n  }, []);\n\n  const handleReconnect = useCallback(\n    async (serverName: string) => {\n      logger.info(\"Reconnecting to server\", { serverName });\n\n      const server = appState.servers[serverName];\n      if (!server) {\n        throw new Error(`Server ${serverName} not found`);\n      }\n\n      // Update status to connecting\n      setAppState((prev) => ({\n        ...prev,\n        servers: {\n          ...prev.servers,\n          [serverName]: {\n            ...server,\n            connectionStatus: \"connecting\" as const,\n          },\n        },\n      }));\n\n      try {\n        let serverConfig = server.config;\n\n        // If server has OAuth tokens, try to refresh them\n        if (server.oauthTokens) {\n          logger.info(\"Attempting to refresh OAuth tokens\", { serverName });\n          const refreshResult = await refreshOAuthTokens(serverName);\n\n          if (refreshResult.success && refreshResult.serverConfig) {\n            logger.info(\"OAuth tokens refreshed successfully\", { serverName });\n            serverConfig = refreshResult.serverConfig;\n\n            // Update server state with refreshed config and tokens\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  ...prev.servers[serverName],\n                  config: refreshResult.serverConfig!,\n                  oauthTokens: getStoredTokens(serverName),\n                },\n              },\n            }));\n          } else {\n            logger.warn(\n              \"OAuth token refresh failed, attempting with existing tokens\",\n              {\n                serverName,\n                error: refreshResult.error,\n              },\n            );\n          }\n        }\n\n        // Test connection using the stateless endpoint\n        const response = await fetch(\"/api/mcp/connect\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            serverConfig,\n          }),\n        });\n\n        const result = await response.json();\n\n        if (result.success) {\n          // Update status to connected and reset retry count\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [serverName]: {\n                ...prev.servers[serverName],\n                connectionStatus: \"connected\" as const,\n                lastConnectionTime: new Date(),\n                retryCount: 0,\n                lastError: undefined,\n              },\n            },\n          }));\n          logger.info(\"Reconnection successful\", {\n            serverName,\n            result,\n          });\n          return { success: true };\n        } else {\n          // Update status to failed and increment retry count\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [serverName]: {\n                ...prev.servers[serverName],\n                connectionStatus: \"failed\" as const,\n                retryCount: prev.servers[serverName].retryCount + 1,\n                lastError: result.error || \"Connection test failed\",\n              },\n            },\n          }));\n          logger.error(\"Reconnection failed\", {\n            serverName,\n            result,\n          });\n          toast.error(`Failed to connect: ${serverName}`);\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n\n        // Update status to failed and increment retry count\n        setAppState((prev) => ({\n          ...prev,\n          servers: {\n            ...prev.servers,\n            [serverName]: {\n              ...prev.servers[serverName],\n              connectionStatus: \"failed\" as const,\n              retryCount: prev.servers[serverName].retryCount + 1,\n              lastError: errorMessage,\n            },\n          },\n        }));\n        logger.error(\"Reconnection failed\", {\n          serverName,\n          error: errorMessage,\n        });\n        throw error;\n      }\n    },\n    [appState.servers],\n  );\n\n  // Effect to handle cleanup of reconnection timeouts (automatic retries disabled)\n  useEffect(() => {\n    // Cleanup timeouts for servers that are no longer failed or have been removed\n    Object.keys(reconnectionTimeouts).forEach((serverName) => {\n      const server = appState.servers[serverName];\n      if (!server || server.connectionStatus !== \"failed\") {\n        clearTimeout(reconnectionTimeouts[serverName]);\n        setReconnectionTimeouts((prev) => {\n          const newTimeouts = { ...prev };\n          delete newTimeouts[serverName];\n          return newTimeouts;\n        });\n      }\n    });\n  }, [appState.servers, reconnectionTimeouts]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      Object.values(reconnectionTimeouts).forEach(clearTimeout);\n    };\n  }, [reconnectionTimeouts]);\n\n  const setSelectedServer = useCallback((serverName: string) => {\n    setAppState((prev) => ({\n      ...prev,\n      selectedServer: serverName,\n    }));\n  }, []);\n\n  const setSelectedMCPConfigs = useCallback((serverNames: string[]) => {\n    setAppState((prev) => ({\n      ...prev,\n      selectedMCPConfigs: serverNames,\n    }));\n  }, []);\n\n  const toggleMultiSelectMode = useCallback((enabled: boolean) => {\n    setAppState((prev) => ({\n      ...prev,\n      isMultiSelectMode: enabled,\n      // Reset selections when switching modes\n      selectedMultipleServers: enabled ? [] : prev.selectedMultipleServers,\n    }));\n  }, []);\n\n  const toggleServerSelection = useCallback((serverName: string) => {\n    setAppState((prev) => {\n      const currentSelected = prev.selectedMultipleServers;\n      const isSelected = currentSelected.includes(serverName);\n\n      return {\n        ...prev,\n        selectedMultipleServers: isSelected\n          ? currentSelected.filter((name) => name !== serverName)\n          : [...currentSelected, serverName],\n      };\n    });\n  }, []);\n\n  const handleUpdate = useCallback(\n    async (originalServerName: string, formData: ServerFormData) => {\n      console.log(\"handleUpdateFormData\", formData);\n\n      const originalServer = appState.servers[originalServerName];\n      const hadOAuthTokens = originalServer?.oauthTokens != null;\n\n      // For OAuth servers, preserve the tokens if the server name and URL haven't changed\n      // and the user is still using OAuth authentication\n      const shouldPreserveOAuth =\n        hadOAuthTokens &&\n        formData.useOAuth &&\n        formData.name === originalServerName &&\n        formData.type === \"http\" &&\n        formData.url === originalServer.config.url?.toString();\n\n      if (shouldPreserveOAuth) {\n        // Update server config without disconnecting to preserve OAuth tokens\n        const mcpConfig = convertFormToMCPConfig(formData);\n\n        // Update the server configuration in place\n        setAppState((prev) => ({\n          ...prev,\n          servers: {\n            ...prev.servers,\n            [originalServerName]: {\n              ...prev.servers[originalServerName],\n              config: mcpConfig,\n              connectionStatus: \"connecting\" as const,\n            },\n          },\n        }));\n\n        // Test connection with existing OAuth tokens\n        try {\n          const response = await fetch(\"/api/mcp/connect\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              serverConfig: originalServer.config, // Use original config with OAuth tokens\n            }),\n          });\n\n          const result = await response.json();\n\n          if (result.success) {\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [originalServerName]: {\n                  ...prev.servers[originalServerName],\n                  config: mcpConfig, // Now update to new config\n                  connectionStatus: \"connected\" as const,\n                  lastConnectionTime: new Date(),\n                  retryCount: 0,\n                  lastError: undefined,\n                },\n              },\n            }));\n            toast.success(\"Server configuration updated successfully!\");\n            return;\n          } else {\n            // Connection failed, fall back to full reconnect\n            console.warn(\n              \"OAuth connection test failed, falling back to full reconnect\",\n            );\n          }\n        } catch (error) {\n          console.warn(\n            \"OAuth connection test error, falling back to full reconnect\",\n            error,\n          );\n        }\n      }\n\n      // Full disconnect and reconnect for non-OAuth or when preservation fails\n      // First, disconnect the original server\n      await handleDisconnect(originalServerName);\n\n      // Then connect with the new configuration\n      await handleConnect(formData);\n\n      // If the server name changed, update selected server\n      if (\n        appState.selectedServer === originalServerName &&\n        formData.name !== originalServerName\n      ) {\n        setSelectedServer(formData.name);\n      }\n    },\n    [\n      appState.servers,\n      appState.selectedServer,\n      convertFormToMCPConfig,\n      handleDisconnect,\n      handleConnect,\n      setSelectedServer,\n    ],\n  );\n\n  return {\n    // State\n    appState,\n    isLoading,\n\n    // Computed values\n    connectedServerConfigs: appState.servers,\n    selectedServerEntry: appState.servers[appState.selectedServer],\n    selectedMCPConfig: appState.servers[appState.selectedServer]?.config,\n    selectedMCPConfigs: appState.selectedMultipleServers\n      .map((name) => appState.servers[name])\n      .filter(Boolean),\n    selectedMCPConfigsMap: appState.selectedMultipleServers.reduce(\n      (acc, name) => {\n        if (appState.servers[name]) {\n          acc[name] = appState.servers[name].config;\n        }\n        return acc;\n      },\n      {} as Record<string, MastraMCPServerDefinition>,\n    ),\n    isMultiSelectMode: appState.isMultiSelectMode,\n\n    // Actions\n    handleConnect,\n    handleDisconnect,\n    handleReconnect,\n    handleUpdate,\n    setSelectedServer,\n    setSelectedMCPConfigs,\n    toggleMultiSelectMode,\n    toggleServerSelection,\n    getValidAccessToken,\n    setSelectedMultipleServersToAllServers,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2215, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/server/server-actions.ts"],"sourcesContent":["\"use server\";\n\nimport { cookies } from \"next/headers\";\n\nexport async function getValueFromCookie(\n  key: string,\n): Promise<string | undefined> {\n  const cookieStore = await cookies();\n  return cookieStore.get(key)?.value;\n}\n\nexport async function setValueToCookie(\n  key: string,\n  value: string,\n  options: { path?: string; maxAge?: number } = {},\n): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.set(key, value, {\n    path: options.path ?? \"/\",\n    maxAge: options.maxAge ?? 60 * 60 * 24 * 7, // default: 7 days\n  });\n}\n\nexport async function getPreference<T extends string>(\n  key: string,\n  allowed: readonly T[],\n  fallback: T,\n): Promise<T> {\n  const cookieStore = await cookies();\n  const cookie = cookieStore.get(key);\n  const value = cookie ? cookie.value.trim() : undefined;\n  return allowed.includes(value as T) ? (value as T) : fallback;\n}\n"],"names":[],"mappings":";;;;;;IAWsB,mBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 2226, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/app/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\n\nimport { ServersTab } from \"@/components/ServersTab\";\nimport { ToolsTab } from \"@/components/ToolsTab\";\nimport { ResourcesTab } from \"@/components/ResourcesTab\";\nimport { PromptsTab } from \"@/components/PromptsTab\";\nimport { ChatTab } from \"@/components/ChatTab\";\nimport { SettingsTab } from \"@/components/SettingsTab\";\nimport { TracingTab } from \"@/components/TracingTab\";\nimport { MCPSidebar } from \"@/components/mcp-sidebar\";\nimport { ActiveServerSelector } from \"@/components/ActiveServerSelector\";\nimport {\n  SidebarInset,\n  SidebarProvider,\n  SidebarTrigger,\n} from \"@/components/ui/sidebar\";\nimport { ThemeSwitcher } from \"@/components/sidebar/theme-switcher\";\n// import { AccountSwitcher } from \"@/components/sidebar/account-switcher\";\nimport { useAppState } from \"@/hooks/use-app-state\";\n\n// const users = [\n//   {\n//     id: \"1\",\n//     name: \"MCP Inspector\",\n//     email: \"inspector@example.com\",\n//     avatar: \"/avatars/shadcn.jpg\",\n//     role: \"Inspector\",\n//   },\n// ] as const;\n\nexport default function Home() {\n  const [activeTab, setActiveTab] = useState(\"servers\");\n\n  const {\n    appState,\n    isLoading,\n    connectedServerConfigs,\n    selectedMCPConfig,\n    handleConnect,\n    handleDisconnect,\n    handleReconnect,\n    handleUpdate,\n    setSelectedServer,\n    toggleServerSelection,\n    selectedMCPConfigsMap,\n    setSelectedMultipleServersToAllServers,\n  } = useAppState();\n\n  const handleNavigate = (section: string) => {\n    setActiveTab(section);\n    if (section === \"chat\") {\n      setSelectedMultipleServersToAllServers();\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"min-h-screen bg-background flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto\"></div>\n          <p className=\"mt-4 text-muted-foreground\">Loading...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <SidebarProvider defaultOpen={true}>\n      <MCPSidebar onNavigate={handleNavigate} activeTab={activeTab} />\n      <SidebarInset className=\"flex flex-col\">\n        <header className=\"flex h-12 shrink-0 items-center gap-2 border-b transition-[width,height] ease-linear\">\n          <div className=\"flex w-full items-center justify-between px-4 lg:px-6\">\n            <div className=\"flex items-center gap-1 lg:gap-2\">\n              <SidebarTrigger className=\"-ml-1\" />\n            </div>\n            <div className=\"flex items-center gap-2\">\n              <ThemeSwitcher />\n              {/* <AccountSwitcher users={users} /> */}\n            </div>\n          </div>\n        </header>\n\n        <div className=\"flex-1\">\n          {/* Active Server Selector - Only show on Tools, Resources, and Prompts pages */}\n          {(activeTab === \"tools\" ||\n            activeTab === \"resources\" ||\n            activeTab === \"prompts\" ||\n            activeTab === \"chat\") && (\n            <ActiveServerSelector\n              connectedServerConfigs={connectedServerConfigs}\n              selectedServer={appState.selectedServer}\n              onServerChange={setSelectedServer}\n              onConnect={handleConnect}\n              isMultiSelectEnabled={activeTab === \"chat\"}\n              onMultiServerToggle={toggleServerSelection}\n              selectedMultipleServers={appState.selectedMultipleServers}\n            />\n          )}\n\n          {/* Content Areas */}\n          {activeTab === \"servers\" && (\n            <ServersTab\n              connectedServerConfigs={connectedServerConfigs}\n              onConnect={handleConnect}\n              onDisconnect={handleDisconnect}\n              onReconnect={handleReconnect}\n              onUpdate={handleUpdate}\n            />\n          )}\n\n          {activeTab === \"tools\" && (\n            <ToolsTab serverConfig={selectedMCPConfig} />\n          )}\n\n          {activeTab === \"resources\" && (\n            <ResourcesTab serverConfig={selectedMCPConfig} />\n          )}\n\n          {activeTab === \"prompts\" && (\n            <PromptsTab serverConfig={selectedMCPConfig} />\n          )}\n\n          {activeTab === \"chat\" && (\n            <ChatTab serverConfigs={selectedMCPConfigsMap} />\n          )}\n\n          {activeTab === \"tracing\" && <TracingTab />}\n\n          {activeTab === \"settings\" && <SettingsTab />}\n        </div>\n      </SidebarInset>\n    </SidebarProvider>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA,2EAA2E;AAC3E;AApBA;;;;;;;;;;;;;;;AAgCe,SAAS;IACtB,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAE3C,MAAM,EACJ,QAAQ,EACR,SAAS,EACT,sBAAsB,EACtB,iBAAiB,EACjB,aAAa,EACb,gBAAgB,EAChB,eAAe,EACf,YAAY,EACZ,iBAAiB,EACjB,qBAAqB,EACrB,qBAAqB,EACrB,sCAAsC,EACvC,GAAG,CAAA,GAAA,mIAAA,CAAA,cAAW,AAAD;IAEd,MAAM,iBAAiB,CAAC;QACtB,aAAa;QACb,IAAI,YAAY,QAAQ;YACtB;QACF;IACF;IAEA,IAAI,WAAW;QACb,qBACE,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAI,WAAU;;;;;;kCACf,8OAAC;wBAAE,WAAU;kCAA6B;;;;;;;;;;;;;;;;;IAIlD;IAEA,qBACE,8OAAC,mIAAA,CAAA,kBAAe;QAAC,aAAa;;0BAC5B,8OAAC,oIAAA,CAAA,aAAU;gBAAC,YAAY;gBAAgB,WAAW;;;;;;0BACnD,8OAAC,mIAAA,CAAA,eAAY;gBAAC,WAAU;;kCACtB,8OAAC;wBAAO,WAAU;kCAChB,cAAA,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAI,WAAU;8CACb,cAAA,8OAAC,mIAAA,CAAA,iBAAc;wCAAC,WAAU;;;;;;;;;;;8CAE5B,8OAAC;oCAAI,WAAU;8CACb,cAAA,8OAAC,kJAAA,CAAA,gBAAa;;;;;;;;;;;;;;;;;;;;;kCAMpB,8OAAC;wBAAI,WAAU;;4BAEZ,CAAC,cAAc,WACd,cAAc,eACd,cAAc,aACd,cAAc,MAAM,mBACpB,8OAAC,0IAAA,CAAA,uBAAoB;gCACnB,wBAAwB;gCACxB,gBAAgB,SAAS,cAAc;gCACvC,gBAAgB;gCAChB,WAAW;gCACX,sBAAsB,cAAc;gCACpC,qBAAqB;gCACrB,yBAAyB,SAAS,uBAAuB;;;;;;4BAK5D,cAAc,2BACb,8OAAC,gIAAA,CAAA,aAAU;gCACT,wBAAwB;gCACxB,WAAW;gCACX,cAAc;gCACd,aAAa;gCACb,UAAU;;;;;;4BAIb,cAAc,yBACb,8OAAC,8HAAA,CAAA,WAAQ;gCAAC,cAAc;;;;;;4BAGzB,cAAc,6BACb,8OAAC,kIAAA,CAAA,eAAY;gCAAC,cAAc;;;;;;4BAG7B,cAAc,2BACb,8OAAC,gIAAA,CAAA,aAAU;gCAAC,cAAc;;;;;;4BAG3B,cAAc,wBACb,8OAAC,6HAAA,CAAA,UAAO;gCAAC,eAAe;;;;;;4BAGzB,cAAc,2BAAa,8OAAC,gIAAA,CAAA,aAAU;;;;;4BAEtC,cAAc,4BAAc,8OAAC,iIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;;;;;;;;AAKnD","debugId":null}}]
}