module.exports = {

"[project]/node_modules/@mastra/core/dist/chunk-5YDTZN2X.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/logger/constants.ts
__turbopack_context__.s({
    "ConsoleLogger": ()=>ConsoleLogger,
    "LogLevel": ()=>LogLevel,
    "MastraLogger": ()=>MastraLogger,
    "RegisteredLogger": ()=>RegisteredLogger,
    "createLogger": ()=>createLogger
});
var RegisteredLogger = {
    AGENT: "AGENT",
    AUTH: "AUTH",
    NETWORK: "NETWORK",
    WORKFLOW: "WORKFLOW",
    LLM: "LLM",
    TTS: "TTS",
    VOICE: "VOICE",
    VECTOR: "VECTOR",
    BUNDLER: "BUNDLER",
    DEPLOYER: "DEPLOYER",
    MEMORY: "MEMORY",
    STORAGE: "STORAGE",
    EMBEDDINGS: "EMBEDDINGS",
    MCP_SERVER: "MCP_SERVER"
};
var LogLevel = {
    DEBUG: "debug",
    INFO: "info",
    WARN: "warn",
    ERROR: "error",
    NONE: "silent"
};
// src/logger/logger.ts
var MastraLogger = class {
    name;
    level;
    transports;
    constructor(options = {}){
        this.name = options.name || "Mastra";
        this.level = options.level || LogLevel.ERROR;
        this.transports = new Map(Object.entries(options.transports || {}));
    }
    getTransports() {
        return this.transports;
    }
    trackException(_error) {}
    async getLogs(transportId, params) {
        if (!transportId || !this.transports.has(transportId)) {
            return {
                logs: [],
                total: 0,
                page: params?.page ?? 1,
                perPage: params?.perPage ?? 100,
                hasMore: false
            };
        }
        return this.transports.get(transportId).getLogs(params) ?? {
            logs: [],
            total: 0,
            page: params?.page ?? 1,
            perPage: params?.perPage ?? 100,
            hasMore: false
        };
    }
    async getLogsByRunId({ transportId, runId, fromDate, toDate, logLevel, filters, page, perPage }) {
        if (!transportId || !this.transports.has(transportId) || !runId) {
            return {
                logs: [],
                total: 0,
                page: page ?? 1,
                perPage: perPage ?? 100,
                hasMore: false
            };
        }
        return this.transports.get(transportId).getLogsByRunId({
            runId,
            fromDate,
            toDate,
            logLevel,
            filters,
            page,
            perPage
        }) ?? {
            logs: [],
            total: 0,
            page: page ?? 1,
            perPage: perPage ?? 100,
            hasMore: false
        };
    }
};
// src/logger/default-logger.ts
var createLogger = (options)=>{
    const logger = new ConsoleLogger(options);
    logger.warn(`createLogger is deprecated. Please use "new ConsoleLogger()" from "@mastra/core/logger" instead.`);
    return logger;
};
var ConsoleLogger = class extends MastraLogger {
    constructor(options = {}){
        super(options);
    }
    debug(message, ...args) {
        if (this.level === LogLevel.DEBUG) {
            console.debug(message, ...args);
        }
    }
    info(message, ...args) {
        if (this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
            console.info(message, ...args);
        }
    }
    warn(message, ...args) {
        if (this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
            console.warn(message, ...args);
        }
    }
    error(message, ...args) {
        if (this.level === LogLevel.ERROR || this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
            console.error(message, ...args);
        }
    }
    async getLogs(_transportId, _params) {
        return {
            logs: [],
            total: 0,
            page: _params?.page ?? 1,
            perPage: _params?.perPage ?? 100,
            hasMore: false
        };
    }
    async getLogsByRunId(_args) {
        return {
            logs: [],
            total: 0,
            page: _args.page ?? 1,
            perPage: _args.perPage ?? 100,
            hasMore: false
        };
    }
};
;
}),
"[project]/node_modules/@mastra/core/dist/chunk-5IEKR756.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "MastraBase": ()=>MastraBase
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5YDTZN2X.js [app-route] (ecmascript)");
;
// src/base.ts
var MastraBase = class {
    component = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].LLM;
    logger;
    name;
    telemetry;
    constructor({ component, name }){
        this.component = component || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].LLM;
        this.name = name;
        this.logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ConsoleLogger"]({
            name: `${this.component} - ${this.name}`
        });
    }
    /**
   * Set the logger for the agent
   * @param logger
   */ __setLogger(logger) {
        this.logger = logger;
        if (this.component !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].LLM) {
            this.logger.debug(`Logger updated [component=${this.component}] [name=${this.name}]`);
        }
    }
    /**
   * Set the telemetry for the
   * @param telemetry
   */ __setTelemetry(telemetry) {
        this.telemetry = telemetry;
        if (this.component !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].LLM) {
            this.logger.debug(`Telemetry updated [component=${this.component}] [name=${this.telemetry.name}]`);
        }
    }
    /**
   * Get the telemetry on the vector
   * @returns telemetry
   */ __getTelemetry() {
        return this.telemetry;
    }
    /* 
    get experimental_telemetry config
    */ get experimental_telemetry() {
        return this.telemetry ? {
            // tracer: this.telemetry.tracer,
            tracer: this.telemetry.getBaggageTracer(),
            isEnabled: !!this.telemetry.tracer
        } : void 0;
    }
};
;
}),
"[project]/node_modules/@mastra/core/dist/chunk-6UNGH46J.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/error/index.ts
__turbopack_context__.s({
    "ErrorCategory": ()=>ErrorCategory,
    "ErrorDomain": ()=>ErrorDomain,
    "MastraBaseError": ()=>MastraBaseError,
    "MastraError": ()=>MastraError
});
var ErrorDomain = /* @__PURE__ */ ((ErrorDomain2)=>{
    ErrorDomain2["TOOL"] = "TOOL";
    ErrorDomain2["AGENT"] = "AGENT";
    ErrorDomain2["MCP"] = "MCP";
    ErrorDomain2["AGENT_NETWORK"] = "AGENT_NETWORK";
    ErrorDomain2["MASTRA_SERVER"] = "MASTRA_SERVER";
    ErrorDomain2["MASTRA_TELEMETRY"] = "MASTRA_TELEMETRY";
    ErrorDomain2["MASTRA_WORKFLOW"] = "MASTRA_WORKFLOW";
    ErrorDomain2["MASTRA_VOICE"] = "MASTRA_VOICE";
    ErrorDomain2["MASTRA_VECTOR"] = "MASTRA_VECTOR";
    ErrorDomain2["LLM"] = "LLM";
    ErrorDomain2["EVAL"] = "EVAL";
    ErrorDomain2["A2A"] = "A2A";
    ErrorDomain2["MASTRA_INSTANCE"] = "MASTRA_INSTANCE";
    ErrorDomain2["MASTRA"] = "MASTRA";
    ErrorDomain2["DEPLOYER"] = "DEPLOYER";
    ErrorDomain2["STORAGE"] = "STORAGE";
    return ErrorDomain2;
})(ErrorDomain || {});
var ErrorCategory = /* @__PURE__ */ ((ErrorCategory2)=>{
    ErrorCategory2["UNKNOWN"] = "UNKNOWN";
    ErrorCategory2["USER"] = "USER";
    ErrorCategory2["SYSTEM"] = "SYSTEM";
    ErrorCategory2["THIRD_PARTY"] = "THIRD_PARTY";
    return ErrorCategory2;
})(ErrorCategory || {});
var MastraBaseError = class extends Error {
    id;
    domain;
    category;
    details = {};
    message;
    constructor(errorDefinition, originalError){
        let error;
        if (originalError instanceof Error) {
            error = originalError;
        } else if (originalError) {
            error = new Error(String(originalError));
        }
        const message = errorDefinition.text ?? error?.message ?? "Unknown error";
        super(message, {
            cause: error
        });
        this.id = errorDefinition.id;
        this.domain = errorDefinition.domain;
        this.category = errorDefinition.category;
        this.details = errorDefinition.details ?? {};
        this.message = message;
        Object.setPrototypeOf(this, new.target.prototype);
    }
    /**
   * Returns a structured representation of the error, useful for logging or API responses.
   */ toJSONDetails() {
        return {
            message: this.message,
            domain: this.domain,
            category: this.category,
            details: this.details
        };
    }
    toJSON() {
        return {
            message: this.message,
            details: this.toJSONDetails(),
            code: this.id
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
};
var MastraError = class extends MastraBaseError {
};
;
}),
"[project]/node_modules/@mastra/core/dist/chunk-C4LMN2IR.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/tools/tool.ts
__turbopack_context__.s({
    "Tool": ()=>Tool,
    "createTool": ()=>createTool,
    "isVercelTool": ()=>isVercelTool
});
var Tool = class {
    id;
    description;
    inputSchema;
    outputSchema;
    execute;
    mastra;
    constructor(opts){
        this.id = opts.id;
        this.description = opts.description;
        this.inputSchema = opts.inputSchema;
        this.outputSchema = opts.outputSchema;
        this.execute = opts.execute;
        this.mastra = opts.mastra;
    }
};
function createTool(opts) {
    return new Tool(opts);
}
// src/tools/toolchecks.ts
function isVercelTool(tool) {
    return !!(tool && !(tool instanceof Tool) && "parameters" in tool);
}
;
}),
"[project]/node_modules/@mastra/core/dist/chunk-SGGPJWRQ.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/runtime-context/index.ts
__turbopack_context__.s({
    "RuntimeContext": ()=>RuntimeContext
});
var RuntimeContext = class {
    registry = /* @__PURE__ */ new Map();
    constructor(iterable){
        this.registry = new Map(iterable);
    }
    /**
   * set a value with strict typing if `Values` is a Record and the key exists in it.
   */ set(key, value) {
        this.registry.set(key, value);
    }
    /**
   * Get a value with its type
   */ get(key) {
        return this.registry.get(key);
    }
    /**
   * Check if a key exists in the container
   */ has(key) {
        return this.registry.has(key);
    }
    /**
   * Delete a value by key
   */ delete(key) {
        return this.registry.delete(key);
    }
    /**
   * Clear all values from the container
   */ clear() {
        this.registry.clear();
    }
    /**
   * Get all keys in the container
   */ keys() {
        return this.registry.keys();
    }
    /**
   * Get all values in the container
   */ values() {
        return this.registry.values();
    }
    /**
   * Get all entries in the container
   */ entries() {
        return this.registry.entries();
    }
    /**
   * Get the size of the container
   */ size() {
        return this.registry.size;
    }
    /**
   * Execute a function for each entry in the container
   */ forEach(callbackfn) {
        this.registry.forEach(callbackfn);
    }
};
;
}),
"[project]/node_modules/@mastra/core/dist/chunk-IBKM5CLQ.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "checkEvalStorageFields": ()=>checkEvalStorageFields,
    "createMastraProxy": ()=>createMastraProxy,
    "deepMerge": ()=>deepMerge,
    "delay": ()=>delay,
    "ensureToolProperties": ()=>ensureToolProperties,
    "generateEmptyFromSchema": ()=>generateEmptyFromSchema,
    "isCoreMessage": ()=>isCoreMessage,
    "isUiMessage": ()=>isUiMessage,
    "isZodType": ()=>isZodType,
    "makeCoreTool": ()=>makeCoreTool,
    "maskStreamTags": ()=>maskStreamTags,
    "parseFieldKey": ()=>parseFieldKey,
    "parseSqlIdentifier": ()=>parseSqlIdentifier,
    "resolveSerializedZodOutput": ()=>resolveSerializedZodOutput
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$C4LMN2IR$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-C4LMN2IR.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6UNGH46J$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-6UNGH46J.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5IEKR756$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5IEKR756.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$SGGPJWRQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-SGGPJWRQ.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
var CoreToolBuilder = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5IEKR756$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    originalTool;
    options;
    logType;
    constructor(input){
        super({
            name: "CoreToolBuilder"
        });
        this.originalTool = input.originalTool;
        this.options = input.options;
        this.logType = input.logType;
    }
    // Helper to get parameters based on tool type
    getParameters = ()=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$C4LMN2IR$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(this.originalTool)) {
            return this.originalTool.parameters ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({});
        }
        return this.originalTool.inputSchema ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({});
    };
    getOutputSchema = ()=>{
        if ("outputSchema" in this.originalTool) return this.originalTool.outputSchema;
        return null;
    };
    // For provider-defined tools, we need to include all required properties
    buildProviderTool(tool) {
        if ("type" in tool && tool.type === "provider-defined" && "id" in tool && typeof tool.id === "string" && tool.id.includes(".")) {
            const parameters = this.getParameters();
            const outputSchema = this.getOutputSchema();
            return {
                type: "provider-defined",
                id: tool.id,
                args: "args" in this.originalTool ? this.originalTool.args : {},
                description: tool.description,
                parameters: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertZodSchemaToAISDKSchema"])(parameters),
                ...outputSchema ? {
                    outputSchema: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertZodSchemaToAISDKSchema"])(outputSchema)
                } : {},
                execute: this.originalTool.execute ? this.createExecute(this.originalTool, {
                    ...this.options,
                    description: this.originalTool.description
                }, this.logType) : void 0
            };
        }
        return void 0;
    }
    createLogMessageOptions({ agentName, toolName, type }) {
        if (!agentName) {
            return {
                start: `Executing tool ${toolName}`,
                error: `Failed tool execution`
            };
        }
        const prefix = `[Agent:${agentName}]`;
        const toolType = type === "toolset" ? "toolset" : "tool";
        return {
            start: `${prefix} - Executing ${toolType} ${toolName}`,
            error: `${prefix} - Failed ${toolType} execution`
        };
    }
    createExecute(tool, options, logType) {
        const { logger, mastra: _mastra, memory: _memory, runtimeContext, ...rest } = options;
        const { start, error } = this.createLogMessageOptions({
            agentName: options.agentName,
            toolName: options.name,
            type: logType
        });
        const execFunction = async (args, execOptions)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$C4LMN2IR$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(tool)) {
                return tool?.execute?.(args, execOptions) ?? void 0;
            }
            return tool?.execute?.({
                context: args,
                threadId: options.threadId,
                resourceId: options.resourceId,
                mastra: options.mastra,
                memory: options.memory,
                runId: options.runId,
                runtimeContext: options.runtimeContext ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$SGGPJWRQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RuntimeContext"]()
            }, execOptions) ?? void 0;
        };
        return async (args, execOptions)=>{
            let logger2 = options.logger || this.logger;
            try {
                logger2.debug(start, {
                    ...rest,
                    args
                });
                return await execFunction(args, execOptions);
            } catch (err) {
                const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6UNGH46J$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: "TOOL_EXECUTION_FAILED",
                    domain: "TOOL" /* TOOL */ ,
                    category: "USER" /* USER */ ,
                    details: {
                        error,
                        args,
                        model: rest.model?.modelId ?? ""
                    }
                }, err);
                logger2.trackException(mastraError);
                logger2.error(error, {
                    ...rest,
                    error: mastraError,
                    args
                });
                return mastraError;
            }
        };
    }
    build() {
        const providerTool = this.buildProviderTool(this.originalTool);
        if (providerTool) {
            return providerTool;
        }
        const definition = {
            type: "function",
            description: this.originalTool.description,
            parameters: this.getParameters(),
            outputSchema: this.getOutputSchema(),
            execute: this.originalTool.execute ? this.createExecute(this.originalTool, {
                ...this.options,
                description: this.originalTool.description
            }, this.logType) : void 0
        };
        const model = this.options.model;
        const schemaCompatLayers = [];
        if (model) {
            schemaCompatLayers.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAIReasoningSchemaCompatLayer"](model), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAISchemaCompatLayer"](model), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleSchemaCompatLayer"](model), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnthropicSchemaCompatLayer"](model), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DeepSeekSchemaCompatLayer"](model), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MetaSchemaCompatLayer"](model));
        }
        const processedSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applyCompatLayer"])({
            schema: this.getParameters(),
            compatLayers: schemaCompatLayers,
            mode: "aiSdkSchema"
        });
        let processedOutputSchema;
        if (this.getOutputSchema()) {
            processedOutputSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applyCompatLayer"])({
                schema: this.getOutputSchema(),
                compatLayers: schemaCompatLayers,
                mode: "aiSdkSchema"
            });
        }
        return {
            ...definition,
            parameters: processedSchema,
            outputSchema: processedOutputSchema
        };
    }
};
// src/utils.ts
var delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
function deepMerge(target, source) {
    const output = {
        ...target
    };
    if (!source) return output;
    Object.keys(source).forEach((key)=>{
        const targetValue = output[key];
        const sourceValue = source[key];
        if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
            output[key] = sourceValue;
        } else if (sourceValue instanceof Object && targetValue instanceof Object && !Array.isArray(sourceValue) && !Array.isArray(targetValue)) {
            output[key] = deepMerge(targetValue, sourceValue);
        } else if (sourceValue !== void 0) {
            output[key] = sourceValue;
        }
    });
    return output;
}
function generateEmptyFromSchema(schema) {
    try {
        const parsedSchema = JSON.parse(schema);
        if (!parsedSchema || parsedSchema.type !== "object" || !parsedSchema.properties) return {};
        const obj = {};
        const TYPE_DEFAULTS = {
            string: "",
            array: [],
            object: {},
            number: 0,
            integer: 0,
            boolean: false
        };
        for (const [key, prop] of Object.entries(parsedSchema.properties)){
            obj[key] = TYPE_DEFAULTS[prop.type] ?? null;
        }
        return obj;
    } catch  {
        return {};
    }
}
async function* maskStreamTags(stream, tag, options = {}) {
    const { onStart, onEnd, onMask } = options;
    const openTag = `<${tag}>`;
    const closeTag = `</${tag}>`;
    let buffer = "";
    let fullContent = "";
    let isMasking = false;
    let isBuffering = false;
    const trimOutsideDelimiter = (text, delimiter, trim)=>{
        if (!text.includes(delimiter)) {
            return text;
        }
        const parts = text.split(delimiter);
        if (trim === `before-start`) {
            return `${delimiter}${parts[1]}`;
        }
        return `${parts[0]}${delimiter}`;
    };
    const startsWith = (text, pattern)=>{
        if (pattern.includes(openTag.substring(0, 3))) {
            pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);
        }
        return text.trim().startsWith(pattern.trim());
    };
    for await (const chunk of stream){
        fullContent += chunk;
        if (isBuffering) buffer += chunk;
        const chunkHasTag = startsWith(chunk, openTag);
        const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);
        let toYieldBeforeMaskedStartTag = ``;
        if (!isMasking && (chunkHasTag || bufferHasTag)) {
            isMasking = true;
            isBuffering = false;
            const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);
            if (taggedTextToMask !== buffer.trim()) {
                toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);
            }
            buffer = "";
            onStart?.();
        }
        if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== "") {
            isBuffering = true;
            buffer += chunk;
            continue;
        }
        if (isBuffering && buffer && !startsWith(openTag, buffer)) {
            yield buffer;
            buffer = "";
            isBuffering = false;
            continue;
        }
        if (isMasking && fullContent.includes(closeTag)) {
            onMask?.(chunk);
            onEnd?.();
            isMasking = false;
            const lastFullContent = fullContent;
            fullContent = ``;
            const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, "after-end");
            if (textUntilEndTag !== lastFullContent) {
                yield lastFullContent.replace(textUntilEndTag, ``);
            }
            continue;
        }
        if (isMasking) {
            onMask?.(chunk);
            if (toYieldBeforeMaskedStartTag) {
                yield toYieldBeforeMaskedStartTag;
            }
            continue;
        }
        yield chunk;
    }
}
function resolveSerializedZodOutput(schema) {
    return Function("z", `"use strict";return (${schema});`)(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"]);
}
function isZodType(value) {
    return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function createDeterministicId(input) {
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHash"])("sha256").update(input).digest("hex").slice(0, 8);
}
function setVercelToolProperties(tool) {
    const inputSchema = convertVercelToolParameters(tool);
    const toolId = !("id" in tool) ? tool.description ? `tool-${createDeterministicId(tool.description)}` : `tool-${Math.random().toString(36).substring(2, 9)}` : tool.id;
    return {
        ...tool,
        id: toolId,
        inputSchema
    };
}
function ensureToolProperties(tools) {
    const toolsWithProperties = Object.keys(tools).reduce((acc, key)=>{
        const tool = tools?.[key];
        if (tool) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$C4LMN2IR$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(tool)) {
                acc[key] = setVercelToolProperties(tool);
            } else {
                acc[key] = tool;
            }
        }
        return acc;
    }, {});
    return toolsWithProperties;
}
function convertVercelToolParameters(tool) {
    const schema = tool.parameters ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({});
    return isZodType(schema) ? schema : resolveSerializedZodOutput((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(schema));
}
function makeCoreTool(originalTool, options, logType) {
    return new CoreToolBuilder({
        originalTool,
        options,
        logType
    }).build();
}
function createMastraProxy({ mastra, logger }) {
    return new Proxy(mastra, {
        get (target, prop) {
            const hasProp = Reflect.has(target, prop);
            if (hasProp) {
                const value = Reflect.get(target, prop);
                const isFunction = typeof value === "function";
                if (isFunction) {
                    return value.bind(target);
                }
                return value;
            }
            if (prop === "logger") {
                logger.warn(`Please use 'getLogger' instead, logger is deprecated`);
                return Reflect.apply(target.getLogger, target, []);
            }
            if (prop === "telemetry") {
                logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);
                return Reflect.apply(target.getTelemetry, target, []);
            }
            if (prop === "storage") {
                logger.warn(`Please use 'getStorage' instead, storage is deprecated`);
                return Reflect.get(target, "storage");
            }
            if (prop === "agents") {
                logger.warn(`Please use 'getAgents' instead, agents is deprecated`);
                return Reflect.apply(target.getAgents, target, []);
            }
            if (prop === "tts") {
                logger.warn(`Please use 'getTTS' instead, tts is deprecated`);
                return Reflect.apply(target.getTTS, target, []);
            }
            if (prop === "vectors") {
                logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);
                return Reflect.apply(target.getVectors, target, []);
            }
            if (prop === "memory") {
                logger.warn(`Please use 'getMemory' instead, memory is deprecated`);
                return Reflect.get(target, "memory");
            }
            return Reflect.get(target, prop);
        }
    });
}
function checkEvalStorageFields(traceObject, logger) {
    const missingFields = [];
    if (!traceObject.input) missingFields.push("input");
    if (!traceObject.output) missingFields.push("output");
    if (!traceObject.agentName) missingFields.push("agent_name");
    if (!traceObject.metricName) missingFields.push("metric_name");
    if (!traceObject.instructions) missingFields.push("instructions");
    if (!traceObject.globalRunId) missingFields.push("global_run_id");
    if (!traceObject.runId) missingFields.push("run_id");
    if (missingFields.length > 0) {
        if (logger) {
            logger.warn("Skipping evaluation storage due to missing required fields", {
                missingFields,
                runId: traceObject.runId,
                agentName: traceObject.agentName
            });
        } else {
            console.warn("Skipping evaluation storage due to missing required fields", {
                missingFields,
                runId: traceObject.runId,
                agentName: traceObject.agentName
            });
        }
        return false;
    }
    return true;
}
function detectSingleMessageCharacteristics(message) {
    if (typeof message === "object" && message !== null && (message.role === "function" || // UI-only role
    message.role === "data" || // UI-only role
    "toolInvocations" in message || // UI-specific field
    "parts" in message || // UI-specific field
    "experimental_attachments" in message)) {
        return "has-ui-specific-parts";
    } else if (typeof message === "object" && message !== null && "content" in message && (Array.isArray(message.content) || // Core messages can have array content
    "experimental_providerMetadata" in message || "providerOptions" in message)) {
        return "has-core-specific-parts";
    } else if (typeof message === "object" && message !== null && "role" in message && "content" in message && typeof message.content === "string" && [
        "system",
        "user",
        "assistant",
        "tool"
    ].includes(message.role)) {
        return "message";
    } else {
        return "other";
    }
}
function isUiMessage(message) {
    return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;
}
function isCoreMessage(message) {
    return [
        `has-core-specific-parts`,
        `message`
    ].includes(detectSingleMessageCharacteristics(message));
}
var SQL_IDENTIFIER_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
function parseSqlIdentifier(name, kind = "identifier") {
    if (!SQL_IDENTIFIER_PATTERN.test(name) || name.length > 63) {
        throw new Error(`Invalid ${kind}: ${name}. Must start with a letter or underscore, contain only letters, numbers, or underscores, and be at most 63 characters long.`);
    }
    return name;
}
function parseFieldKey(key) {
    if (!key) throw new Error("Field key cannot be empty");
    const segments = key.split(".");
    for (const segment of segments){
        if (!SQL_IDENTIFIER_PATTERN.test(segment) || segment.length > 63) {
            throw new Error(`Invalid field key segment: ${segment} in ${key}`);
        }
    }
    return key;
}
;
}),
"[project]/node_modules/@mastra/core/dist/mcp/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "MCPServerBase": ()=>MCPServerBase
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5IEKR756$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5IEKR756.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5YDTZN2X.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$slugify$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/slugify/index.js [app-route] (ecmascript)");
;
;
;
;
var MCPServerBase = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5IEKR756$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    /** Tracks if the server ID has been definitively set. */ idWasSet = false;
    /** The display name of the MCP server. */ name;
    /** The semantic version of the MCP server. */ version;
    /** Internal storage for the server's unique ID. */ _id;
    /** A description of what the MCP server does. */ description;
    /** Repository information for the server's source code. */ repository;
    /** The release date of this server version (ISO 8601 string). */ releaseDate;
    /** Indicates if this version is the latest available. */ isLatest;
    /** The canonical packaging format (e.g., "npm", "docker"), if applicable. */ packageCanonical;
    /** Information about installable packages for this server. */ packages;
    /** Information about remote access points for this server. */ remotes;
    /** The tools registered with and converted by this MCP server. */ convertedTools;
    /** Reference to the Mastra instance if this server is registered with one. */ mastra;
    /** Agents to be exposed as tools. */ agents;
    /** Workflows to be exposed as tools. */ workflows;
    /**
   * Public getter for the server's unique ID.
   * The ID is set at construction or by Mastra and is read-only afterwards.
   */ get id() {
        return this._id;
    }
    /**
   * Gets a read-only view of the registered tools.
   * @returns A readonly record of converted tools.
   */ tools() {
        return this.convertedTools;
    }
    /**
   * Sets the server's unique ID. This method is typically called by Mastra when
   * registering the server, using the key provided in the Mastra configuration.
   * It ensures the ID is set only once.
   * If an ID was already provided in the MCPServerConfig, this method will be a no-op.
   * @param id The unique ID to assign to the server.
   */ setId(id) {
        if (this.idWasSet) {
            return;
        }
        this._id = id;
        this.idWasSet = true;
    }
    /**
   * Internal method used by Mastra to register itself with the server.
   * @param mastra The Mastra instance.
   * @internal
   */ __registerMastra(mastra) {
        this.mastra = mastra;
    }
    /**
   * Constructor for the MCPServerBase.
   * @param config Configuration options for the MCP server, including metadata.
   */ constructor(config){
        super({
            component: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5YDTZN2X$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].MCP_SERVER,
            name: config.name
        });
        this.name = config.name;
        this.version = config.version;
        if (config.id) {
            this._id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$slugify$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(config.id);
            this.idWasSet = true;
        } else {
            this._id = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])();
        }
        this.description = config.description;
        this.repository = config.repository;
        this.releaseDate = config.releaseDate || /* @__PURE__ */ new Date().toISOString();
        this.isLatest = config.isLatest === void 0 ? true : config.isLatest;
        this.packageCanonical = config.packageCanonical;
        this.packages = config.packages;
        this.remotes = config.remotes;
        this.agents = config.agents;
        this.workflows = config.workflows;
        this.convertedTools = this.convertTools(config.tools, config.agents, config.workflows);
    }
};
;
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/Types.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
;
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAnyOf.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseAnyOf": ()=>parseAnyOf
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
const parseAnyOf = (schema, refs)=>{
    return schema.anyOf.length ? schema.anyOf.length === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema.anyOf[0], {
        ...refs,
        path: [
            ...refs.path,
            "anyOf",
            0
        ]
    }) : `z.union([${schema.anyOf.map((schema, i)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema, {
            ...refs,
            path: [
                ...refs.path,
                "anyOf",
                i
            ]
        })).join(", ")}])` : `z.any()`;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseBoolean.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseBoolean": ()=>parseBoolean
});
const parseBoolean = (_schema)=>{
    return "z.boolean()";
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseDefault.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseDefault": ()=>parseDefault
});
const parseDefault = (_schema)=>{
    return "z.any()";
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseMultipleType.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseMultipleType": ()=>parseMultipleType
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
const parseMultipleType = (schema, refs)=>{
    return `z.union([${schema.type.map((type)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])({
            ...schema,
            type
        }, {
            ...refs,
            withoutDefaults: true
        })).join(", ")}])`;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNot.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseNot": ()=>parseNot
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
const parseNot = (schema, refs)=>{
    return `z.any().refine((value) => !${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema.not, {
        ...refs,
        path: [
            ...refs.path,
            "not"
        ]
    })}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNull.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseNull": ()=>parseNull
});
const parseNull = (_schema)=>{
    return "z.null()";
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/utils/half.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "half": ()=>half
});
const half = (arr)=>{
    return [
        arr.slice(0, arr.length / 2),
        arr.slice(arr.length / 2)
    ];
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseAllOf": ()=>parseAllOf
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$half$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/half.js [app-route] (ecmascript)");
;
;
const originalIndex = Symbol("Original index");
const ensureOriginalIndex = (arr)=>{
    let newArr = [];
    for(let i = 0; i < arr.length; i++){
        const item = arr[i];
        if (typeof item === "boolean") {
            newArr.push(item ? {
                [originalIndex]: i
            } : {
                [originalIndex]: i,
                not: {}
            });
        } else if (originalIndex in item) {
            return arr;
        } else {
            newArr.push({
                ...item,
                [originalIndex]: i
            });
        }
    }
    return newArr;
};
function parseAllOf(schema, refs) {
    if (schema.allOf.length === 0) {
        return "z.never()";
    } else if (schema.allOf.length === 1) {
        const item = schema.allOf[0];
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(item, {
            ...refs,
            path: [
                ...refs.path,
                "allOf",
                item[originalIndex]
            ]
        });
    } else {
        const [left, right] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$half$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["half"])(ensureOriginalIndex(schema.allOf));
        return `z.intersection(${parseAllOf({
            allOf: left
        }, refs)}, ${parseAllOf({
            allOf: right
        }, refs)})`;
    }
}
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "withMessage": ()=>withMessage
});
function withMessage(schema, key, get) {
    const value = schema[key];
    let r = "";
    if (value !== undefined) {
        const got = get({
            value,
            json: JSON.stringify(value)
        });
        if (got) {
            const opener = got[0];
            const prefix = got.length === 3 ? got[1] : "";
            const closer = got.length === 3 ? got[2] : got[1];
            r += opener;
            if (schema.errorMessage?.[key] !== undefined) {
                r += prefix + JSON.stringify(schema.errorMessage[key]);
            }
            r;
            r += closer;
        }
    }
    return r;
}
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseArray.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseArray": ()=>parseArray
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
;
const parseArray = (schema, refs)=>{
    if (Array.isArray(schema.items)) {
        return `z.tuple([${schema.items.map((v, i)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(v, {
                ...refs,
                path: [
                    ...refs.path,
                    "items",
                    i
                ]
            }))}])`;
    }
    let r = !schema.items ? "z.array(z.any())" : `z.array(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema.items, {
        ...refs,
        path: [
            ...refs.path,
            "items"
        ]
    })})`;
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "minItems", ({ json })=>[
            `.min(${json}`,
            ", ",
            ")"
        ]);
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "maxItems", ({ json })=>[
            `.max(${json}`,
            ", ",
            ")"
        ]);
    return r;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseConst.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseConst": ()=>parseConst
});
const parseConst = (schema)=>{
    return `z.literal(${JSON.stringify(schema.const)})`;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseEnum.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseEnum": ()=>parseEnum
});
const parseEnum = (schema)=>{
    if (schema.enum.length === 0) {
        return "z.never()";
    } else if (schema.enum.length === 1) {
        // union does not work when there is only one element
        return `z.literal(${JSON.stringify(schema.enum[0])})`;
    } else if (schema.enum.every((x)=>typeof x === "string")) {
        return `z.enum([${schema.enum.map((x)=>JSON.stringify(x))}])`;
    } else {
        return `z.union([${schema.enum.map((x)=>`z.literal(${JSON.stringify(x)})`).join(", ")}])`;
    }
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseIfThenElse.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseIfThenElse": ()=>parseIfThenElse
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
const parseIfThenElse = (schema, refs)=>{
    const $if = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema.if, {
        ...refs,
        path: [
            ...refs.path,
            "if"
        ]
    });
    const $then = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema.then, {
        ...refs,
        path: [
            ...refs.path,
            "then"
        ]
    });
    const $else = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema.else, {
        ...refs,
        path: [
            ...refs.path,
            "else"
        ]
    });
    return `z.union([${$then}, ${$else}]).superRefine((value,ctx) => {
  const result = ${$if}.safeParse(value).success
    ? ${$then}.safeParse(value)
    : ${$else}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNumber.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseNumber": ()=>parseNumber
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js [app-route] (ecmascript)");
;
const parseNumber = (schema)=>{
    let r = "z.number()";
    if (schema.type === "integer") {
        r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "type", ()=>[
                ".int(",
                ")"
            ]);
    } else {
        r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "format", ({ value })=>{
            if (value === "int64") {
                return [
                    ".int(",
                    ")"
                ];
            }
        });
    }
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "multipleOf", ({ value, json })=>{
        if (value === 1) {
            if (r.startsWith("z.number().int(")) {
                return;
            }
            return [
                ".int(",
                ")"
            ];
        }
        return [
            `.multipleOf(${json}`,
            ", ",
            ")"
        ];
    });
    if (typeof schema.minimum === "number") {
        if (schema.exclusiveMinimum === true) {
            r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "minimum", ({ json })=>[
                    `.gt(${json}`,
                    ", ",
                    ")"
                ]);
        } else {
            r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "minimum", ({ json })=>[
                    `.gte(${json}`,
                    ", ",
                    ")"
                ]);
        }
    } else if (typeof schema.exclusiveMinimum === "number") {
        r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "exclusiveMinimum", ({ json })=>[
                `.gt(${json}`,
                ", ",
                ")"
            ]);
    }
    if (typeof schema.maximum === "number") {
        if (schema.exclusiveMaximum === true) {
            r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "maximum", ({ json })=>[
                    `.lt(${json}`,
                    ", ",
                    ")"
                ]);
        } else {
            r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "maximum", ({ json })=>[
                    `.lte(${json}`,
                    ", ",
                    ")"
                ]);
        }
    } else if (typeof schema.exclusiveMaximum === "number") {
        r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "exclusiveMaximum", ({ json })=>[
                `.lt(${json}`,
                ", ",
                ")"
            ]);
    }
    return r;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseOneOf.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseOneOf": ()=>parseOneOf
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
const parseOneOf = (schema, refs)=>{
    return schema.oneOf.length ? schema.oneOf.length === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema.oneOf[0], {
        ...refs,
        path: [
            ...refs.path,
            "oneOf",
            0
        ]
    }) : `z.any().superRefine((x, ctx) => {
    const schemas = [${schema.oneOf.map((schema, i)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema, {
            ...refs,
            path: [
                ...refs.path,
                "oneOf",
                i
            ]
        })).join(", ")}];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })` : "z.any()";
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/utils/jsdocs.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addJsdocs": ()=>addJsdocs,
    "expandJsdocs": ()=>expandJsdocs
});
const expandJsdocs = (jsdocs)=>{
    const lines = jsdocs.split("\n");
    const result = lines.length === 1 ? lines[0] : `\n${lines.map((x)=>`* ${x}`).join("\n")}\n`;
    return `/**${result}*/\n`;
};
const addJsdocs = (schema, parsed)=>{
    const description = schema.description;
    if (!description) {
        return parsed;
    }
    return `\n${expandJsdocs(description)}${parsed}`;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseObject.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseObject": ()=>parseObject
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAnyOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAnyOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseOneOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseOneOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAllOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$jsdocs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/jsdocs.js [app-route] (ecmascript)");
;
;
;
;
;
function parseObject(objectSchema, refs) {
    let properties = undefined;
    if (objectSchema.properties) {
        if (!Object.keys(objectSchema.properties).length) {
            properties = "z.object({})";
        } else {
            properties = "z.object({ ";
            properties += Object.keys(objectSchema.properties).map((key)=>{
                const propSchema = objectSchema.properties[key];
                let result = `${JSON.stringify(key)}: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(propSchema, {
                    ...refs,
                    path: [
                        ...refs.path,
                        "properties",
                        key
                    ]
                })}`;
                if (refs.withJsdocs && typeof propSchema === "object") {
                    result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$jsdocs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addJsdocs"])(propSchema, result);
                }
                const hasDefault = typeof propSchema === "object" && propSchema.default !== undefined;
                const required = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : typeof propSchema === "object" && propSchema.required === true;
                const optional = !hasDefault && !required;
                return optional ? `${result}.optional()` : result;
            }).join(", ");
            properties += " })";
        }
    }
    const additionalProperties = objectSchema.additionalProperties !== undefined ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(objectSchema.additionalProperties, {
        ...refs,
        path: [
            ...refs.path,
            "additionalProperties"
        ]
    }) : undefined;
    let patternProperties = undefined;
    if (objectSchema.patternProperties) {
        const parsedPatternProperties = Object.fromEntries(Object.entries(objectSchema.patternProperties).map(([key, value])=>{
            return [
                key,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(value, {
                    ...refs,
                    path: [
                        ...refs.path,
                        "patternProperties",
                        key
                    ]
                })
            ];
        }, {}));
        patternProperties = "";
        if (properties) {
            if (additionalProperties) {
                patternProperties += `.catchall(z.union([${[
                    ...Object.values(parsedPatternProperties),
                    additionalProperties
                ].join(", ")}]))`;
            } else if (Object.keys(parsedPatternProperties).length > 1) {
                patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
            } else {
                patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;
            }
        } else {
            if (additionalProperties) {
                patternProperties += `z.record(z.union([${[
                    ...Object.values(parsedPatternProperties),
                    additionalProperties
                ].join(", ")}]))`;
            } else if (Object.keys(parsedPatternProperties).length > 1) {
                patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
            } else {
                patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;
            }
        }
        patternProperties += ".superRefine((value, ctx) => {\n";
        patternProperties += "for (const key in value) {\n";
        if (additionalProperties) {
            if (objectSchema.properties) {
                patternProperties += `let evaluated = [${Object.keys(objectSchema.properties).map((key)=>JSON.stringify(key)).join(", ")}].includes(key)\n`;
            } else {
                patternProperties += `let evaluated = false\n`;
            }
        }
        for(const key in objectSchema.patternProperties){
            patternProperties += "if (key.match(new RegExp(" + JSON.stringify(key) + "))) {\n";
            if (additionalProperties) {
                patternProperties += "evaluated = true\n";
            }
            patternProperties += "const result = " + parsedPatternProperties[key] + ".safeParse(value[key])\n";
            patternProperties += "if (!result.success) {\n";
            patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })\n`;
            patternProperties += "}\n";
            patternProperties += "}\n";
        }
        if (additionalProperties) {
            patternProperties += "if (!evaluated) {\n";
            patternProperties += "const result = " + additionalProperties + ".safeParse(value[key])\n";
            patternProperties += "if (!result.success) {\n";
            patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })\n`;
            patternProperties += "}\n";
            patternProperties += "}\n";
        }
        patternProperties += "}\n";
        patternProperties += "})";
    }
    let output = properties ? patternProperties ? properties + patternProperties : additionalProperties ? additionalProperties === "z.never()" ? properties + ".strict()" : properties + `.catchall(${additionalProperties})` : properties : patternProperties ? patternProperties : additionalProperties ? `z.record(${additionalProperties})` : "z.record(z.any())";
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["its"].an.anyOf(objectSchema)) {
        output += `.and(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAnyOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseAnyOf"])({
            ...objectSchema,
            anyOf: objectSchema.anyOf.map((x)=>typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? {
                    ...x,
                    type: "object"
                } : x)
        }, refs)})`;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["its"].a.oneOf(objectSchema)) {
        output += `.and(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseOneOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseOneOf"])({
            ...objectSchema,
            oneOf: objectSchema.oneOf.map((x)=>typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? {
                    ...x,
                    type: "object"
                } : x)
        }, refs)})`;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["its"].an.allOf(objectSchema)) {
        output += `.and(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAllOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseAllOf"])({
            ...objectSchema,
            allOf: objectSchema.allOf.map((x)=>typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? {
                    ...x,
                    type: "object"
                } : x)
        }, refs)})`;
    }
    return output;
}
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseString.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseString": ()=>parseString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
;
const parseString = (schema)=>{
    let r = "z.string()";
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "format", ({ value })=>{
        switch(value){
            case "email":
                return [
                    ".email(",
                    ")"
                ];
            case "ip":
                return [
                    ".ip(",
                    ")"
                ];
            case "ipv4":
                return [
                    '.ip({ version: "v4"',
                    ", message: ",
                    " })"
                ];
            case "ipv6":
                return [
                    '.ip({ version: "v6"',
                    ", message: ",
                    " })"
                ];
            case "uri":
                return [
                    ".url(",
                    ")"
                ];
            case "uuid":
                return [
                    ".uuid(",
                    ")"
                ];
            case "date-time":
                return [
                    ".datetime({ offset: true",
                    ", message: ",
                    " })"
                ];
            case "time":
                return [
                    ".time(",
                    ")"
                ];
            case "date":
                return [
                    ".date(",
                    ")"
                ];
            case "binary":
                return [
                    ".base64(",
                    ")"
                ];
            case "duration":
                return [
                    ".duration(",
                    ")"
                ];
        }
    });
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "pattern", ({ json })=>[
            `.regex(new RegExp(${json})`,
            ", ",
            ")"
        ]);
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "minLength", ({ json })=>[
            `.min(${json}`,
            ", ",
            ")"
        ]);
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "maxLength", ({ json })=>[
            `.max(${json}`,
            ", ",
            ")"
        ]);
    r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "contentEncoding", ({ value })=>{
        if (value === "base64") {
            return [
                ".base64(",
                ")"
            ];
        }
    });
    const contentMediaType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "contentMediaType", ({ value })=>{
        if (value === "application/json") {
            return [
                ".transform((str, ctx) => { try { return JSON.parse(str); } catch (err) { ctx.addIssue({ code: \"custom\", message: \"Invalid JSON\" }); }}",
                ", ",
                ")"
            ];
        }
    });
    if (contentMediaType != "") {
        r += contentMediaType;
        r += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withMessage"])(schema, "contentSchema", ({ value })=>{
            if (value && value instanceof Object) {
                return [
                    `.pipe(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(value)}`,
                    ", ",
                    ")"
                ];
            }
        });
    }
    return r;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/utils/omit.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "omit": ()=>omit
});
const omit = (obj, ...keys)=>Object.keys(obj).reduce((acc, key)=>{
        if (!keys.includes(key)) {
            acc[key] = obj[key];
        }
        return acc;
    }, {});
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNullable.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseNullable": ()=>parseNullable
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$omit$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/omit.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
;
;
const parseNullable = (schema, refs)=>{
    return `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$omit$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["omit"])(schema, "nullable"), refs, true)}.nullable()`;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "its": ()=>its,
    "parseSchema": ()=>parseSchema
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAnyOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAnyOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseBoolean$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseBoolean.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseDefault$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseDefault.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseMultipleType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseMultipleType.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNot.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNull$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNull.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAllOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseArray.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseConst$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseConst.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseEnum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseEnum.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseIfThenElse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseIfThenElse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNumber.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseObject.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseString.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseOneOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseOneOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNullable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNullable.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const parseSchema = (schema, refs = {
    seen: new Map(),
    path: []
}, blockMeta)=>{
    if (typeof schema !== "object") return schema ? "z.any()" : "z.never()";
    if (refs.parserOverride) {
        const custom = refs.parserOverride(schema, refs);
        if (typeof custom === "string") {
            return custom;
        }
    }
    let seen = refs.seen.get(schema);
    if (seen) {
        if (seen.r !== undefined) {
            return seen.r;
        }
        if (refs.depth === undefined || seen.n >= refs.depth) {
            return "z.any()";
        }
        seen.n += 1;
    } else {
        seen = {
            r: undefined,
            n: 0
        };
        refs.seen.set(schema, seen);
    }
    let parsed = selectParser(schema, refs);
    if (!blockMeta) {
        if (!refs.withoutDescribes) {
            parsed = addDescribes(schema, parsed);
        }
        if (!refs.withoutDefaults) {
            parsed = addDefaults(schema, parsed);
        }
        parsed = addAnnotations(schema, parsed);
    }
    seen.r = parsed;
    return parsed;
};
const addDescribes = (schema, parsed)=>{
    if (schema.description) {
        parsed += `.describe(${JSON.stringify(schema.description)})`;
    }
    return parsed;
};
const addDefaults = (schema, parsed)=>{
    if (schema.default !== undefined) {
        parsed += `.default(${JSON.stringify(schema.default)})`;
    }
    return parsed;
};
const addAnnotations = (schema, parsed)=>{
    if (schema.readOnly) {
        parsed += ".readonly()";
    }
    return parsed;
};
const selectParser = (schema, refs)=>{
    if (its.a.nullable(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNullable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseNullable"])(schema, refs);
    } else if (its.an.object(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseObject"])(schema, refs);
    } else if (its.an.array(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseArray"])(schema, refs);
    } else if (its.an.anyOf(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAnyOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseAnyOf"])(schema, refs);
    } else if (its.an.allOf(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAllOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseAllOf"])(schema, refs);
    } else if (its.a.oneOf(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseOneOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseOneOf"])(schema, refs);
    } else if (its.a.not(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseNot"])(schema, refs);
    } else if (its.an.enum(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseEnum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseEnum"])(schema); //<-- needs to come before primitives
    } else if (its.a.const(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseConst$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseConst"])(schema);
    } else if (its.a.multipleType(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseMultipleType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseMultipleType"])(schema, refs);
    } else if (its.a.primitive(schema, "string")) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseString"])(schema);
    } else if (its.a.primitive(schema, "number") || its.a.primitive(schema, "integer")) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseNumber"])(schema);
    } else if (its.a.primitive(schema, "boolean")) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseBoolean$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseBoolean"])(schema);
    } else if (its.a.primitive(schema, "null")) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNull$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseNull"])(schema);
    } else if (its.a.conditional(schema)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseIfThenElse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseIfThenElse"])(schema, refs);
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseDefault$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseDefault"])(schema);
    }
};
const its = {
    an: {
        object: (x)=>x.type === "object",
        array: (x)=>x.type === "array",
        anyOf: (x)=>x.anyOf !== undefined,
        allOf: (x)=>x.allOf !== undefined,
        enum: (x)=>x.enum !== undefined
    },
    a: {
        nullable: (x)=>x.nullable === true,
        multipleType: (x)=>Array.isArray(x.type),
        not: (x)=>x.not !== undefined,
        const: (x)=>x.const !== undefined,
        primitive: (x, p)=>x.type === p,
        conditional: (x)=>Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else),
        oneOf: (x)=>x.oneOf !== undefined
    }
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/jsonSchemaToZod.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "jsonSchemaToZod": ()=>jsonSchemaToZod
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$jsdocs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/jsdocs.js [app-route] (ecmascript)");
;
;
const jsonSchemaToZod = (schema, { module, name, type, noImport, ...rest } = {})=>{
    if (type && (!name || module !== "esm")) {
        throw new Error("Option `type` requires `name` to be set and `module` to be `esm`");
    }
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSchema"])(schema, {
        module,
        name,
        path: [],
        seen: new Map(),
        ...rest
    });
    const jsdocs = rest.withJsdocs && typeof schema !== "boolean" && schema.description ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$jsdocs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["expandJsdocs"])(schema.description) : "";
    if (module === "cjs") {
        result = `${jsdocs}module.exports = ${name ? `{ ${JSON.stringify(name)}: ${result} }` : result}
`;
        if (!noImport) {
            result = `${jsdocs}const { z } = require("zod")

${result}`;
        }
    } else if (module === "esm") {
        result = `${jsdocs}export ${name ? `const ${name} =` : `default`} ${result}
`;
        if (!noImport) {
            result = `import { z } from "zod"

${result}`;
        }
    } else if (name) {
        result = `${jsdocs}const ${name} = ${result}`;
    }
    if (type && name) {
        let typeName = typeof type === "string" ? type : `${name[0].toUpperCase()}${name.substring(1)}`;
        result += `export type ${typeName} = z.infer<typeof ${name}>
`;
    }
    return result;
};
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$Types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/Types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$jsonSchemaToZod$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/jsonSchemaToZod.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAllOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAnyOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAnyOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseArray.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseBoolean$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseBoolean.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseConst$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseConst.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseDefault$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseDefault.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseEnum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseEnum.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseIfThenElse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseIfThenElse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseMultipleType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseMultipleType.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNot.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNull$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNull.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNullable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNullable.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNumber.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseObject.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseOneOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseOneOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseString.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$half$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/half.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$jsdocs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/jsdocs.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$omit$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/omit.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$jsonSchemaToZod$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonSchemaToZod"];
}),
"[project]/node_modules/json-schema-to-zod/dist/esm/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$Types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/Types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$jsonSchemaToZod$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/jsonSchemaToZod.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAllOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAllOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseAnyOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseAnyOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseArray.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseBoolean$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseBoolean.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseConst$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseConst.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseDefault$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseDefault.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseEnum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseEnum.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseIfThenElse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseIfThenElse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseMultipleType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseMultipleType.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNot$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNot.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNull$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNull.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNullable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNullable.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseNumber.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseObject.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseOneOf$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseOneOf.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseSchema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$parsers$2f$parseString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/parsers/parseString.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$half$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/half.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$jsdocs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/jsdocs.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$omit$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/omit.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$utils$2f$withMessage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/utils/withMessage.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$schema$2d$to$2d$zod$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/json-schema-to-zod/dist/esm/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@ai-sdk/provider/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/errors/ai-sdk-error.ts
__turbopack_context__.s({
    "AISDKError": ()=>AISDKError,
    "APICallError": ()=>APICallError,
    "EmptyResponseBodyError": ()=>EmptyResponseBodyError,
    "InvalidArgumentError": ()=>InvalidArgumentError,
    "InvalidPromptError": ()=>InvalidPromptError,
    "InvalidResponseDataError": ()=>InvalidResponseDataError,
    "JSONParseError": ()=>JSONParseError,
    "LoadAPIKeyError": ()=>LoadAPIKeyError,
    "LoadSettingError": ()=>LoadSettingError,
    "NoContentGeneratedError": ()=>NoContentGeneratedError,
    "NoSuchModelError": ()=>NoSuchModelError,
    "TooManyEmbeddingValuesForCallError": ()=>TooManyEmbeddingValuesForCallError,
    "TypeValidationError": ()=>TypeValidationError,
    "UnsupportedFunctionalityError": ()=>UnsupportedFunctionalityError,
    "getErrorMessage": ()=>getErrorMessage,
    "isJSONArray": ()=>isJSONArray,
    "isJSONObject": ()=>isJSONObject,
    "isJSONValue": ()=>isJSONValue
});
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError extends Error {
    /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */ constructor({ name: name14, message, cause }){
        super(message);
        this[_a] = true;
        this.name = name14;
        this.cause = cause;
    }
    /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */ static isInstance(error) {
        return _AISDKError.hasMarker(error, marker);
    }
    static hasMarker(error, marker15) {
        const markerSymbol = Symbol.for(marker15);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
};
_a = symbol;
var AISDKError = _AISDKError;
// src/errors/api-call-error.ts
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500), // server error
    data }){
        super({
            name,
            message,
            cause
        });
        this[_a2] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker2);
    }
};
_a2 = symbol2;
// src/errors/empty-response-body-error.ts
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var EmptyResponseBodyError = class extends AISDKError {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}){
        super({
            name: name2,
            message
        });
        this[_a3] = true;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker3);
    }
};
_a3 = symbol3;
// src/errors/get-error-message.ts
function getErrorMessage(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
// src/errors/invalid-argument-error.ts
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
    constructor({ message, cause, argument }){
        super({
            name: name3,
            message,
            cause
        });
        this[_a4] = true;
        this.argument = argument;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker4);
    }
};
_a4 = symbol4;
// src/errors/invalid-prompt-error.ts
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var InvalidPromptError = class extends AISDKError {
    constructor({ prompt, message, cause }){
        super({
            name: name4,
            message: `Invalid prompt: ${message}`,
            cause
        });
        this[_a5] = true;
        this.prompt = prompt;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker5);
    }
};
_a5 = symbol5;
// src/errors/invalid-response-data-error.ts
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
var InvalidResponseDataError = class extends AISDKError {
    constructor({ data, message = `Invalid response data: ${JSON.stringify(data)}.` }){
        super({
            name: name5,
            message
        });
        this[_a6] = true;
        this.data = data;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker6);
    }
};
_a6 = symbol6;
// src/errors/json-parse-error.ts
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
    constructor({ text, cause }){
        super({
            name: name6,
            message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a7] = true;
        this.text = text;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker7);
    }
};
_a7 = symbol7;
// src/errors/load-api-key-error.ts
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var LoadAPIKeyError = class extends AISDKError {
    // used in isInstance
    constructor({ message }){
        super({
            name: name7,
            message
        });
        this[_a8] = true;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker8);
    }
};
_a8 = symbol8;
// src/errors/load-setting-error.ts
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var LoadSettingError = class extends AISDKError {
    // used in isInstance
    constructor({ message }){
        super({
            name: name8,
            message
        });
        this[_a9] = true;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker9);
    }
};
_a9 = symbol9;
// src/errors/no-content-generated-error.ts
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
var NoContentGeneratedError = class extends AISDKError {
    // used in isInstance
    constructor({ message = "No content generated." } = {}){
        super({
            name: name9,
            message
        });
        this[_a10] = true;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker10);
    }
};
_a10 = symbol10;
// src/errors/no-such-model-error.ts
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var NoSuchModelError = class extends AISDKError {
    constructor({ errorName = name10, modelId, modelType, message = `No such ${modelType}: ${modelId}` }){
        super({
            name: errorName,
            message
        });
        this[_a11] = true;
        this.modelId = modelId;
        this.modelType = modelType;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker11);
    }
};
_a11 = symbol11;
// src/errors/too-many-embedding-values-for-call-error.ts
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
var TooManyEmbeddingValuesForCallError = class extends AISDKError {
    constructor(options){
        super({
            name: name11,
            message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
        });
        this[_a12] = true;
        this.provider = options.provider;
        this.modelId = options.modelId;
        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
        this.values = options.values;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker12);
    }
};
_a12 = symbol12;
// src/errors/type-validation-error.ts
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError extends AISDKError {
    constructor({ value, cause }){
        super({
            name: name12,
            message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a13] = true;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker13);
    }
    /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */ static wrap({ value, cause }) {
        return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({
            value,
            cause
        });
    }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
// src/errors/unsupported-functionality-error.ts
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var UnsupportedFunctionalityError = class extends AISDKError {
    constructor({ functionality, message = `'${functionality}' functionality not supported.` }){
        super({
            name: name13,
            message
        });
        this[_a14] = true;
        this.functionality = functionality;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker14);
    }
};
_a14 = symbol14;
// src/json-value/is-json.ts
function isJSONValue(value) {
    if (value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return true;
    }
    if (Array.isArray(value)) {
        return value.every(isJSONValue);
    }
    if (typeof value === "object") {
        return Object.entries(value).every(([key, val])=>typeof key === "string" && isJSONValue(val));
    }
    return false;
}
function isJSONArray(value) {
    return Array.isArray(value) && value.every(isJSONValue);
}
function isJSONObject(value) {
    return value != null && typeof value === "object" && Object.entries(value).every(([key, val])=>typeof key === "string" && isJSONValue(val));
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/nanoid/non-secure/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "customAlphabet": ()=>customAlphabet,
    "nanoid": ()=>nanoid
});
let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
let customAlphabet = (alphabet, defaultSize = 21)=>{
    return (size = defaultSize)=>{
        let id = '';
        let i = size | 0;
        while(i--){
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
let nanoid = (size = 21)=>{
    let id = '';
    let i = size | 0;
    while(i--){
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};
;
}),
"[project]/node_modules/secure-json-parse/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const hasBuffer = typeof Buffer !== 'undefined';
const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function _parse(text, reviver, options) {
    // Normalize arguments
    if (options == null) {
        if (reviver !== null && typeof reviver === 'object') {
            options = reviver;
            reviver = undefined;
        }
    }
    if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
    }
    // BOM checker
    if (text && text.charCodeAt(0) === 0xFEFF) {
        text = text.slice(1);
    }
    // Parse normally, allowing exceptions
    const obj = JSON.parse(text, reviver);
    // Ignore null and non-objects
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    const protoAction = options && options.protoAction || 'error';
    const constructorAction = options && options.constructorAction || 'error';
    // options: 'error' (default) / 'remove' / 'ignore'
    if (protoAction === 'ignore' && constructorAction === 'ignore') {
        return obj;
    }
    if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
            return obj;
        }
    } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {
        if (suspectProtoRx.test(text) === false) {
            return obj;
        }
    } else {
        if (suspectConstructorRx.test(text) === false) {
            return obj;
        }
    }
    // Scan result for proto keys
    return filter(obj, {
        protoAction,
        constructorAction,
        safe: options && options.safe
    });
}
function filter(obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
    let next = [
        obj
    ];
    while(next.length){
        const nodes = next;
        next = [];
        for (const node of nodes){
            if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) {
                if (safe === true) {
                    return null;
                } else if (protoAction === 'error') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }
                delete node.__proto__; // eslint-disable-line no-proto
            }
            if (constructorAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, 'constructor') && Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) {
                if (safe === true) {
                    return null;
                } else if (constructorAction === 'error') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }
                delete node.constructor;
            }
            for(const key in node){
                const value = node[key];
                if (value && typeof value === 'object') {
                    next.push(value);
                }
            }
        }
    }
    return obj;
}
function parse(text, reviver, options) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
        return _parse(text, reviver, options);
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
function safeParse(text, reviver) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
        return _parse(text, reviver, {
            safe: true
        });
    } catch (_e) {
        return null;
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
module.exports = parse;
module.exports.default = parse;
module.exports.parse = parse;
module.exports.safeParse = safeParse;
module.exports.scan = filter;
}}),
"[project]/node_modules/@ai-sdk/provider-utils/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/combine-headers.ts
__turbopack_context__.s({
    "asValidator": ()=>asValidator,
    "combineHeaders": ()=>combineHeaders,
    "convertAsyncIteratorToReadableStream": ()=>convertAsyncIteratorToReadableStream,
    "convertBase64ToUint8Array": ()=>convertBase64ToUint8Array,
    "convertUint8ArrayToBase64": ()=>convertUint8ArrayToBase64,
    "createBinaryResponseHandler": ()=>createBinaryResponseHandler,
    "createEventSourceParserStream": ()=>createEventSourceParserStream,
    "createEventSourceResponseHandler": ()=>createEventSourceResponseHandler,
    "createIdGenerator": ()=>createIdGenerator,
    "createJsonErrorResponseHandler": ()=>createJsonErrorResponseHandler,
    "createJsonResponseHandler": ()=>createJsonResponseHandler,
    "createJsonStreamResponseHandler": ()=>createJsonStreamResponseHandler,
    "createStatusCodeErrorResponseHandler": ()=>createStatusCodeErrorResponseHandler,
    "delay": ()=>delay,
    "extractResponseHeaders": ()=>extractResponseHeaders,
    "generateId": ()=>generateId,
    "getErrorMessage": ()=>getErrorMessage,
    "getFromApi": ()=>getFromApi,
    "isAbortError": ()=>isAbortError,
    "isParsableJson": ()=>isParsableJson,
    "isValidator": ()=>isValidator,
    "loadApiKey": ()=>loadApiKey,
    "loadOptionalSetting": ()=>loadOptionalSetting,
    "loadSetting": ()=>loadSetting,
    "parseJSON": ()=>parseJSON,
    "parseProviderOptions": ()=>parseProviderOptions,
    "postFormDataToApi": ()=>postFormDataToApi,
    "postJsonToApi": ()=>postJsonToApi,
    "postToApi": ()=>postToApi,
    "removeUndefinedEntries": ()=>removeUndefinedEntries,
    "resolve": ()=>resolve,
    "safeParseJSON": ()=>safeParseJSON,
    "safeValidateTypes": ()=>safeValidateTypes,
    "validateTypes": ()=>validateTypes,
    "validator": ()=>validator,
    "validatorSymbol": ()=>validatorSymbol,
    "withoutTrailingSlash": ()=>withoutTrailingSlash,
    "zodValidator": ()=>zodValidator
});
// src/generate-id.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/provider/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$non$2d$secure$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/nanoid/non-secure/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$secure$2d$json$2d$parse$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/secure-json-parse/index.js [app-route] (ecmascript)");
function combineHeaders(...headers) {
    return headers.reduce((combinedHeaders, currentHeaders)=>({
            ...combinedHeaders,
            ...currentHeaders != null ? currentHeaders : {}
        }), {});
}
// src/convert-async-iterator-to-readable-stream.ts
function convertAsyncIteratorToReadableStream(iterator) {
    return new ReadableStream({
        /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */ async pull (controller) {
            try {
                const { value, done } = await iterator.next();
                if (done) {
                    controller.close();
                } else {
                    controller.enqueue(value);
                }
            } catch (error) {
                controller.error(error);
            }
        },
        /**
     * Called when the consumer cancels the stream.
     */ cancel () {}
    });
}
// src/delay.ts
async function delay(delayInMs) {
    return delayInMs == null ? Promise.resolve() : new Promise((resolve2)=>setTimeout(resolve2, delayInMs));
}
// src/event-source-parser-stream.ts
function createEventSourceParserStream() {
    let buffer = "";
    let event = void 0;
    let data = [];
    let lastEventId = void 0;
    let retry = void 0;
    function parseLine(line, controller) {
        if (line === "") {
            dispatchEvent(controller);
            return;
        }
        if (line.startsWith(":")) {
            return;
        }
        const colonIndex = line.indexOf(":");
        if (colonIndex === -1) {
            handleField(line, "");
            return;
        }
        const field = line.slice(0, colonIndex);
        const valueStart = colonIndex + 1;
        const value = valueStart < line.length && line[valueStart] === " " ? line.slice(valueStart + 1) : line.slice(valueStart);
        handleField(field, value);
    }
    function dispatchEvent(controller) {
        if (data.length > 0) {
            controller.enqueue({
                event,
                data: data.join("\n"),
                id: lastEventId,
                retry
            });
            data = [];
            event = void 0;
            retry = void 0;
        }
    }
    function handleField(field, value) {
        switch(field){
            case "event":
                event = value;
                break;
            case "data":
                data.push(value);
                break;
            case "id":
                lastEventId = value;
                break;
            case "retry":
                const parsedRetry = parseInt(value, 10);
                if (!isNaN(parsedRetry)) {
                    retry = parsedRetry;
                }
                break;
        }
    }
    return new TransformStream({
        transform (chunk, controller) {
            const { lines, incompleteLine } = splitLines(buffer, chunk);
            buffer = incompleteLine;
            for(let i = 0; i < lines.length; i++){
                parseLine(lines[i], controller);
            }
        },
        flush (controller) {
            parseLine(buffer, controller);
            dispatchEvent(controller);
        }
    });
}
function splitLines(buffer, chunk) {
    const lines = [];
    let currentLine = buffer;
    for(let i = 0; i < chunk.length;){
        const char = chunk[i++];
        if (char === "\n") {
            lines.push(currentLine);
            currentLine = "";
        } else if (char === "\r") {
            lines.push(currentLine);
            currentLine = "";
            if (chunk[i] === "\n") {
                i++;
            }
        } else {
            currentLine += char;
        }
    }
    return {
        lines,
        incompleteLine: currentLine
    };
}
// src/extract-response-headers.ts
function extractResponseHeaders(response) {
    const headers = {};
    response.headers.forEach((value, key)=>{
        headers[key] = value;
    });
    return headers;
}
;
;
var createIdGenerator = ({ prefix, size: defaultSize = 16, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", separator = "-" } = {})=>{
    const generator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$non$2d$secure$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["customAlphabet"])(alphabet, defaultSize);
    if (prefix == null) {
        return generator;
    }
    if (alphabet.includes(separator)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InvalidArgumentError"]({
            argument: "separator",
            message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
    }
    return (size)=>`${prefix}${separator}${generator(size)}`;
};
var generateId = createIdGenerator();
// src/get-error-message.ts
function getErrorMessage(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
;
// src/remove-undefined-entries.ts
function removeUndefinedEntries(record) {
    return Object.fromEntries(Object.entries(record).filter(([_key, value])=>value != null));
}
// src/is-abort-error.ts
function isAbortError(error) {
    return error instanceof Error && (error.name === "AbortError" || error.name === "TimeoutError");
}
// src/get-from-api.ts
var getOriginalFetch = ()=>globalThis.fetch;
var getFromApi = async ({ url, headers = {}, successfulResponseHandler, failedResponseHandler, abortSignal, fetch = getOriginalFetch() })=>{
    try {
        const response = await fetch(url, {
            method: "GET",
            headers: removeUndefinedEntries(headers),
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: {}
                });
            } catch (error) {
                if (isAbortError(error) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"].isInstance(error)) {
                    throw error;
                }
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: {}
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: {}
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError(error) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"].isInstance(error)) {
                    throw error;
                }
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: {}
            });
        }
    } catch (error) {
        if (isAbortError(error)) {
            throw error;
        }
        if (error instanceof TypeError && error.message === "fetch failed") {
            const cause = error.cause;
            if (cause != null) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                    message: `Cannot connect to API: ${cause.message}`,
                    cause,
                    url,
                    isRetryable: true,
                    requestBodyValues: {}
                });
            }
        }
        throw error;
    }
};
;
function loadApiKey({ apiKey, environmentVariableName, apiKeyParameterName = "apiKey", description }) {
    if (typeof apiKey === "string") {
        return apiKey;
    }
    if (apiKey != null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadAPIKeyError"]({
            message: `${description} API key must be a string.`
        });
    }
    if (typeof process === "undefined") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadAPIKeyError"]({
            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
        });
    }
    apiKey = process.env[environmentVariableName];
    if (apiKey == null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadAPIKeyError"]({
            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
        });
    }
    if (typeof apiKey !== "string") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadAPIKeyError"]({
            message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
        });
    }
    return apiKey;
}
// src/load-optional-setting.ts
function loadOptionalSetting({ settingValue, environmentVariableName }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
        return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
        return void 0;
    }
    return settingValue;
}
;
function loadSetting({ settingValue, environmentVariableName, settingName, description }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadSettingError"]({
            message: `${description} setting must be a string.`
        });
    }
    if (typeof process === "undefined") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadSettingError"]({
            message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`
        });
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadSettingError"]({
            message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`
        });
    }
    if (typeof settingValue !== "string") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoadSettingError"]({
            message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
        });
    }
    return settingValue;
}
;
;
;
// src/validator.ts
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
    return {
        [validatorSymbol]: true,
        validate
    };
}
function isValidator(value) {
    return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
    return isValidator(value) ? value : zodValidator(value);
}
function zodValidator(zodSchema) {
    return validator((value)=>{
        const result = zodSchema.safeParse(value);
        return result.success ? {
            success: true,
            value: result.data
        } : {
            success: false,
            error: result.error
        };
    });
}
// src/validate-types.ts
function validateTypes({ value, schema: inputSchema }) {
    const result = safeValidateTypes({
        value,
        schema: inputSchema
    });
    if (!result.success) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TypeValidationError"].wrap({
            value,
            cause: result.error
        });
    }
    return result.value;
}
function safeValidateTypes({ value, schema }) {
    const validator2 = asValidator(schema);
    try {
        if (validator2.validate == null) {
            return {
                success: true,
                value
            };
        }
        const result = validator2.validate(value);
        if (result.success) {
            return result;
        }
        return {
            success: false,
            error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TypeValidationError"].wrap({
                value,
                cause: result.error
            })
        };
    } catch (error) {
        return {
            success: false,
            error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TypeValidationError"].wrap({
                value,
                cause: error
            })
        };
    }
}
// src/parse-json.ts
function parseJSON({ text, schema }) {
    try {
        const value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$secure$2d$json$2d$parse$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].parse(text);
        if (schema == null) {
            return value;
        }
        return validateTypes({
            value,
            schema
        });
    } catch (error) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONParseError"].isInstance(error) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TypeValidationError"].isInstance(error)) {
            throw error;
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONParseError"]({
            text,
            cause: error
        });
    }
}
function safeParseJSON({ text, schema }) {
    try {
        const value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$secure$2d$json$2d$parse$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].parse(text);
        if (schema == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        const validationResult = safeValidateTypes({
            value,
            schema
        });
        return validationResult.success ? {
            ...validationResult,
            rawValue: value
        } : validationResult;
    } catch (error) {
        return {
            success: false,
            error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONParseError"].isInstance(error) ? error : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONParseError"]({
                text,
                cause: error
            })
        };
    }
}
function isParsableJson(input) {
    try {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$secure$2d$json$2d$parse$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].parse(input);
        return true;
    } catch (e) {
        return false;
    }
}
;
function parseProviderOptions({ provider, providerOptions, schema }) {
    if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
        return void 0;
    }
    const parsedProviderOptions = safeValidateTypes({
        value: providerOptions[provider],
        schema
    });
    if (!parsedProviderOptions.success) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InvalidArgumentError"]({
            argument: "providerOptions",
            message: `invalid ${provider} provider options`,
            cause: parsedProviderOptions.error
        });
    }
    return parsedProviderOptions.value;
}
;
var getOriginalFetch2 = ()=>globalThis.fetch;
var postJsonToApi = async ({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch })=>postToApi({
        url,
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        body: {
            content: JSON.stringify(body),
            values: body
        },
        failedResponseHandler,
        successfulResponseHandler,
        abortSignal,
        fetch
    });
var postFormDataToApi = async ({ url, headers, formData, failedResponseHandler, successfulResponseHandler, abortSignal, fetch })=>postToApi({
        url,
        headers,
        body: {
            content: formData,
            values: Object.fromEntries(formData.entries())
        },
        failedResponseHandler,
        successfulResponseHandler,
        abortSignal,
        fetch
    });
var postToApi = async ({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch = getOriginalFetch2() })=>{
    try {
        const response = await fetch(url, {
            method: "POST",
            headers: removeUndefinedEntries(headers),
            body: body.content,
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: body.values
                });
            } catch (error) {
                if (isAbortError(error) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"].isInstance(error)) {
                    throw error;
                }
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: body.values
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: body.values
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError(error) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"].isInstance(error)) {
                    throw error;
                }
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: body.values
            });
        }
    } catch (error) {
        if (isAbortError(error)) {
            throw error;
        }
        if (error instanceof TypeError && error.message === "fetch failed") {
            const cause = error.cause;
            if (cause != null) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                    message: `Cannot connect to API: ${cause.message}`,
                    cause,
                    url,
                    requestBodyValues: body.values,
                    isRetryable: true
                });
            }
        }
        throw error;
    }
};
// src/resolve.ts
async function resolve(value) {
    if (typeof value === "function") {
        value = value();
    }
    return Promise.resolve(value);
}
;
var createJsonErrorResponseHandler = ({ errorSchema, errorToMessage, isRetryable })=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const responseHeaders = extractResponseHeaders(response);
        if (responseBody.trim() === "") {
            return {
                responseHeaders,
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
        try {
            const parsedError = parseJSON({
                text: responseBody,
                schema: errorSchema
            });
            return {
                responseHeaders,
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                    message: errorToMessage(parsedError),
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    data: parsedError,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
                })
            };
        } catch (parseError) {
            return {
                responseHeaders,
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
    };
var createEventSourceResponseHandler = (chunkSchema)=>async ({ response })=>{
        const responseHeaders = extractResponseHeaders(response);
        if (response.body == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EmptyResponseBodyError"]({});
        }
        return {
            responseHeaders,
            value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(new TransformStream({
                transform ({ data }, controller) {
                    if (data === "[DONE]") {
                        return;
                    }
                    controller.enqueue(safeParseJSON({
                        text: data,
                        schema: chunkSchema
                    }));
                }
            }))
        };
    };
var createJsonStreamResponseHandler = (chunkSchema)=>async ({ response })=>{
        const responseHeaders = extractResponseHeaders(response);
        if (response.body == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EmptyResponseBodyError"]({});
        }
        let buffer = "";
        return {
            responseHeaders,
            value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({
                transform (chunkText, controller) {
                    if (chunkText.endsWith("\n")) {
                        controller.enqueue(safeParseJSON({
                            text: buffer + chunkText,
                            schema: chunkSchema
                        }));
                        buffer = "";
                    } else {
                        buffer += chunkText;
                    }
                }
            }))
        };
    };
var createJsonResponseHandler = (responseSchema)=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const parsedResult = safeParseJSON({
            text: responseBody,
            schema: responseSchema
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!parsedResult.success) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                message: "Invalid JSON response",
                cause: parsedResult.error,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                url,
                requestBodyValues
            });
        }
        return {
            responseHeaders,
            value: parsedResult.value,
            rawValue: parsedResult.rawValue
        };
    };
var createBinaryResponseHandler = ()=>async ({ response, url, requestBodyValues })=>{
        const responseHeaders = extractResponseHeaders(response);
        if (!response.body) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                message: "Response body is empty",
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody: void 0
            });
        }
        try {
            const buffer = await response.arrayBuffer();
            return {
                responseHeaders,
                value: new Uint8Array(buffer)
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                message: "Failed to read response as array buffer",
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody: void 0,
                cause: error
            });
        }
    };
var createStatusCodeErrorResponseHandler = ()=>async ({ response, url, requestBodyValues })=>{
        const responseHeaders = extractResponseHeaders(response);
        const responseBody = await response.text();
        return {
            responseHeaders,
            value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APICallError"]({
                message: response.statusText,
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody
            })
        };
    };
// src/uint8-utils.ts
var { btoa, atob } = globalThis;
function convertBase64ToUint8Array(base64String) {
    const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
    const latin1string = atob(base64Url);
    return Uint8Array.from(latin1string, (byte)=>byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array) {
    let latin1string = "";
    for(let i = 0; i < array.length; i++){
        latin1string += String.fromCodePoint(array[i]);
    }
    return btoa(latin1string);
}
// src/without-trailing-slash.ts
function withoutTrailingSlash(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@ai-sdk/ui-utils/dist/index.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

// src/index.ts
__turbopack_context__.s({
    "asSchema": ()=>asSchema,
    "callChatApi": ()=>callChatApi,
    "callCompletionApi": ()=>callCompletionApi,
    "extractMaxToolInvocationStep": ()=>extractMaxToolInvocationStep,
    "fillMessageParts": ()=>fillMessageParts,
    "formatAssistantStreamPart": ()=>formatAssistantStreamPart,
    "formatDataStreamPart": ()=>formatDataStreamPart,
    "getMessageParts": ()=>getMessageParts,
    "getTextFromDataUrl": ()=>getTextFromDataUrl,
    "isAssistantMessageWithCompletedToolCalls": ()=>isAssistantMessageWithCompletedToolCalls,
    "isDeepEqualData": ()=>isDeepEqualData,
    "jsonSchema": ()=>jsonSchema,
    "parseAssistantStreamPart": ()=>parseAssistantStreamPart,
    "parseDataStreamPart": ()=>parseDataStreamPart,
    "parsePartialJson": ()=>parsePartialJson,
    "prepareAttachmentsForRequest": ()=>prepareAttachmentsForRequest,
    "processAssistantStream": ()=>processAssistantStream,
    "processDataStream": ()=>processDataStream,
    "processTextStream": ()=>processTextStream,
    "shouldResubmitMessages": ()=>shouldResubmitMessages,
    "updateToolCallResult": ()=>updateToolCallResult,
    "zodSchema": ()=>zodSchema
});
// src/process-chat-response.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/provider-utils/dist/index.mjs [app-route] (ecmascript)");
// src/zod-schema.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/index.js [app-route] (ecmascript) <locals>");
;
// src/assistant-stream-parts.ts
var textStreamPart = {
    code: "0",
    name: "text",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"text" parts expect a string value.');
        }
        return {
            type: "text",
            value
        };
    }
};
var errorStreamPart = {
    code: "3",
    name: "error",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"error" parts expect a string value.');
        }
        return {
            type: "error",
            value
        };
    }
};
var assistantMessageStreamPart = {
    code: "4",
    name: "assistant_message",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("id" in value) || !("role" in value) || !("content" in value) || typeof value.id !== "string" || typeof value.role !== "string" || value.role !== "assistant" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === "object" && "type" in item && item.type === "text" && "text" in item && item.text != null && typeof item.text === "object" && "value" in item.text && typeof item.text.value === "string")) {
            throw new Error('"assistant_message" parts expect an object with an "id", "role", and "content" property.');
        }
        return {
            type: "assistant_message",
            value
        };
    }
};
var assistantControlDataStreamPart = {
    code: "5",
    name: "assistant_control_data",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("threadId" in value) || !("messageId" in value) || typeof value.threadId !== "string" || typeof value.messageId !== "string") {
            throw new Error('"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.');
        }
        return {
            type: "assistant_control_data",
            value: {
                threadId: value.threadId,
                messageId: value.messageId
            }
        };
    }
};
var dataMessageStreamPart = {
    code: "6",
    name: "data_message",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("role" in value) || !("data" in value) || typeof value.role !== "string" || value.role !== "data") {
            throw new Error('"data_message" parts expect an object with a "role" and "data" property.');
        }
        return {
            type: "data_message",
            value
        };
    }
};
var assistantStreamParts = [
    textStreamPart,
    errorStreamPart,
    assistantMessageStreamPart,
    assistantControlDataStreamPart,
    dataMessageStreamPart
];
var assistantStreamPartsByCode = {
    [textStreamPart.code]: textStreamPart,
    [errorStreamPart.code]: errorStreamPart,
    [assistantMessageStreamPart.code]: assistantMessageStreamPart,
    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,
    [dataMessageStreamPart.code]: dataMessageStreamPart
};
var StreamStringPrefixes = {
    [textStreamPart.name]: textStreamPart.code,
    [errorStreamPart.name]: errorStreamPart.code,
    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,
    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,
    [dataMessageStreamPart.name]: dataMessageStreamPart.code
};
var validCodes = assistantStreamParts.map((part)=>part.code);
var parseAssistantStreamPart = (line)=>{
    const firstSeparatorIndex = line.indexOf(":");
    if (firstSeparatorIndex === -1) {
        throw new Error("Failed to parse stream string. No separator found.");
    }
    const prefix = line.slice(0, firstSeparatorIndex);
    if (!validCodes.includes(prefix)) {
        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);
    }
    const code = prefix;
    const textValue = line.slice(firstSeparatorIndex + 1);
    const jsonValue = JSON.parse(textValue);
    return assistantStreamPartsByCode[code].parse(jsonValue);
};
function formatAssistantStreamPart(type, value) {
    const streamPart = assistantStreamParts.find((part)=>part.name === type);
    if (!streamPart) {
        throw new Error(`Invalid stream part type: ${type}`);
    }
    return `${streamPart.code}:${JSON.stringify(value)}
`;
}
;
// src/duplicated/usage.ts
function calculateLanguageModelUsage({ promptTokens, completionTokens }) {
    return {
        promptTokens,
        completionTokens,
        totalTokens: promptTokens + completionTokens
    };
}
;
// src/fix-json.ts
function fixJson(input) {
    const stack = [
        "ROOT"
    ];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
        {
            switch(char){
                case '"':
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_STRING");
                        break;
                    }
                case "f":
                case "t":
                case "n":
                    {
                        lastValidIndex = i;
                        literalStart = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_LITERAL");
                        break;
                    }
                case "-":
                    {
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "{":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_OBJECT_START");
                        break;
                    }
                case "[":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_ARRAY_START");
                        break;
                    }
            }
        }
    }
    function processAfterObjectValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_OBJECT_AFTER_COMMA");
                    break;
                }
            case "}":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    function processAfterArrayValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_ARRAY_AFTER_COMMA");
                    break;
                }
            case "]":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    for(let i = 0; i < input.length; i++){
        const char = input[i];
        const currentState = stack[stack.length - 1];
        switch(currentState){
            case "ROOT":
                processValueStart(char, i, "FINISH");
                break;
            case "INSIDE_OBJECT_START":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                        case "}":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_COMMA":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_KEY":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_AFTER_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_KEY":
                {
                    switch(char){
                        case ":":
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_BEFORE_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_BEFORE_VALUE":
                {
                    processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
                    break;
                }
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    processAfterObjectValue(char, i);
                    break;
                }
            case "INSIDE_STRING":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                lastValidIndex = i;
                                break;
                            }
                        case "\\":
                            {
                                stack.push("INSIDE_STRING_ESCAPE");
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_START":
                {
                    switch(char){
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    switch(char){
                        case ",":
                            {
                                stack.pop();
                                stack.push("INSIDE_ARRAY_AFTER_COMMA");
                                break;
                            }
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_COMMA":
                {
                    processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                    break;
                }
            case "INSIDE_STRING_ESCAPE":
                {
                    stack.pop();
                    lastValidIndex = i;
                    break;
                }
            case "INSIDE_NUMBER":
                {
                    switch(char){
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                            {
                                lastValidIndex = i;
                                break;
                            }
                        case "e":
                        case "E":
                        case "-":
                        case ".":
                            {
                                break;
                            }
                        case ",":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "}":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "]":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                break;
                            }
                        default:
                            {
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, i + 1);
                    if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
                        stack.pop();
                        if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                            processAfterObjectValue(char, i);
                        } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                            processAfterArrayValue(char, i);
                        }
                    } else {
                        lastValidIndex = i;
                    }
                    break;
                }
        }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for(let i = stack.length - 1; i >= 0; i--){
        const state = stack[i];
        switch(state){
            case "INSIDE_STRING":
                {
                    result += '"';
                    break;
                }
            case "INSIDE_OBJECT_KEY":
            case "INSIDE_OBJECT_AFTER_KEY":
            case "INSIDE_OBJECT_AFTER_COMMA":
            case "INSIDE_OBJECT_START":
            case "INSIDE_OBJECT_BEFORE_VALUE":
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    result += "}";
                    break;
                }
            case "INSIDE_ARRAY_START":
            case "INSIDE_ARRAY_AFTER_COMMA":
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    result += "]";
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, input.length);
                    if ("true".startsWith(partialLiteral)) {
                        result += "true".slice(partialLiteral.length);
                    } else if ("false".startsWith(partialLiteral)) {
                        result += "false".slice(partialLiteral.length);
                    } else if ("null".startsWith(partialLiteral)) {
                        result += "null".slice(partialLiteral.length);
                    }
                }
        }
    }
    return result;
}
// src/parse-partial-json.ts
function parsePartialJson(jsonText) {
    if (jsonText === void 0) {
        return {
            value: void 0,
            state: "undefined-input"
        };
    }
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeParseJSON"])({
        text: jsonText
    });
    if (result.success) {
        return {
            value: result.value,
            state: "successful-parse"
        };
    }
    result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeParseJSON"])({
        text: fixJson(jsonText)
    });
    if (result.success) {
        return {
            value: result.value,
            state: "repaired-parse"
        };
    }
    return {
        value: void 0,
        state: "failed-parse"
    };
}
// src/data-stream-parts.ts
var textStreamPart2 = {
    code: "0",
    name: "text",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"text" parts expect a string value.');
        }
        return {
            type: "text",
            value
        };
    }
};
var dataStreamPart = {
    code: "2",
    name: "data",
    parse: (value)=>{
        if (!Array.isArray(value)) {
            throw new Error('"data" parts expect an array value.');
        }
        return {
            type: "data",
            value
        };
    }
};
var errorStreamPart2 = {
    code: "3",
    name: "error",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"error" parts expect a string value.');
        }
        return {
            type: "error",
            value
        };
    }
};
var messageAnnotationsStreamPart = {
    code: "8",
    name: "message_annotations",
    parse: (value)=>{
        if (!Array.isArray(value)) {
            throw new Error('"message_annotations" parts expect an array value.');
        }
        return {
            type: "message_annotations",
            value
        };
    }
};
var toolCallStreamPart = {
    code: "9",
    name: "tool_call",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
            throw new Error('"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.');
        }
        return {
            type: "tool_call",
            value
        };
    }
};
var toolResultStreamPart = {
    code: "a",
    name: "tool_result",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
            throw new Error('"tool_result" parts expect an object with a "toolCallId" and a "result" property.');
        }
        return {
            type: "tool_result",
            value
        };
    }
};
var toolCallStreamingStartStreamPart = {
    code: "b",
    name: "tool_call_streaming_start",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
            throw new Error('"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.');
        }
        return {
            type: "tool_call_streaming_start",
            value
        };
    }
};
var toolCallDeltaStreamPart = {
    code: "c",
    name: "tool_call_delta",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
            throw new Error('"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.');
        }
        return {
            type: "tool_call_delta",
            value
        };
    }
};
var finishMessageStreamPart = {
    code: "d",
    name: "finish_message",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
            throw new Error('"finish_message" parts expect an object with a "finishReason" property.');
        }
        const result = {
            finishReason: value.finishReason
        };
        if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
            result.usage = {
                promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
                completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
            };
        }
        return {
            type: "finish_message",
            value: result
        };
    }
};
var finishStepStreamPart = {
    code: "e",
    name: "finish_step",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
            throw new Error('"finish_step" parts expect an object with a "finishReason" property.');
        }
        const result = {
            finishReason: value.finishReason,
            isContinued: false
        };
        if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
            result.usage = {
                promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
                completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
            };
        }
        if ("isContinued" in value && typeof value.isContinued === "boolean") {
            result.isContinued = value.isContinued;
        }
        return {
            type: "finish_step",
            value: result
        };
    }
};
var startStepStreamPart = {
    code: "f",
    name: "start_step",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
            throw new Error('"start_step" parts expect an object with an "id" property.');
        }
        return {
            type: "start_step",
            value: {
                messageId: value.messageId
            }
        };
    }
};
var reasoningStreamPart = {
    code: "g",
    name: "reasoning",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"reasoning" parts expect a string value.');
        }
        return {
            type: "reasoning",
            value
        };
    }
};
var sourcePart = {
    code: "h",
    name: "source",
    parse: (value)=>{
        if (value == null || typeof value !== "object") {
            throw new Error('"source" parts expect a Source object.');
        }
        return {
            type: "source",
            value
        };
    }
};
var redactedReasoningStreamPart = {
    code: "i",
    name: "redacted_reasoning",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
            throw new Error('"redacted_reasoning" parts expect an object with a "data" property.');
        }
        return {
            type: "redacted_reasoning",
            value: {
                data: value.data
            }
        };
    }
};
var reasoningSignatureStreamPart = {
    code: "j",
    name: "reasoning_signature",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
            throw new Error('"reasoning_signature" parts expect an object with a "signature" property.');
        }
        return {
            type: "reasoning_signature",
            value: {
                signature: value.signature
            }
        };
    }
};
var fileStreamPart = {
    code: "k",
    name: "file",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
            throw new Error('"file" parts expect an object with a "data" and "mimeType" property.');
        }
        return {
            type: "file",
            value
        };
    }
};
var dataStreamParts = [
    textStreamPart2,
    dataStreamPart,
    errorStreamPart2,
    messageAnnotationsStreamPart,
    toolCallStreamPart,
    toolResultStreamPart,
    toolCallStreamingStartStreamPart,
    toolCallDeltaStreamPart,
    finishMessageStreamPart,
    finishStepStreamPart,
    startStepStreamPart,
    reasoningStreamPart,
    sourcePart,
    redactedReasoningStreamPart,
    reasoningSignatureStreamPart,
    fileStreamPart
];
var dataStreamPartsByCode = Object.fromEntries(dataStreamParts.map((part)=>[
        part.code,
        part
    ]));
var DataStreamStringPrefixes = Object.fromEntries(dataStreamParts.map((part)=>[
        part.name,
        part.code
    ]));
var validCodes2 = dataStreamParts.map((part)=>part.code);
var parseDataStreamPart = (line)=>{
    const firstSeparatorIndex = line.indexOf(":");
    if (firstSeparatorIndex === -1) {
        throw new Error("Failed to parse stream string. No separator found.");
    }
    const prefix = line.slice(0, firstSeparatorIndex);
    if (!validCodes2.includes(prefix)) {
        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);
    }
    const code = prefix;
    const textValue = line.slice(firstSeparatorIndex + 1);
    const jsonValue = JSON.parse(textValue);
    return dataStreamPartsByCode[code].parse(jsonValue);
};
function formatDataStreamPart(type, value) {
    const streamPart = dataStreamParts.find((part)=>part.name === type);
    if (!streamPart) {
        throw new Error(`Invalid stream part type: ${type}`);
    }
    return `${streamPart.code}:${JSON.stringify(value)}
`;
}
// src/process-data-stream.ts
var NEWLINE = "\n".charCodeAt(0);
function concatChunks(chunks, totalLength) {
    const concatenatedChunks = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks){
        concatenatedChunks.set(chunk, offset);
        offset += chunk.length;
    }
    chunks.length = 0;
    return concatenatedChunks;
}
async function processDataStream({ stream, onTextPart, onReasoningPart, onReasoningSignaturePart, onRedactedReasoningPart, onSourcePart, onFilePart, onDataPart, onErrorPart, onToolCallStreamingStartPart, onToolCallDeltaPart, onToolCallPart, onToolResultPart, onMessageAnnotationsPart, onFinishMessagePart, onFinishStepPart, onStartStepPart }) {
    const reader = stream.getReader();
    const decoder = new TextDecoder();
    const chunks = [];
    let totalLength = 0;
    while(true){
        const { value } = await reader.read();
        if (value) {
            chunks.push(value);
            totalLength += value.length;
            if (value[value.length - 1] !== NEWLINE) {
                continue;
            }
        }
        if (chunks.length === 0) {
            break;
        }
        const concatenatedChunks = concatChunks(chunks, totalLength);
        totalLength = 0;
        const streamParts = decoder.decode(concatenatedChunks, {
            stream: true
        }).split("\n").filter((line)=>line !== "").map(parseDataStreamPart);
        for (const { type, value: value2 } of streamParts){
            switch(type){
                case "text":
                    await (onTextPart == null ? void 0 : onTextPart(value2));
                    break;
                case "reasoning":
                    await (onReasoningPart == null ? void 0 : onReasoningPart(value2));
                    break;
                case "reasoning_signature":
                    await (onReasoningSignaturePart == null ? void 0 : onReasoningSignaturePart(value2));
                    break;
                case "redacted_reasoning":
                    await (onRedactedReasoningPart == null ? void 0 : onRedactedReasoningPart(value2));
                    break;
                case "file":
                    await (onFilePart == null ? void 0 : onFilePart(value2));
                    break;
                case "source":
                    await (onSourcePart == null ? void 0 : onSourcePart(value2));
                    break;
                case "data":
                    await (onDataPart == null ? void 0 : onDataPart(value2));
                    break;
                case "error":
                    await (onErrorPart == null ? void 0 : onErrorPart(value2));
                    break;
                case "message_annotations":
                    await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));
                    break;
                case "tool_call_streaming_start":
                    await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));
                    break;
                case "tool_call_delta":
                    await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));
                    break;
                case "tool_call":
                    await (onToolCallPart == null ? void 0 : onToolCallPart(value2));
                    break;
                case "tool_result":
                    await (onToolResultPart == null ? void 0 : onToolResultPart(value2));
                    break;
                case "finish_message":
                    await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));
                    break;
                case "finish_step":
                    await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));
                    break;
                case "start_step":
                    await (onStartStepPart == null ? void 0 : onStartStepPart(value2));
                    break;
                default:
                    {
                        const exhaustiveCheck = type;
                        throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);
                    }
            }
        }
    }
}
// src/process-chat-response.ts
async function processChatResponse({ stream, update, onToolCall, onFinish, generateId: generateId2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateId"], getCurrentDate = ()=>/* @__PURE__ */ new Date(), lastMessage }) {
    var _a, _b;
    const replaceLastMessage = (lastMessage == null ? void 0 : lastMessage.role) === "assistant";
    let step = replaceLastMessage ? 1 + // find max step in existing tool invocations:
    ((_b = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.reduce((max, toolInvocation)=>{
        var _a2;
        return Math.max(max, (_a2 = toolInvocation.step) != null ? _a2 : 0);
    }, 0)) != null ? _b : 0) : 0;
    const message = replaceLastMessage ? structuredClone(lastMessage) : {
        id: generateId2(),
        createdAt: getCurrentDate(),
        role: "assistant",
        content: "",
        parts: []
    };
    let currentTextPart = void 0;
    let currentReasoningPart = void 0;
    let currentReasoningTextDetail = void 0;
    function updateToolInvocationPart(toolCallId, invocation) {
        const part = message.parts.find((part2)=>part2.type === "tool-invocation" && part2.toolInvocation.toolCallId === toolCallId);
        if (part != null) {
            part.toolInvocation = invocation;
        } else {
            message.parts.push({
                type: "tool-invocation",
                toolInvocation: invocation
            });
        }
    }
    const data = [];
    let messageAnnotations = replaceLastMessage ? lastMessage == null ? void 0 : lastMessage.annotations : void 0;
    const partialToolCalls = {};
    let usage = {
        completionTokens: NaN,
        promptTokens: NaN,
        totalTokens: NaN
    };
    let finishReason = "unknown";
    function execUpdate() {
        const copiedData = [
            ...data
        ];
        if (messageAnnotations == null ? void 0 : messageAnnotations.length) {
            message.annotations = messageAnnotations;
        }
        const copiedMessage = {
            // deep copy the message to ensure that deep changes (msg attachments) are updated
            // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.
            ...structuredClone(message),
            // add a revision id to ensure that the message is updated with SWR. SWR uses a
            // hashing approach by default to detect changes, but it only works for shallow
            // changes. This is why we need to add a revision id to ensure that the message
            // is updated with SWR (without it, the changes get stuck in SWR and are not
            // forwarded to rendering):
            revisionId: generateId2()
        };
        update({
            message: copiedMessage,
            data: copiedData,
            replaceLastMessage
        });
    }
    await processDataStream({
        stream,
        onTextPart (value) {
            if (currentTextPart == null) {
                currentTextPart = {
                    type: "text",
                    text: value
                };
                message.parts.push(currentTextPart);
            } else {
                currentTextPart.text += value;
            }
            message.content += value;
            execUpdate();
        },
        onReasoningPart (value) {
            var _a2;
            if (currentReasoningTextDetail == null) {
                currentReasoningTextDetail = {
                    type: "text",
                    text: value
                };
                if (currentReasoningPart != null) {
                    currentReasoningPart.details.push(currentReasoningTextDetail);
                }
            } else {
                currentReasoningTextDetail.text += value;
            }
            if (currentReasoningPart == null) {
                currentReasoningPart = {
                    type: "reasoning",
                    reasoning: value,
                    details: [
                        currentReasoningTextDetail
                    ]
                };
                message.parts.push(currentReasoningPart);
            } else {
                currentReasoningPart.reasoning += value;
            }
            message.reasoning = ((_a2 = message.reasoning) != null ? _a2 : "") + value;
            execUpdate();
        },
        onReasoningSignaturePart (value) {
            if (currentReasoningTextDetail != null) {
                currentReasoningTextDetail.signature = value.signature;
            }
        },
        onRedactedReasoningPart (value) {
            if (currentReasoningPart == null) {
                currentReasoningPart = {
                    type: "reasoning",
                    reasoning: "",
                    details: []
                };
                message.parts.push(currentReasoningPart);
            }
            currentReasoningPart.details.push({
                type: "redacted",
                data: value.data
            });
            currentReasoningTextDetail = void 0;
            execUpdate();
        },
        onFilePart (value) {
            message.parts.push({
                type: "file",
                mimeType: value.mimeType,
                data: value.data
            });
            execUpdate();
        },
        onSourcePart (value) {
            message.parts.push({
                type: "source",
                source: value
            });
            execUpdate();
        },
        onToolCallStreamingStartPart (value) {
            if (message.toolInvocations == null) {
                message.toolInvocations = [];
            }
            partialToolCalls[value.toolCallId] = {
                text: "",
                step,
                toolName: value.toolName,
                index: message.toolInvocations.length
            };
            const invocation = {
                state: "partial-call",
                step,
                toolCallId: value.toolCallId,
                toolName: value.toolName,
                args: void 0
            };
            message.toolInvocations.push(invocation);
            updateToolInvocationPart(value.toolCallId, invocation);
            execUpdate();
        },
        onToolCallDeltaPart (value) {
            const partialToolCall = partialToolCalls[value.toolCallId];
            partialToolCall.text += value.argsTextDelta;
            const { value: partialArgs } = parsePartialJson(partialToolCall.text);
            const invocation = {
                state: "partial-call",
                step: partialToolCall.step,
                toolCallId: value.toolCallId,
                toolName: partialToolCall.toolName,
                args: partialArgs
            };
            message.toolInvocations[partialToolCall.index] = invocation;
            updateToolInvocationPart(value.toolCallId, invocation);
            execUpdate();
        },
        async onToolCallPart (value) {
            const invocation = {
                state: "call",
                step,
                ...value
            };
            if (partialToolCalls[value.toolCallId] != null) {
                message.toolInvocations[partialToolCalls[value.toolCallId].index] = invocation;
            } else {
                if (message.toolInvocations == null) {
                    message.toolInvocations = [];
                }
                message.toolInvocations.push(invocation);
            }
            updateToolInvocationPart(value.toolCallId, invocation);
            execUpdate();
            if (onToolCall) {
                const result = await onToolCall({
                    toolCall: value
                });
                if (result != null) {
                    const invocation2 = {
                        state: "result",
                        step,
                        ...value,
                        result
                    };
                    message.toolInvocations[message.toolInvocations.length - 1] = invocation2;
                    updateToolInvocationPart(value.toolCallId, invocation2);
                    execUpdate();
                }
            }
        },
        onToolResultPart (value) {
            const toolInvocations = message.toolInvocations;
            if (toolInvocations == null) {
                throw new Error("tool_result must be preceded by a tool_call");
            }
            const toolInvocationIndex = toolInvocations.findIndex((invocation2)=>invocation2.toolCallId === value.toolCallId);
            if (toolInvocationIndex === -1) {
                throw new Error("tool_result must be preceded by a tool_call with the same toolCallId");
            }
            const invocation = {
                ...toolInvocations[toolInvocationIndex],
                state: "result",
                ...value
            };
            toolInvocations[toolInvocationIndex] = invocation;
            updateToolInvocationPart(value.toolCallId, invocation);
            execUpdate();
        },
        onDataPart (value) {
            data.push(...value);
            execUpdate();
        },
        onMessageAnnotationsPart (value) {
            if (messageAnnotations == null) {
                messageAnnotations = [
                    ...value
                ];
            } else {
                messageAnnotations.push(...value);
            }
            execUpdate();
        },
        onFinishStepPart (value) {
            step += 1;
            currentTextPart = value.isContinued ? currentTextPart : void 0;
            currentReasoningPart = void 0;
            currentReasoningTextDetail = void 0;
        },
        onStartStepPart (value) {
            if (!replaceLastMessage) {
                message.id = value.messageId;
            }
            message.parts.push({
                type: "step-start"
            });
            execUpdate();
        },
        onFinishMessagePart (value) {
            finishReason = value.finishReason;
            if (value.usage != null) {
                usage = calculateLanguageModelUsage(value.usage);
            }
        },
        onErrorPart (error) {
            throw new Error(error);
        }
    });
    onFinish == null ? void 0 : onFinish({
        message,
        finishReason,
        usage
    });
}
;
// src/process-text-stream.ts
async function processTextStream({ stream, onTextPart }) {
    const reader = stream.pipeThrough(new TextDecoderStream()).getReader();
    while(true){
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        await onTextPart(value);
    }
}
// src/process-chat-text-response.ts
async function processChatTextResponse({ stream, update, onFinish, getCurrentDate = ()=>/* @__PURE__ */ new Date(), generateId: generateId2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateId"] }) {
    const textPart = {
        type: "text",
        text: ""
    };
    const resultMessage = {
        id: generateId2(),
        createdAt: getCurrentDate(),
        role: "assistant",
        content: "",
        parts: [
            textPart
        ]
    };
    await processTextStream({
        stream,
        onTextPart: (chunk)=>{
            resultMessage.content += chunk;
            textPart.text += chunk;
            update({
                message: {
                    ...resultMessage
                },
                data: [],
                replaceLastMessage: false
            });
        }
    });
    onFinish == null ? void 0 : onFinish(resultMessage, {
        usage: {
            completionTokens: NaN,
            promptTokens: NaN,
            totalTokens: NaN
        },
        finishReason: "unknown"
    });
}
// src/call-chat-api.ts
var getOriginalFetch = ()=>fetch;
async function callChatApi({ api, body, streamProtocol = "data", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, onToolCall, generateId: generateId2, fetch: fetch2 = getOriginalFetch(), lastMessage, requestType = "generate" }) {
    var _a, _b, _c;
    const request = requestType === "resume" ? fetch2(`${api}?chatId=${body.id}`, {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,
        credentials
    }) : fetch2(api, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        signal: (_b = abortController == null ? void 0 : abortController()) == null ? void 0 : _b.signal,
        credentials
    });
    const response = await request.catch((err)=>{
        restoreMessagesOnFailure();
        throw err;
    });
    if (onResponse) {
        try {
            await onResponse(response);
        } catch (err) {
            throw err;
        }
    }
    if (!response.ok) {
        restoreMessagesOnFailure();
        throw new Error((_c = await response.text()) != null ? _c : "Failed to fetch the chat response.");
    }
    if (!response.body) {
        throw new Error("The response body is empty.");
    }
    switch(streamProtocol){
        case "text":
            {
                await processChatTextResponse({
                    stream: response.body,
                    update: onUpdate,
                    onFinish,
                    generateId: generateId2
                });
                return;
            }
        case "data":
            {
                await processChatResponse({
                    stream: response.body,
                    update: onUpdate,
                    lastMessage,
                    onToolCall,
                    onFinish ({ message, finishReason, usage }) {
                        if (onFinish && message != null) {
                            onFinish(message, {
                                usage,
                                finishReason
                            });
                        }
                    },
                    generateId: generateId2
                });
                return;
            }
        default:
            {
                const exhaustiveCheck = streamProtocol;
                throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);
            }
    }
}
// src/call-completion-api.ts
var getOriginalFetch2 = ()=>fetch;
async function callCompletionApi({ api, prompt, credentials, headers, body, streamProtocol = "data", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData, fetch: fetch2 = getOriginalFetch2() }) {
    var _a;
    try {
        setLoading(true);
        setError(void 0);
        const abortController = new AbortController();
        setAbortController(abortController);
        setCompletion("");
        const response = await fetch2(api, {
            method: "POST",
            body: JSON.stringify({
                prompt,
                ...body
            }),
            credentials,
            headers: {
                "Content-Type": "application/json",
                ...headers
            },
            signal: abortController.signal
        }).catch((err)=>{
            throw err;
        });
        if (onResponse) {
            try {
                await onResponse(response);
            } catch (err) {
                throw err;
            }
        }
        if (!response.ok) {
            throw new Error((_a = await response.text()) != null ? _a : "Failed to fetch the chat response.");
        }
        if (!response.body) {
            throw new Error("The response body is empty.");
        }
        let result = "";
        switch(streamProtocol){
            case "text":
                {
                    await processTextStream({
                        stream: response.body,
                        onTextPart: (chunk)=>{
                            result += chunk;
                            setCompletion(result);
                        }
                    });
                    break;
                }
            case "data":
                {
                    await processDataStream({
                        stream: response.body,
                        onTextPart (value) {
                            result += value;
                            setCompletion(result);
                        },
                        onDataPart (value) {
                            onData == null ? void 0 : onData(value);
                        },
                        onErrorPart (value) {
                            throw new Error(value);
                        }
                    });
                    break;
                }
            default:
                {
                    const exhaustiveCheck = streamProtocol;
                    throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);
                }
        }
        if (onFinish) {
            onFinish(prompt, result);
        }
        setAbortController(null);
        return result;
    } catch (err) {
        if (err.name === "AbortError") {
            setAbortController(null);
            return null;
        }
        if (err instanceof Error) {
            if (onError) {
                onError(err);
            }
        }
        setError(err);
    } finally{
        setLoading(false);
    }
}
// src/data-url.ts
function getTextFromDataUrl(dataUrl) {
    const [header, base64Content] = dataUrl.split(",");
    const mimeType = header.split(";")[0].split(":")[1];
    if (mimeType == null || base64Content == null) {
        throw new Error("Invalid data URL format");
    }
    try {
        return window.atob(base64Content);
    } catch (error) {
        throw new Error(`Error decoding data URL`);
    }
}
// src/extract-max-tool-invocation-step.ts
function extractMaxToolInvocationStep(toolInvocations) {
    return toolInvocations == null ? void 0 : toolInvocations.reduce((max, toolInvocation)=>{
        var _a;
        return Math.max(max, (_a = toolInvocation.step) != null ? _a : 0);
    }, 0);
}
// src/get-message-parts.ts
function getMessageParts(message) {
    var _a;
    return (_a = message.parts) != null ? _a : [
        ...message.toolInvocations ? message.toolInvocations.map((toolInvocation)=>({
                type: "tool-invocation",
                toolInvocation
            })) : [],
        ...message.reasoning ? [
            {
                type: "reasoning",
                reasoning: message.reasoning,
                details: [
                    {
                        type: "text",
                        text: message.reasoning
                    }
                ]
            }
        ] : [],
        ...message.content ? [
            {
                type: "text",
                text: message.content
            }
        ] : []
    ];
}
// src/fill-message-parts.ts
function fillMessageParts(messages) {
    return messages.map((message)=>({
            ...message,
            parts: getMessageParts(message)
        }));
}
// src/is-deep-equal-data.ts
function isDeepEqualData(obj1, obj2) {
    if (obj1 === obj2) return true;
    if (obj1 == null || obj2 == null) return false;
    if (typeof obj1 !== "object" && typeof obj2 !== "object") return obj1 === obj2;
    if (obj1.constructor !== obj2.constructor) return false;
    if (obj1 instanceof Date && obj2 instanceof Date) {
        return obj1.getTime() === obj2.getTime();
    }
    if (Array.isArray(obj1)) {
        if (obj1.length !== obj2.length) return false;
        for(let i = 0; i < obj1.length; i++){
            if (!isDeepEqualData(obj1[i], obj2[i])) return false;
        }
        return true;
    }
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) return false;
    for (const key of keys1){
        if (!keys2.includes(key)) return false;
        if (!isDeepEqualData(obj1[key], obj2[key])) return false;
    }
    return true;
}
// src/prepare-attachments-for-request.ts
async function prepareAttachmentsForRequest(attachmentsFromOptions) {
    if (!attachmentsFromOptions) {
        return [];
    }
    if (globalThis.FileList && attachmentsFromOptions instanceof globalThis.FileList) {
        return Promise.all(Array.from(attachmentsFromOptions).map(async (attachment)=>{
            const { name, type } = attachment;
            const dataUrl = await new Promise((resolve, reject)=>{
                const reader = new FileReader();
                reader.onload = (readerEvent)=>{
                    var _a;
                    resolve((_a = readerEvent.target) == null ? void 0 : _a.result);
                };
                reader.onerror = (error)=>reject(error);
                reader.readAsDataURL(attachment);
            });
            return {
                name,
                contentType: type,
                url: dataUrl
            };
        }));
    }
    if (Array.isArray(attachmentsFromOptions)) {
        return attachmentsFromOptions;
    }
    throw new Error("Invalid attachments type");
}
// src/process-assistant-stream.ts
var NEWLINE2 = "\n".charCodeAt(0);
function concatChunks2(chunks, totalLength) {
    const concatenatedChunks = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks){
        concatenatedChunks.set(chunk, offset);
        offset += chunk.length;
    }
    chunks.length = 0;
    return concatenatedChunks;
}
async function processAssistantStream({ stream, onTextPart, onErrorPart, onAssistantMessagePart, onAssistantControlDataPart, onDataMessagePart }) {
    const reader = stream.getReader();
    const decoder = new TextDecoder();
    const chunks = [];
    let totalLength = 0;
    while(true){
        const { value } = await reader.read();
        if (value) {
            chunks.push(value);
            totalLength += value.length;
            if (value[value.length - 1] !== NEWLINE2) {
                continue;
            }
        }
        if (chunks.length === 0) {
            break;
        }
        const concatenatedChunks = concatChunks2(chunks, totalLength);
        totalLength = 0;
        const streamParts = decoder.decode(concatenatedChunks, {
            stream: true
        }).split("\n").filter((line)=>line !== "").map(parseAssistantStreamPart);
        for (const { type, value: value2 } of streamParts){
            switch(type){
                case "text":
                    await (onTextPart == null ? void 0 : onTextPart(value2));
                    break;
                case "error":
                    await (onErrorPart == null ? void 0 : onErrorPart(value2));
                    break;
                case "assistant_message":
                    await (onAssistantMessagePart == null ? void 0 : onAssistantMessagePart(value2));
                    break;
                case "assistant_control_data":
                    await (onAssistantControlDataPart == null ? void 0 : onAssistantControlDataPart(value2));
                    break;
                case "data_message":
                    await (onDataMessagePart == null ? void 0 : onDataMessagePart(value2));
                    break;
                default:
                    {
                        const exhaustiveCheck = type;
                        throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);
                    }
            }
        }
    }
}
;
;
function zodSchema(zodSchema2, options) {
    var _a;
    const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;
    return jsonSchema((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(zodSchema2, {
        $refStrategy: useReferences ? "root" : "none",
        target: "jsonSchema7"
    }), {
        validate: (value)=>{
            const result = zodSchema2.safeParse(value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
// src/schema.ts
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, { validate } = {}) {
    return {
        [schemaSymbol]: true,
        _type: void 0,
        // should never be used directly
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validatorSymbol"]]: true,
        jsonSchema: jsonSchema2,
        validate
    };
}
function isSchema(value) {
    return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
    return isSchema(schema) ? schema : zodSchema(schema);
}
// src/should-resubmit-messages.ts
function shouldResubmitMessages({ originalMaxToolInvocationStep, originalMessageCount, maxSteps, messages }) {
    var _a;
    const lastMessage = messages[messages.length - 1];
    return(// check if the feature is enabled:
    maxSteps > 1 && // ensure there is a last message:
    lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):
    (messages.length > originalMessageCount || extractMaxToolInvocationStep(lastMessage.toolInvocations) !== originalMaxToolInvocationStep) && // check that next step is possible:
    isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:
    ((_a = extractMaxToolInvocationStep(lastMessage.toolInvocations)) != null ? _a : 0) < maxSteps);
}
function isAssistantMessageWithCompletedToolCalls(message) {
    if (message.role !== "assistant") {
        return false;
    }
    const lastStepStartIndex = message.parts.reduce((lastIndex, part, index)=>{
        return part.type === "step-start" ? index : lastIndex;
    }, -1);
    const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter((part)=>part.type === "tool-invocation");
    return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part)=>"result" in part.toolInvocation);
}
// src/update-tool-call-result.ts
function updateToolCallResult({ messages, toolCallId, toolResult: result }) {
    var _a;
    const lastMessage = messages[messages.length - 1];
    const invocationPart = lastMessage.parts.find((part)=>part.type === "tool-invocation" && part.toolInvocation.toolCallId === toolCallId);
    if (invocationPart == null) {
        return;
    }
    const toolResult = {
        ...invocationPart.toolInvocation,
        state: "result",
        result
    };
    invocationPart.toolInvocation = toolResult;
    lastMessage.toolInvocations = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.map((toolInvocation)=>toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/zod-from-json-schema/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/index.ts
__turbopack_context__.s({
    "convertJsonSchemaToZod": ()=>convertJsonSchemaToZod,
    "jsonSchemaObjectToZodRawShape": ()=>jsonSchemaObjectToZodRawShape
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
function convertJsonSchemaToZod(schema) {
    function addMetadata(zodSchema, jsonSchema) {
        if (jsonSchema.description) {
            zodSchema = zodSchema.describe(jsonSchema.description);
        }
        return zodSchema;
    }
    if (schema.const !== void 0) {
        if (typeof schema.const === "string") {
            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(schema.const), schema);
        } else if (typeof schema.const === "number") {
            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(schema.const), schema);
        } else if (typeof schema.const === "boolean") {
            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(schema.const), schema);
        } else if (schema.const === null) {
            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null(), schema);
        }
        return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(schema.const), schema);
    }
    if (schema.type) {
        switch(schema.type){
            case "string":
                {
                    if (schema.enum) {
                        if (schema.enum.length === 0) {
                            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), schema);
                        }
                        return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum(schema.enum), schema);
                    }
                    let stringSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string();
                    if (schema.minLength !== void 0) {
                        stringSchema = stringSchema.min(schema.minLength);
                    }
                    if (schema.maxLength !== void 0) {
                        stringSchema = stringSchema.max(schema.maxLength);
                    }
                    if (schema.pattern !== void 0) {
                        const regex = new RegExp(schema.pattern);
                        stringSchema = stringSchema.regex(regex);
                    }
                    return addMetadata(stringSchema, schema);
                }
            case "number":
            case "integer":
                {
                    if (schema.enum) {
                        if (schema.enum.length === 0) {
                            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(), schema);
                        }
                        const options = schema.enum.map((val)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(val));
                        if (options.length === 1) {
                            return addMetadata(options[0], schema);
                        }
                        if (options.length >= 2) {
                            const unionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                                options[0],
                                options[1],
                                ...options.slice(2)
                            ]);
                            return addMetadata(unionSchema, schema);
                        }
                    }
                    let numberSchema = schema.type === "integer" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number();
                    if (schema.minimum !== void 0) {
                        numberSchema = numberSchema.min(schema.minimum);
                    }
                    if (schema.maximum !== void 0) {
                        numberSchema = numberSchema.max(schema.maximum);
                    }
                    if (schema.exclusiveMinimum !== void 0) {
                        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
                    }
                    if (schema.exclusiveMaximum !== void 0) {
                        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
                    }
                    if (schema.multipleOf !== void 0) {
                        numberSchema = numberSchema.multipleOf(schema.multipleOf);
                    }
                    return addMetadata(numberSchema, schema);
                }
            case "boolean":
                if (schema.enum) {
                    if (schema.enum.length === 0) {
                        return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(), schema);
                    }
                    const options = schema.enum.map((val)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(val));
                    if (options.length === 1) {
                        return addMetadata(options[0], schema);
                    }
                    if (options.length >= 2) {
                        const unionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                            options[0],
                            options[1],
                            ...options.slice(2)
                        ]);
                        return addMetadata(unionSchema, schema);
                    }
                }
                return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(), schema);
            case "null":
                return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null(), schema);
            case "object":
                if (schema.properties) {
                    const shape = {};
                    for (const [key, propSchema] of Object.entries(schema.properties)){
                        shape[key] = convertJsonSchemaToZod(propSchema);
                    }
                    if (schema.required && Array.isArray(schema.required)) {
                        const required = new Set(schema.required);
                        for (const key of Object.keys(shape)){
                            if (!required.has(key)) {
                                shape[key] = shape[key].optional();
                            }
                        }
                    } else {
                        for (const key of Object.keys(shape)){
                            shape[key] = shape[key].optional();
                        }
                    }
                    let zodSchema;
                    if (schema.additionalProperties !== false) {
                        zodSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object(shape).passthrough();
                    } else {
                        zodSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object(shape);
                    }
                    return addMetadata(zodSchema, schema);
                }
                return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}), schema);
            case "array":
                {
                    let arraySchema;
                    if (schema.items) {
                        arraySchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(convertJsonSchemaToZod(schema.items));
                    } else {
                        arraySchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any());
                    }
                    if (schema.minItems !== void 0) {
                        arraySchema = arraySchema.min(schema.minItems);
                    }
                    if (schema.maxItems !== void 0) {
                        arraySchema = arraySchema.max(schema.maxItems);
                    }
                    if (schema.uniqueItems === true) {
                        arraySchema = arraySchema.refine((items)=>{
                            const seen = /* @__PURE__ */ new Set();
                            return items.every((item)=>{
                                if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
                                    if (seen.has(item)) return false;
                                    seen.add(item);
                                    return true;
                                }
                                const serialized = JSON.stringify(item);
                                if (seen.has(serialized)) return false;
                                seen.add(serialized);
                                return true;
                            });
                        }, {
                            message: "Array items must be unique"
                        });
                    }
                    return addMetadata(arraySchema, schema);
                }
        }
    }
    if (schema.enum) {
        if (schema.enum.length === 0) {
            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].never(), schema);
        }
        const allStrings = schema.enum.every((val)=>typeof val === "string");
        if (allStrings) {
            return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum(schema.enum), schema);
        } else {
            const options = schema.enum.map((val)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(val));
            if (options.length === 1) {
                return addMetadata(options[0], schema);
            }
            if (options.length >= 2) {
                const unionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                    options[0],
                    options[1],
                    ...options.slice(2)
                ]);
                return addMetadata(unionSchema, schema);
            }
        }
    }
    if (schema.anyOf && schema.anyOf.length >= 2) {
        const schemas = schema.anyOf.map(convertJsonSchemaToZod);
        return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            schemas[0],
            schemas[1],
            ...schemas.slice(2)
        ]), schema);
    }
    if (schema.allOf) {
        return addMetadata(schema.allOf.reduce((acc, s)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].intersection(acc, convertJsonSchemaToZod(s)), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({})), schema);
    }
    if (schema.oneOf && schema.oneOf.length >= 2) {
        const schemas = schema.oneOf.map(convertJsonSchemaToZod);
        return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            schemas[0],
            schemas[1],
            ...schemas.slice(2)
        ]), schema);
    }
    return addMetadata(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(), schema);
}
function jsonSchemaObjectToZodRawShape(schema) {
    var _a;
    let raw = {};
    for (const [key, value] of Object.entries((_a = schema.properties) != null ? _a : {})){
        raw[key] = convertJsonSchemaToZod(value);
    }
    return raw;
}
;
}),
"[project]/node_modules/@mastra/schema-compat/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ALL_ARRAY_CHECKS": ()=>ALL_ARRAY_CHECKS,
    "ALL_NUMBER_CHECKS": ()=>ALL_NUMBER_CHECKS,
    "ALL_STRING_CHECKS": ()=>ALL_STRING_CHECKS,
    "ALL_ZOD_TYPES": ()=>ALL_ZOD_TYPES,
    "AnthropicSchemaCompatLayer": ()=>AnthropicSchemaCompatLayer,
    "DeepSeekSchemaCompatLayer": ()=>DeepSeekSchemaCompatLayer,
    "GoogleSchemaCompatLayer": ()=>GoogleSchemaCompatLayer,
    "MetaSchemaCompatLayer": ()=>MetaSchemaCompatLayer,
    "OpenAIReasoningSchemaCompatLayer": ()=>OpenAIReasoningSchemaCompatLayer,
    "OpenAISchemaCompatLayer": ()=>OpenAISchemaCompatLayer,
    "SUPPORTED_ZOD_TYPES": ()=>SUPPORTED_ZOD_TYPES,
    "SchemaCompatLayer": ()=>SchemaCompatLayer,
    "UNSUPPORTED_ZOD_TYPES": ()=>UNSUPPORTED_ZOD_TYPES,
    "applyCompatLayer": ()=>applyCompatLayer,
    "convertSchemaToZod": ()=>convertSchemaToZod,
    "convertZodSchemaToAISDKSchema": ()=>convertZodSchemaToAISDKSchema,
    "isArr": ()=>isArr,
    "isNumber": ()=>isNumber,
    "isObj": ()=>isObj,
    "isOptional": ()=>isOptional,
    "isString": ()=>isString,
    "isUnion": ()=>isUnion
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$ui$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/ui-utils/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$from$2d$json$2d$schema$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod-from-json-schema/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$zodToJsonSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js [app-route] (ecmascript)");
;
;
;
;
// src/schema-compatibility.ts
function convertZodSchemaToAISDKSchema(zodSchema, target = "jsonSchema7") {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$ui$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["jsonSchema"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$zodToJsonSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["zodToJsonSchema"])(zodSchema, {
        $refStrategy: "none",
        target
    }), {
        validate: (value)=>{
            const result = zodSchema.safeParse(value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function isZodType(value) {
    return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function convertSchemaToZod(schema) {
    if (isZodType(schema)) {
        return schema;
    } else {
        const jsonSchemaToConvert = "jsonSchema" in schema ? schema.jsonSchema : schema;
        try {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$from$2d$json$2d$schema$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertJsonSchemaToZod"])(jsonSchemaToConvert);
        } catch (e) {
            const errorMessage = `[Schema Builder] Failed to convert schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;
            console.error(errorMessage, e);
            throw new Error(errorMessage + (e instanceof Error ? `
${e.stack}` : "\nUnknown error object"));
        }
    }
}
function applyCompatLayer({ schema, compatLayers, mode }) {
    let zodSchema;
    if (!isZodType(schema)) {
        zodSchema = convertSchemaToZod(schema);
    } else {
        zodSchema = schema;
    }
    for (const compat of compatLayers){
        if (compat.shouldApply()) {
            return mode === "jsonSchema" ? compat.processToJSONSchema(zodSchema) : compat.processToAISDKSchema(zodSchema);
        }
    }
    if (mode === "jsonSchema") {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$zodToJsonSchema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["zodToJsonSchema"])(zodSchema, {
            $refStrategy: "none",
            target: "jsonSchema7"
        });
    } else {
        return convertZodSchemaToAISDKSchema(zodSchema);
    }
}
// src/schema-compatibility.ts
var ALL_STRING_CHECKS = [
    "regex",
    "emoji",
    "email",
    "url",
    "uuid",
    "cuid",
    "min",
    "max"
];
var ALL_NUMBER_CHECKS = [
    "min",
    // gte internally
    "max",
    // lte internally
    "multipleOf"
];
var ALL_ARRAY_CHECKS = [
    "min",
    "max",
    "length"
];
var isOptional = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodOptional"];
var isObj = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodObject"];
var isNull = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodNull"];
var isArr = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodArray"];
var isUnion = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodUnion"];
var isString = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodString"];
var isNumber = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodNumber"];
var isDate = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodDate"];
var isDefault = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodDefault"];
var UNSUPPORTED_ZOD_TYPES = [
    "ZodIntersection",
    "ZodNever",
    "ZodNull",
    "ZodTuple",
    "ZodUndefined"
];
var SUPPORTED_ZOD_TYPES = [
    "ZodObject",
    "ZodArray",
    "ZodUnion",
    "ZodString",
    "ZodNumber",
    "ZodDate",
    "ZodAny",
    "ZodDefault"
];
var ALL_ZOD_TYPES = [
    ...SUPPORTED_ZOD_TYPES,
    ...UNSUPPORTED_ZOD_TYPES
];
var SchemaCompatLayer = class {
    model;
    /**
   * Creates a new schema compatibility instance.
   *
   * @param model - The language model this compatibility layer applies to
   */ constructor(model){
        this.model = model;
    }
    /**
   * Gets the language model associated with this compatibility layer.
   *
   * @returns The language model instance
   */ getModel() {
        return this.model;
    }
    /**
   * Default handler for Zod object types. Recursively processes all properties in the object.
   *
   * @param value - The Zod object to process
   * @returns The processed Zod object
   */ defaultZodObjectHandler(value, options = {
        passthrough: true
    }) {
        const processedShape = Object.entries(value.shape).reduce((acc, [key, propValue])=>{
            acc[key] = this.processZodType(propValue);
            return acc;
        }, {});
        let result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object(processedShape);
        if (value._def.unknownKeys === "strict") {
            result = result.strict();
        }
        if (value._def.catchall && !(value._def.catchall instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].ZodNever)) {
            result = result.catchall(value._def.catchall);
        }
        if (value.description) {
            result = result.describe(value.description);
        }
        if (options.passthrough && value._def.unknownKeys === "passthrough") {
            result = result.passthrough();
        }
        return result;
    }
    /**
   * Merges validation constraints into a parameter description.
   *
   * This helper method converts validation constraints that may not be supported
   * by a provider into human-readable descriptions.
   *
   * @param description - The existing parameter description
   * @param constraints - The validation constraints to merge
   * @returns The updated description with constraints, or undefined if no constraints
   */ mergeParameterDescription(description, constraints) {
        if (Object.keys(constraints).length > 0) {
            return (description ? description + "\n" : "") + JSON.stringify(constraints);
        } else {
            return description;
        }
    }
    /**
   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.
   *
   * @param value - The Zod type to check
   * @param throwOnTypes - Array of type names to throw errors for
   * @returns The original value if not in the throw list
   * @throws Error if the type is in the unsupported list
   */ defaultUnsupportedZodTypeHandler(value, throwOnTypes = UNSUPPORTED_ZOD_TYPES) {
        if (throwOnTypes.includes(value._def?.typeName)) {
            throw new Error(`${this.model.modelId} does not support zod type: ${value._def?.typeName}`);
        }
        return value;
    }
    /**
   * Default handler for Zod array types. Processes array constraints according to provider support.
   *
   * @param value - The Zod array to process
   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod array
   */ defaultZodArrayHandler(value, handleChecks = ALL_ARRAY_CHECKS) {
        const zodArrayDef = value._def;
        const processedType = this.processZodType(zodArrayDef.type);
        let result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(processedType);
        const constraints = {};
        if (zodArrayDef.minLength?.value !== void 0) {
            if (handleChecks.includes("min")) {
                constraints.minLength = zodArrayDef.minLength.value;
            } else {
                result = result.min(zodArrayDef.minLength.value);
            }
        }
        if (zodArrayDef.maxLength?.value !== void 0) {
            if (handleChecks.includes("max")) {
                constraints.maxLength = zodArrayDef.maxLength.value;
            } else {
                result = result.max(zodArrayDef.maxLength.value);
            }
        }
        if (zodArrayDef.exactLength?.value !== void 0) {
            if (handleChecks.includes("length")) {
                constraints.exactLength = zodArrayDef.exactLength.value;
            } else {
                result = result.length(zodArrayDef.exactLength.value);
            }
        }
        const description = this.mergeParameterDescription(value.description, constraints);
        if (description) {
            result = result.describe(description);
        }
        return result;
    }
    /**
   * Default handler for Zod union types. Processes all union options.
   *
   * @param value - The Zod union to process
   * @returns The processed Zod union
   * @throws Error if union has fewer than 2 options
   */ defaultZodUnionHandler(value) {
        const processedOptions = value._def.options.map((option)=>this.processZodType(option));
        if (processedOptions.length < 2) throw new Error("Union must have at least 2 options");
        let result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union(processedOptions);
        if (value.description) {
            result = result.describe(value.description);
        }
        return result;
    }
    /**
   * Default handler for Zod string types. Processes string validation constraints.
   *
   * @param value - The Zod string to process
   * @param handleChecks - String constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod string
   */ defaultZodStringHandler(value, handleChecks = ALL_STRING_CHECKS) {
        const constraints = {};
        const checks = value._def.checks || [];
        const newChecks = [];
        for (const check of checks){
            if ("kind" in check) {
                if (handleChecks.includes(check.kind)) {
                    switch(check.kind){
                        case "regex":
                            {
                                constraints.regex = {
                                    pattern: check.regex.source,
                                    flags: check.regex.flags
                                };
                                break;
                            }
                        case "emoji":
                            {
                                constraints.emoji = true;
                                break;
                            }
                        case "email":
                            {
                                constraints.email = true;
                                break;
                            }
                        case "url":
                            {
                                constraints.url = true;
                                break;
                            }
                        case "uuid":
                            {
                                constraints.uuid = true;
                                break;
                            }
                        case "cuid":
                            {
                                constraints.cuid = true;
                                break;
                            }
                        case "min":
                            {
                                constraints.minLength = check.value;
                                break;
                            }
                        case "max":
                            {
                                constraints.maxLength = check.value;
                                break;
                            }
                    }
                } else {
                    newChecks.push(check);
                }
            }
        }
        let result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string();
        for (const check of newChecks){
            result = result._addCheck(check);
        }
        const description = this.mergeParameterDescription(value.description, constraints);
        if (description) {
            result = result.describe(description);
        }
        return result;
    }
    /**
   * Default handler for Zod number types. Processes number validation constraints.
   *
   * @param value - The Zod number to process
   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation
   * @returns The processed Zod number
   */ defaultZodNumberHandler(value, handleChecks = ALL_NUMBER_CHECKS) {
        const constraints = {};
        const checks = value._def.checks || [];
        const newChecks = [];
        for (const check of checks){
            if ("kind" in check) {
                if (handleChecks.includes(check.kind)) {
                    switch(check.kind){
                        case "min":
                            if (check.inclusive) {
                                constraints.gte = check.value;
                            } else {
                                constraints.gt = check.value;
                            }
                            break;
                        case "max":
                            if (check.inclusive) {
                                constraints.lte = check.value;
                            } else {
                                constraints.lt = check.value;
                            }
                            break;
                        case "multipleOf":
                            {
                                constraints.multipleOf = check.value;
                                break;
                            }
                    }
                } else {
                    newChecks.push(check);
                }
            }
        }
        let result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number();
        for (const check of newChecks){
            switch(check.kind){
                case "int":
                    result = result.int();
                    break;
                case "finite":
                    result = result.finite();
                    break;
                default:
                    result = result._addCheck(check);
            }
        }
        const description = this.mergeParameterDescription(value.description, constraints);
        if (description) {
            result = result.describe(description);
        }
        return result;
    }
    /**
   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.
   *
   * @param value - The Zod date to process
   * @returns A Zod string schema representing the date in ISO format
   */ defaultZodDateHandler(value) {
        const constraints = {};
        const checks = value._def.checks || [];
        for (const check of checks){
            if ("kind" in check) {
                switch(check.kind){
                    case "min":
                        const minDate = new Date(check.value);
                        if (!isNaN(minDate.getTime())) {
                            constraints.minDate = minDate.toISOString();
                        }
                        break;
                    case "max":
                        const maxDate = new Date(check.value);
                        if (!isNaN(maxDate.getTime())) {
                            constraints.maxDate = maxDate.toISOString();
                        }
                        break;
                }
            }
        }
        constraints.dateFormat = "date-time";
        let result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("date-time");
        const description = this.mergeParameterDescription(value.description, constraints);
        if (description) {
            result = result.describe(description);
        }
        return result;
    }
    /**
   * Default handler for Zod optional types. Processes the inner type and maintains optionality.
   *
   * @param value - The Zod optional to process
   * @param handleTypes - Types that should be processed vs passed through
   * @returns The processed Zod optional
   */ defaultZodOptionalHandler(value, handleTypes = SUPPORTED_ZOD_TYPES) {
        if (handleTypes.includes(value._def.innerType._def.typeName)) {
            return this.processZodType(value._def.innerType).optional();
        } else {
            return value;
        }
    }
    /**
   * Processes a Zod object schema and converts it to an AI SDK Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns An AI SDK Schema with provider-specific compatibility applied
   */ processToAISDKSchema(zodSchema) {
        const processedSchema = this.processZodType(zodSchema);
        return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());
    }
    /**
   * Processes a Zod object schema and converts it to a JSON Schema.
   *
   * @param zodSchema - The Zod object schema to process
   * @returns A JSONSchema7 object with provider-specific compatibility applied
   */ processToJSONSchema(zodSchema) {
        return this.processToAISDKSchema(zodSchema).jsonSchema;
    }
};
// src/provider-compats/anthropic.ts
var AnthropicSchemaCompatLayer = class extends SchemaCompatLayer {
    constructor(model){
        super(model);
    }
    getSchemaTarget() {
        return "jsonSchema7";
    }
    shouldApply() {
        return this.getModel().modelId.includes("claude");
    }
    processZodType(value) {
        if (isOptional(value)) {
            const handleTypes = [
                "ZodObject",
                "ZodArray",
                "ZodUnion",
                "ZodNever",
                "ZodUndefined",
                "ZodTuple"
            ];
            if (this.getModel().modelId.includes("claude-3.5-haiku")) handleTypes.push("ZodString");
            return this.defaultZodOptionalHandler(value, handleTypes);
        } else if (isObj(value)) {
            return this.defaultZodObjectHandler(value);
        } else if (isArr(value)) {
            return this.defaultZodArrayHandler(value, []);
        } else if (isUnion(value)) {
            return this.defaultZodUnionHandler(value);
        } else if (isString(value)) {
            if (this.getModel().modelId.includes("claude-3.5-haiku")) {
                return this.defaultZodStringHandler(value, [
                    "max",
                    "min"
                ]);
            } else {
                return value;
            }
        }
        return this.defaultUnsupportedZodTypeHandler(value, [
            "ZodNever",
            "ZodTuple",
            "ZodUndefined"
        ]);
    }
};
// src/provider-compats/deepseek.ts
var DeepSeekSchemaCompatLayer = class extends SchemaCompatLayer {
    constructor(model){
        super(model);
    }
    getSchemaTarget() {
        return "jsonSchema7";
    }
    shouldApply() {
        return this.getModel().modelId.includes("deepseek") && !this.getModel().modelId.includes("r1");
    }
    processZodType(value) {
        if (isOptional(value)) {
            return this.defaultZodOptionalHandler(value, [
                "ZodObject",
                "ZodArray",
                "ZodUnion",
                "ZodString",
                "ZodNumber"
            ]);
        } else if (isObj(value)) {
            return this.defaultZodObjectHandler(value);
        } else if (isArr(value)) {
            return this.defaultZodArrayHandler(value, [
                "min",
                "max"
            ]);
        } else if (isUnion(value)) {
            return this.defaultZodUnionHandler(value);
        } else if (isString(value)) {
            return this.defaultZodStringHandler(value);
        }
        return value;
    }
};
var GoogleSchemaCompatLayer = class extends SchemaCompatLayer {
    constructor(model){
        super(model);
    }
    getSchemaTarget() {
        return "jsonSchema7";
    }
    shouldApply() {
        return this.getModel().provider.includes("google") || this.getModel().modelId.includes("google");
    }
    processZodType(value) {
        if (isOptional(value)) {
            return this.defaultZodOptionalHandler(value, [
                "ZodObject",
                "ZodArray",
                "ZodUnion",
                "ZodString",
                "ZodNumber",
                ...UNSUPPORTED_ZOD_TYPES
            ]);
        } else if (isNull(value)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().refine((v)=>v === null, {
                message: "must be null"
            }).describe(value._def.description || "must be null");
        } else if (isObj(value)) {
            return this.defaultZodObjectHandler(value);
        } else if (isArr(value)) {
            return this.defaultZodArrayHandler(value, []);
        } else if (isUnion(value)) {
            return this.defaultZodUnionHandler(value);
        } else if (isString(value)) {
            return this.defaultZodStringHandler(value);
        } else if (isNumber(value)) {
            return this.defaultZodNumberHandler(value);
        }
        return this.defaultUnsupportedZodTypeHandler(value);
    }
};
// src/provider-compats/meta.ts
var MetaSchemaCompatLayer = class extends SchemaCompatLayer {
    constructor(model){
        super(model);
    }
    getSchemaTarget() {
        return "jsonSchema7";
    }
    shouldApply() {
        return this.getModel().modelId.includes("meta");
    }
    processZodType(value) {
        if (isOptional(value)) {
            return this.defaultZodOptionalHandler(value, [
                "ZodObject",
                "ZodArray",
                "ZodUnion",
                "ZodString",
                "ZodNumber"
            ]);
        } else if (isObj(value)) {
            return this.defaultZodObjectHandler(value);
        } else if (isArr(value)) {
            return this.defaultZodArrayHandler(value, [
                "min",
                "max"
            ]);
        } else if (isUnion(value)) {
            return this.defaultZodUnionHandler(value);
        } else if (isNumber(value)) {
            return this.defaultZodNumberHandler(value);
        } else if (isString(value)) {
            return this.defaultZodStringHandler(value);
        }
        return value;
    }
};
// src/provider-compats/openai.ts
var OpenAISchemaCompatLayer = class extends SchemaCompatLayer {
    constructor(model){
        super(model);
    }
    getSchemaTarget() {
        return `jsonSchema7`;
    }
    shouldApply() {
        if (!this.getModel().supportsStructuredOutputs && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {
            return true;
        }
        return false;
    }
    processZodType(value) {
        if (isOptional(value)) {
            return this.defaultZodOptionalHandler(value, [
                "ZodObject",
                "ZodArray",
                "ZodUnion",
                "ZodString",
                "ZodNever",
                "ZodUndefined",
                "ZodTuple"
            ]);
        } else if (isObj(value)) {
            return this.defaultZodObjectHandler(value);
        } else if (isUnion(value)) {
            return this.defaultZodUnionHandler(value);
        } else if (isArr(value)) {
            return this.defaultZodArrayHandler(value);
        } else if (isString(value)) {
            const model = this.getModel();
            const checks = [
                "emoji"
            ];
            if (model.modelId.includes("gpt-4o-mini")) {
                checks.push("regex");
            }
            return this.defaultZodStringHandler(value, checks);
        }
        return this.defaultUnsupportedZodTypeHandler(value, [
            "ZodNever",
            "ZodUndefined",
            "ZodTuple"
        ]);
    }
};
var OpenAIReasoningSchemaCompatLayer = class extends SchemaCompatLayer {
    constructor(model){
        super(model);
    }
    getSchemaTarget() {
        return `openApi3`;
    }
    isReasoningModel() {
        return this.getModel().modelId.includes(`o3`) || this.getModel().modelId.includes(`o4`);
    }
    shouldApply() {
        if ((this.getModel().supportsStructuredOutputs || this.isReasoningModel()) && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {
            return true;
        }
        return false;
    }
    processZodType(value) {
        if (isOptional(value)) {
            const innerZodType = this.processZodType(value._def.innerType);
            return innerZodType.nullable();
        } else if (isObj(value)) {
            return this.defaultZodObjectHandler(value, {
                passthrough: false
            });
        } else if (isArr(value)) {
            return this.defaultZodArrayHandler(value);
        } else if (isUnion(value)) {
            return this.defaultZodUnionHandler(value);
        } else if (isDefault(value)) {
            const defaultDef = value._def;
            const innerType = defaultDef.innerType;
            const defaultValue = defaultDef.defaultValue();
            const constraints = {};
            if (defaultValue !== void 0) {
                constraints.defaultValue = defaultValue;
            }
            const description = this.mergeParameterDescription(value.description, constraints);
            let result = this.processZodType(innerType);
            if (description) {
                result = result.describe(description);
            }
            return result;
        } else if (isNumber(value)) {
            return this.defaultZodNumberHandler(value);
        } else if (isString(value)) {
            return this.defaultZodStringHandler(value);
        } else if (isDate(value)) {
            return this.defaultZodDateHandler(value);
        } else if (value._def.typeName === "ZodAny") {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe((value.description ?? "") + `
Argument was an "any" type, but you (the LLM) do not support "any", so it was cast to a "string" type`);
        }
        return this.defaultUnsupportedZodTypeHandler(value);
    }
};
;
}),
"[project]/node_modules/uri-js/dist/es5/uri.all.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports) : "TURBOPACK unreachable";
})(("TURBOPACK member replacement", __turbopack_context__.e), function(exports1) {
    'use strict';
    function merge() {
        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){
            sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for(var x = 1; x < xl; ++x){
                sets[x] = sets[x].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join('');
        } else {
            return sets[0];
        }
    }
    function subexp(str) {
        return "(?:" + str + ")";
    }
    function typeOf(o) {
        return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
        return str.toUpperCase();
    }
    function toArray(obj) {
        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [
            obj
        ] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
        var obj = target;
        if (source) {
            for(var key in source){
                obj[key] = source[key];
            }
        }
        return obj;
    }
    function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), //case-insensitive
        LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), //expanded
        GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", //subset, excludes bidi control characters
        IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", //subset
        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), //relaxed parsing rules
        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), //                           6( h16 ":" ) ls32
        IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), //                      "::" 5( h16 ":" ) ls32
        IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), //[               h16 ] "::" 4( h16 ":" ) ls32
        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), //[ *4( h16 ":" ) h16 ] "::"              ls32
        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), //[ *5( h16 ":" ) h16 ] "::"              h16
        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), //[ *6( h16 ":" ) h16 ] "::"
        IPV6ADDRESS$ = subexp([
            IPV6ADDRESS1$,
            IPV6ADDRESS2$,
            IPV6ADDRESS3$,
            IPV6ADDRESS4$,
            IPV6ADDRESS5$,
            IPV6ADDRESS6$,
            IPV6ADDRESS7$,
            IPV6ADDRESS8$,
            IPV6ADDRESS9$
        ].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), //RFC 6874
        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), //RFC 6874
        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$), //RFC 6874, with relaxed parsing rules
        IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), //RFC 6874
        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), //simplified
        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified
        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified
        PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
            NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$, "g"),
            OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
        };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;
            try {
                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) {
                return arr;
            } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
            } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
        };
    }();
    var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
            return arr2;
        } else {
            return Array.from(arr);
        }
    };
    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
    /** Bootstring parameters */ var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = '-'; // '\x2D'
    /** Regular expressions */ var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
    /** Error messages */ var errors = {
        'overflow': 'Overflow: input needs wider integers to process',
        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
        'invalid-input': 'Invalid input'
    };
    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    /*--------------------------------------------------------------------------*/ /**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */ function error$1(type) {
        throw new RangeError(errors[type]);
    }
    /**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */ function map(array, fn) {
        var result = [];
        var length = array.length;
        while(length--){
            result[length] = fn(array[length]);
        }
        return result;
    }
    /**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */ function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
    }
    /**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */ function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while(counter < length){
            var value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // It's a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                    // Low surrogate.
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                    // It's an unmatched surrogate; only append this code unit, in case the
                    // next code unit is the high surrogate of a surrogate pair.
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    }
    /**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */ var ucs2encode = function ucs2encode(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    /**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */ var basicToDigit = function basicToDigit(codePoint) {
        if (codePoint - 0x30 < 0x0A) {
            return codePoint - 0x16;
        }
        if (codePoint - 0x41 < 0x1A) {
            return codePoint - 0x41;
        }
        if (codePoint - 0x61 < 0x1A) {
            return codePoint - 0x61;
        }
        return base;
    };
    /**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */ var digitToBasic = function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    /**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */ var adapt = function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for(; delta > baseMinusTMin * tMax >> 1; k += base){
            delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    /**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */ var decode = function decode(input) {
        // Don't use UCS-2.
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
            basic = 0;
        }
        for(var j = 0; j < basic; ++j){
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
                error$1('not-basic');
            }
            output.push(input.charCodeAt(j));
        }
        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.
        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            var oldi = i;
            for(var w = 1, k = base;; k += base){
                if (index >= inputLength) {
                    error$1('invalid-input');
                }
                var digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error$1('overflow');
                }
                i += digit * w;
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (digit < t) {
                    break;
                }
                var baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                    error$1('overflow');
                }
                w *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
                error$1('overflow');
            }
            n += floor(i / out);
            i %= out;
            // Insert `n` at position `i` of the output.
            output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
    };
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */ var encode = function encode(input) {
        var output = [];
        // Convert the input in UCS-2 to an array of Unicode code points.
        input = ucs2decode(input);
        // Cache the length.
        var inputLength = input.length;
        // Initialize the state.
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        // Handle the basic code points.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _currentValue2 = _step.value;
                if (_currentValue2 < 0x80) {
                    output.push(stringFromCharCode(_currentValue2));
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string with a delimiter unless it's empty.
        if (basicLength) {
            output.push(delimiter);
        }
        // Main encoding loop:
        while(handledCPCount < inputLength){
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            var m = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;
            try {
                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var currentValue = _step2.value;
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow.
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally{
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error$1('overflow');
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;
            try {
                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                    var _currentValue = _step3.value;
                    if (_currentValue < n && ++delta > maxInt) {
                        error$1('overflow');
                    }
                    if (_currentValue == n) {
                        // Represent delta as a generalized variable-length integer.
                        var q = delta;
                        for(var k = base;; k += base){
                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                                break;
                            }
                            var qMinusT = q - t;
                            var baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally{
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
            ++delta;
            ++n;
        }
        return output.join('');
    };
    /**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */ var toUnicode = function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
    };
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */ var toASCII = function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
    };
    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {
        /**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */ 'version': '2.1.0',
        /**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */ 'ucs2': {
            'decode': ucs2decode,
            'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
    };
    /**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */ /**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */ var SCHEMES = {};
    function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
    }
    function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while(i < il){
            var c = parseInt(str.substr(i + 1, 2), 16);
            if (c < 128) {
                newStr += String.fromCharCode(c);
                i += 3;
            } else if (c >= 194 && c < 224) {
                if (il - i >= 6) {
                    var c2 = parseInt(str.substr(i + 4, 2), 16);
                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                } else {
                    newStr += str.substr(i, 6);
                }
                i += 6;
            } else if (c >= 224) {
                if (il - i >= 9) {
                    var _c = parseInt(str.substr(i + 4, 2), 16);
                    var c3 = parseInt(str.substr(i + 7, 2), 16);
                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                } else {
                    newStr += str.substr(i, 9);
                }
                i += 9;
            } else {
                newStr += str.substr(i, 3);
                i += 3;
            }
        }
        return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
    }
    function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
            return host;
        }
    }
    function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for(var x = 0; x < fieldCount; ++x){
                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
            }
            if (isLastFieldIPv4Address) {
                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function(acc, field, index) {
                if (!field || field === "0") {
                    var lastLongest = acc[acc.length - 1];
                    if (lastLongest && lastLongest.index + lastLongest.length === index) {
                        lastLongest.length++;
                    } else {
                        acc.push({
                            index: index,
                            length: 1
                        });
                    }
                }
                return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a, b) {
                return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
                var newFirst = fields.slice(0, longestZeroFields.index);
                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
                newHost = fields.join(":");
            }
            if (zone) {
                newHost += "%" + zone;
            }
            return newHost;
        } else {
            return host;
        }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
    function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
                //store each component
                components.scheme = matches[1];
                components.userinfo = matches[3];
                components.host = matches[4];
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = matches[7];
                components.fragment = matches[8];
                //fix port number
                if (isNaN(components.port)) {
                    components.port = matches[5];
                }
            } else {
                //IE FIX for improper RegExp matching
                //store each component
                components.scheme = matches[1] || undefined;
                components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                //fix port number
                if (isNaN(components.port)) {
                    components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
                }
            }
            if (components.host) {
                //normalize IP hosts
                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            //determine reference type
            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
                components.reference = "same-document";
            } else if (components.scheme === undefined) {
                components.reference = "relative";
            } else if (components.fragment === undefined) {
                components.reference = "absolute";
            } else {
                components.reference = "uri";
            }
            //check for reference errors
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
                components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            //find scheme handler
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            //check if scheme can't handle IRIs
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                //if host component is a domain name
                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                    } catch (e) {
                        components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                    }
                }
                //convert IRI -> URI
                _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
                //normalize encodings
                _normalizeComponentEncoding(components, protocol);
            }
            //perform scheme specific parsing
            if (schemeHandler && schemeHandler.parse) {
                schemeHandler.parse(components, options);
            }
        } else {
            components.error = components.error || "URI can not be parsed.";
        }
        return components;
    }
    function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== undefined) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
        }
        if (components.host !== undefined) {
            //normalize IP hosts, add brackets and escape zone separator for IPv6
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
                return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : undefined;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
        var output = [];
        while(input.length){
            if (input.match(RDS1)) {
                input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
                input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
                input = input.replace(RDS3, "/");
                output.pop();
            } else if (input === "." || input === "..") {
                input = "";
            } else {
                var im = input.match(RDS5);
                if (im) {
                    var s = im[0];
                    input = input.slice(s.length);
                    output.push(s);
                } else {
                    throw new Error("Unexpected dot segment condition");
                }
            }
        }
        return output.join("");
    }
    function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //perform scheme specific serialization
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
            //if host component is an IPv6 address
            if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
        }
        //normalize encoding
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== undefined) {
            if (options.reference !== "suffix") {
                uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
                uriTokens.push("/");
            }
        }
        if (components.path !== undefined) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
                s = removeDotSegments(s);
            }
            if (authority === undefined) {
                s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
            }
            uriTokens.push(s);
        }
        if (components.query !== undefined) {
            uriTokens.push("?");
            uriTokens.push(components.query);
        }
        if (components.fragment !== undefined) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
        }
        return uriTokens.join(""); //merge tokens into a string
    }
    function resolveComponents(base, relative) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
            base = parse(serialize(base, options), options); //normalize base components
            relative = parse(serialize(relative, options), options); //normalize relative components
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                //target.authority = relative.authority;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || "");
                target.query = relative.query;
            } else {
                if (!relative.path) {
                    target.path = base.path;
                    if (relative.query !== undefined) {
                        target.query = relative.query;
                    } else {
                        target.query = base.query;
                    }
                } else {
                    if (relative.path.charAt(0) === "/") {
                        target.path = removeDotSegments(relative.path);
                    } else {
                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                            target.path = "/" + relative.path;
                        } else if (!base.path) {
                            target.path = relative.path;
                        } else {
                            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                        }
                        target.path = removeDotSegments(target.path);
                    }
                    target.query = relative.query;
                }
                //target.authority = base.authority;
                target.userinfo = base.userinfo;
                target.host = base.host;
                target.port = base.port;
            }
            target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
    }
    function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({
            scheme: 'null'
        }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
        if (typeof uri === "string") {
            uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
            uri = parse(serialize(uri, options), options);
        }
        return uri;
    }
    function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
            uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
            uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
            uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
            uriB = serialize(uriB, options);
        }
        return uriA === uriB;
    }
    function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse(components, options) {
            //report missing host
            if (!components.host) {
                components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
        },
        serialize: function serialize(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            //normalize the default port
            if (components.port === (secure ? 443 : 80) || components.port === "") {
                components.port = undefined;
            }
            //normalize the empty path
            if (!components.path) {
                components.path = "/";
            }
            //NOTE: We do not parse query strings for HTTP URIs
            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
            //and not the HTTP spec.
            return components;
        }
    };
    var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
    };
    function isSecure(wsComponents) {
        return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    //RFC 6455
    var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse(components, options) {
            var wsComponents = components;
            //indicate if the secure flag is set
            wsComponents.secure = isSecure(wsComponents);
            //construct resouce name
            wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
            wsComponents.path = undefined;
            wsComponents.query = undefined;
            return wsComponents;
        },
        serialize: function serialize(wsComponents, options) {
            //normalize the default port
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
                wsComponents.port = undefined;
            }
            //ensure scheme matches secure flag
            if (typeof wsComponents.secure === 'boolean') {
                wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
                wsComponents.secure = undefined;
            }
            //reconstruct path from resource name
            if (wsComponents.resourceName) {
                var _wsComponents$resourc = wsComponents.resourceName.split('?'), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
                wsComponents.path = path && path !== '/' ? path : undefined;
                wsComponents.query = query;
                wsComponents.resourceName = undefined;
            }
            //forbid fragment component
            wsComponents.fragment = undefined;
            return wsComponents;
        }
    };
    var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
    };
    var O = {};
    var isIRI = true;
    //RFC 3986
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (("TURBOPACK compile-time truthy", 1) ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "TURBOPACK unreachable") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
    //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
    //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
    //const VCHAR$$ = "[\\x21-\\x7E]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
    //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
    //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
    //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = undefined;
            if (mailtoComponents.query) {
                var unknownHeaders = false;
                var headers = {};
                var hfields = mailtoComponents.query.split("&");
                for(var x = 0, xl = hfields.length; x < xl; ++x){
                    var hfield = hfields[x].split("=");
                    switch(hfield[0]){
                        case "to":
                            var toAddrs = hfield[1].split(",");
                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){
                                to.push(toAddrs[_x]);
                            }
                            break;
                        case "subject":
                            mailtoComponents.subject = unescapeComponent(hfield[1], options);
                            break;
                        case "body":
                            mailtoComponents.body = unescapeComponent(hfield[1], options);
                            break;
                        default:
                            unknownHeaders = true;
                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                            break;
                    }
                }
                if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = undefined;
            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){
                var addr = to[_x2].split("@");
                addr[0] = unescapeComponent(addr[0]);
                if (!options.unicodeSupport) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                    } catch (e) {
                        mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                    }
                } else {
                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                }
                to[_x2] = addr.join("@");
            }
            return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
                for(var x = 0, xl = to.length; x < xl; ++x){
                    var toAddr = String(to[x]);
                    var atIdx = toAddr.lastIndexOf("@");
                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                    var domain = toAddr.slice(atIdx + 1);
                    //convert IDN via punycode
                    try {
                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                    } catch (e) {
                        components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                    }
                    to[x] = localPart + "@" + domain;
                }
                components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for(var name in headers){
                if (headers[name] !== O[name]) {
                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
                }
            }
            if (fields.length) {
                components.query = fields.join("&");
            }
            return components;
        }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    //RFC 2141
    var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = matches[1].toLowerCase();
                var nss = matches[2];
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES[urnScheme];
                urnComponents.nid = nid;
                urnComponents.nss = nss;
                urnComponents.path = undefined;
                if (schemeHandler) {
                    urnComponents = schemeHandler.parse(urnComponents, options);
                }
            } else {
                urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
                urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
        }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    //RFC 4122
    var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = undefined;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
                uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
        },
        serialize: function serialize(uuidComponents, options) {
            var urnComponents = uuidComponents;
            //normalize UUID
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
        }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports1.SCHEMES = SCHEMES;
    exports1.pctEncChar = pctEncChar;
    exports1.pctDecChars = pctDecChars;
    exports1.parse = parse;
    exports1.removeDotSegments = removeDotSegments;
    exports1.serialize = serialize;
    exports1.resolveComponents = resolveComponents;
    exports1.resolve = resolve;
    exports1.normalize = normalize;
    exports1.equal = equal;
    exports1.escapeComponent = escapeComponent;
    exports1.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
}); //# sourceMappingURL=uri.all.js.map
}}),
"[project]/node_modules/fast-deep-equal/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};
}}),
"[project]/node_modules/json-schema-traverse/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == 'function') {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == 'function' ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, '', schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) {
                    for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                }
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == 'object') {
                    for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
                _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
            }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
}}),
"[project]/node_modules/fast-json-stable-stringify/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = function(data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = {
        cmp: opts
    };
    var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
        return function(node) {
            return function(a, b) {
                var aobj = {
                    key: a,
                    value: node[a]
                };
                var bobj = {
                    key: b,
                    value: node[b]
                };
                return f(aobj, bobj);
            };
        };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }
        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for(i = 0; i < node.length; i++){
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }
        if (node === null) return 'null';
        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for(i = 0; i < keys.length; i++){
            var key = keys[i];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    }(data);
};
}}),
"[project]/node_modules/eventsource-parser/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ParseError": ()=>ParseError,
    "createParser": ()=>createParser
});
class ParseError extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
}
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = !0, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = !1;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/eventsource-parser/dist/stream.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "EventSourceParserStream": ()=>EventSourceParserStream
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/eventsource-parser/dist/index.js [app-route] (ecmascript)");
;
;
class EventSourceParserStream extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}){
        let parser;
        super({
            start (controller) {
                parser = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createParser"])({
                    onEvent: (event)=>{
                        controller.enqueue(event);
                    },
                    onError (error) {
                        onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                    },
                    onRetry,
                    onComment
                });
            },
            transform (chunk) {
                parser.feed(chunk);
            }
        });
    }
}
;
 //# sourceMappingURL=stream.js.map
}),
"[project]/node_modules/eventsource/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ErrorEvent": ()=>ErrorEvent,
    "EventSource": ()=>EventSource
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/eventsource-parser/dist/index.js [app-route] (ecmascript)");
;
class ErrorEvent extends Event {
    /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */ constructor(type, errorEventInitDict){
        var _a, _b;
        super(type), this.code = (_a = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
    }
    /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */ [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        return inspect(inspectableError(this), options);
    }
    /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */ [Symbol.for("Deno.customInspect")](inspect, options) {
        return inspect(inspectableError(this), options);
    }
}
function syntaxError(message) {
    const DomException = globalThis.DOMException;
    return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
function flattenError(err) {
    return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;
}
function inspectableError(err) {
    return {
        type: err.type,
        message: err.message,
        code: err.code,
        defaultPrevented: err.defaultPrevented,
        cancelable: err.cancelable,
        timeStamp: err.timeStamp
    };
}
var __typeError = (msg)=>{
    throw TypeError(msg);
}, __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError("Cannot " + msg), __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter)=>(__accessCheck(obj, member, "write to private field"), member.set(obj, value), value), __privateMethod = (obj, member, method)=>(__accessCheck(obj, member, "access private method"), method), _readyState, _url, _redirectUrl, _withCredentials, _fetch, _reconnectInterval, _reconnectTimer, _lastEventId, _controller, _parser, _onError, _onMessage, _onOpen, _EventSource_instances, connect_fn, _onFetchResponse, _onFetchError, getRequestOptions_fn, _onEvent, _onRetryChange, failConnection_fn, scheduleReconnect_fn, _reconnect;
class EventSource extends EventTarget {
    constructor(url, eventSourceInitDict){
        var _a, _b;
        super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response)=>{
            var _a2;
            __privateGet(this, _parser).reset();
            const { body, redirected, status, headers } = response;
            if (status === 204) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
                return;
            }
            if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
                return;
            }
            if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
                return;
            }
            if (__privateGet(this, _readyState) === this.CLOSED) return;
            __privateSet(this, _readyState, this.OPEN);
            const openEvent = new Event("open");
            if ((_a2 = __privateGet(this, _onOpen)) == null || _a2.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
                return;
            }
            const decoder = new TextDecoder(), reader = body.getReader();
            let open = !0;
            do {
                const { done, value } = await reader.read();
                value && __privateGet(this, _parser).feed(decoder.decode(value, {
                    stream: !done
                })), done && (open = !1, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
            }while (open)
        }), __privateAdd(this, _onFetchError, (err)=>{
            __privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));
        }), __privateAdd(this, _onEvent, (event)=>{
            typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
            const messageEvent = new MessageEvent(event.event || "message", {
                data: event.data,
                origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,
                lastEventId: event.id || ""
            });
            __privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
        }), __privateAdd(this, _onRetryChange, (value)=>{
            __privateSet(this, _reconnectInterval, value);
        }), __privateAdd(this, _reconnect, ()=>{
            __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
        });
        try {
            if (url instanceof URL) __privateSet(this, _url, url);
            else if (typeof url == "string") __privateSet(this, _url, new URL(url, getBaseURL()));
            else throw new Error("Invalid URL");
        } catch  {
            throw syntaxError("An invalid or illegal string was specified");
        }
        __privateSet(this, _parser, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createParser"])({
            onEvent: __privateGet(this, _onEvent),
            onRetry: __privateGet(this, _onRetryChange)
        })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : !1), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    }
    /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */ get readyState() {
        return __privateGet(this, _readyState);
    }
    /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */ get url() {
        return __privateGet(this, _url).href;
    }
    /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */ get withCredentials() {
        return __privateGet(this, _withCredentials);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */ get onerror() {
        return __privateGet(this, _onError);
    }
    set onerror(value) {
        __privateSet(this, _onError, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */ get onmessage() {
        return __privateGet(this, _onMessage);
    }
    set onmessage(value) {
        __privateSet(this, _onMessage, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */ get onopen() {
        return __privateGet(this, _onOpen);
    }
    set onopen(value) {
        __privateSet(this, _onOpen, value);
    }
    addEventListener(type, listener, options) {
        const listen = listener;
        super.addEventListener(type, listen, options);
    }
    removeEventListener(type, listener, options) {
        const listen = listener;
        super.removeEventListener(type, listen, options);
    }
    /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */ close() {
        __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
    }
}
_readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/ connect_fn = function() {
    __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/ getRequestOptions_fn = function() {
    var _a;
    const init = {
        // [spec] Let `corsAttributeState` be `Anonymous`…
        // [spec] …will have their mode set to "cors"…
        mode: "cors",
        redirect: "follow",
        headers: {
            Accept: "text/event-stream",
            ...__privateGet(this, _lastEventId) ? {
                "Last-Event-ID": __privateGet(this, _lastEventId)
            } : void 0
        },
        cache: "no-store",
        signal: (_a = __privateGet(this, _controller)) == null ? void 0 : _a.signal
    };
    return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ failConnection_fn = function(message, code) {
    var _a;
    __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ scheduleReconnect_fn = function(message, code) {
    var _a;
    if (__privateGet(this, _readyState) === this.CLOSED) return;
    __privateSet(this, _readyState, this.CONNECTING);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
}, _reconnect = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/ EventSource.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/ EventSource.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/ EventSource.CLOSED = 2;
function getBaseURL() {
    const doc = "document" in globalThis ? globalThis.document : void 0;
    return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/pkce-challenge/dist/index.node.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>pkceChallenge,
    "generateChallenge": ()=>generateChallenge,
    "verifyChallenge": ()=>verifyChallenge
});
let crypto;
crypto = globalThis.crypto?.webcrypto ?? // Node.js [18-16] REPL
globalThis.crypto ?? // Node.js >18
__turbopack_context__.r("[externals]/node:crypto [external] (node:crypto, cjs, async loader)")(__turbopack_context__.i).then((m)=>m.webcrypto); // Node.js <18 Non-REPL
/**
 * Creates an array of length `size` of random bytes
 * @param size
 * @returns Array of random ints (0 to 255)
 */ async function getRandomValues(size) {
    return (await crypto).getRandomValues(new Uint8Array(size));
}
/** Generate cryptographically strong random string
 * @param size The desired length of the string
 * @returns The random string
 */ async function random(size) {
    const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
    let result = "";
    const randomUints = await getRandomValues(size);
    for(let i = 0; i < size; i++){
        // cap the value of the randomIndex to mask.length - 1
        const randomIndex = randomUints[i] % mask.length;
        result += mask[randomIndex];
    }
    return result;
}
/** Generate a PKCE challenge verifier
 * @param length Length of the verifier
 * @returns A random verifier `length` characters long
 */ async function generateVerifier(length) {
    return await random(length);
}
async function generateChallenge(code_verifier) {
    const buffer = await (await crypto).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
    // Generate base64url string
    // btoa is deprecated in Node.js but is used here for web browser compatibility
    // (which has no good replacement yet, see also https://github.com/whatwg/html/issues/6811)
    return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, '_').replace(/\+/g, '-').replace(/=/g, '');
}
async function pkceChallenge(length) {
    if (!length) length = 43;
    if (length < 43 || length > 128) {
        throw `Expected a length between 43 and 128. Received ${length}.`;
    }
    const verifier = await generateVerifier(length);
    const challenge = await generateChallenge(verifier);
    return {
        code_verifier: verifier,
        code_challenge: challenge
    };
}
async function verifyChallenge(code_verifier, expectedChallenge) {
    const actualChallenge = await generateChallenge(code_verifier);
    return actualChallenge === expectedChallenge;
}
}),
"[project]/node_modules/isexe/mode.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = isexe;
isexe.sync = sync;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
    });
}
function sync(path, options) {
    return checkStat(fs.statSync(path), options);
}
function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
}
function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt('100', 8);
    var g = parseInt('010', 8);
    var o = parseInt('001', 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
}
}}),
"[project]/node_modules/isexe/windows.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = isexe;
isexe.sync = sync;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
        return true;
    }
    pathext = pathext.split(';');
    if (pathext.indexOf('') !== -1) {
        return true;
    }
    for(var i = 0; i < pathext.length; i++){
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
            return true;
        }
    }
    return false;
}
function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
    }
    return checkPathExt(path, options);
}
function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
    });
}
function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
}
}}),
"[project]/node_modules/isexe/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var core;
if (process.platform === 'win32' || ("TURBOPACK ident replacement", globalThis).TESTING_WINDOWS) {
    core = __turbopack_context__.r("[project]/node_modules/isexe/windows.js [app-route] (ecmascript)");
} else {
    core = __turbopack_context__.r("[project]/node_modules/isexe/mode.js [app-route] (ecmascript)");
}
module.exports = isexe;
isexe.sync = sync;
function isexe(path, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = {};
    }
    if (!cb) {
        if (typeof Promise !== 'function') {
            throw new TypeError('callback not provided');
        }
        return new Promise(function(resolve, reject) {
            isexe(path, options || {}, function(er, is) {
                if (er) {
                    reject(er);
                } else {
                    resolve(is);
                }
            });
        });
    }
    core(path, options || {}, function(er, is) {
        // ignore EACCES because that just means we aren't allowed to run it
        if (er) {
            if (er.code === 'EACCES' || options && options.ignoreErrors) {
                er = null;
                is = false;
            }
        }
        cb(er, is);
    });
}
function sync(path, options) {
    // my kingdom for a filtered catch
    try {
        return core.sync(path, options || {});
    } catch (er) {
        if (options && options.ignoreErrors || er.code === 'EACCES') {
            return false;
        } else {
            throw er;
        }
    }
}
}}),
"[project]/node_modules/which/which.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const COLON = isWindows ? ';' : ':';
const isexe = __turbopack_context__.r("[project]/node_modules/isexe/index.js [app-route] (ecmascript)");
const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
        code: 'ENOENT'
    });
const getPathInfo = (cmd, opt)=>{
    const colon = opt.colon || COLON;
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
        ''
    ] : [
        // windows always checks the cwd first
        ...isWindows ? [
            process.cwd()
        ] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */ '').split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';
    const pathExt = isWindows ? pathExtExe.split(colon) : [
        ''
    ];
    if (isWindows) {
        if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
    }
    return {
        pathEnv,
        pathExt,
        pathExtExe
    };
};
const which = (cmd, opt, cb)=>{
    if (typeof opt === 'function') {
        cb = opt;
        opt = {};
    }
    if (!opt) opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i)=>new Promise((resolve, reject)=>{
            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
        });
    const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
            if (ii === pathExt.length) return resolve(step(i + 1));
            const ext = pathExt[ii];
            isexe(p + ext, {
                pathExt: pathExtExe
            }, (er, is)=>{
                if (!er && is) {
                    if (opt.all) found.push(p + ext);
                    else return resolve(p + ext);
                }
                return resolve(subStep(p, i, ii + 1));
            });
        });
    return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
};
const whichSync = (cmd, opt)=>{
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for(let i = 0; i < pathEnv.length; i++){
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for(let j = 0; j < pathExt.length; j++){
            const cur = p + pathExt[j];
            try {
                const is = isexe.sync(cur, {
                    pathExt: pathExtExe
                });
                if (is) {
                    if (opt.all) found.push(cur);
                    else return cur;
                }
            } catch (ex) {}
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
};
module.exports = which;
which.sync = whichSync;
}}),
"[project]/node_modules/path-key/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const pathKey = (options = {})=>{
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== 'win32') {
        return 'PATH';
    }
    return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';
};
module.exports = pathKey;
// TODO: Remove this for the next major release
module.exports.default = pathKey;
}}),
"[project]/node_modules/cross-spawn/lib/util/resolveCommand.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const which = __turbopack_context__.r("[project]/node_modules/which/which.js [app-route] (ecmascript)");
const getPathKey = __turbopack_context__.r("[project]/node_modules/path-key/index.js [app-route] (ecmascript)");
function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
        /* Empty */ }
    }
    let resolved;
    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({
                env
            })],
            pathExt: withoutPathExt ? path.delimiter : undefined
        });
    } catch (e) {
    /* Empty */ } finally{
        if (shouldSwitchCwd) {
            process.chdir(cwd);
        }
    }
    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }
    return resolved;
}
function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
module.exports = resolveCommand;
}}),
"[project]/node_modules/cross-spawn/lib/util/escape.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');
    return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;
    // Algorithm below is based on https://qntm.org/cmd
    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input
    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information
    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(?=(\\+?)?)\1$/, '$1$1');
    // All other backslashes occur literally
    // Quote the whole thing:
    arg = `"${arg}"`;
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');
    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }
    return arg;
}
module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;
}}),
"[project]/node_modules/cross-spawn/lib/util/readShebang.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const shebangCommand = __turbopack_context__.r("[project]/node_modules/shebang-command/index.js [app-route] (ecmascript)");
function readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) {}
    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}
module.exports = readShebang;
}}),
"[project]/node_modules/cross-spawn/lib/parse.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const resolveCommand = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/util/resolveCommand.js [app-route] (ecmascript)");
const escape = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/util/escape.js [app-route] (ecmascript)");
const readShebang = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/util/readShebang.js [app-route] (ecmascript)");
const isWin = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
    }
    return parsed.file;
}
function parseNonShell(parsed) {
    if ("TURBOPACK compile-time truthy", 1) {
        return parsed;
    }
    //TURBOPACK unreachable
    ;
    // Detect & add support for shebangs
    const commandFile = undefined;
    // We don't need a shell if the command filename is an executable
    const needsShell = undefined;
}
function parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }
    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original
    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args
        }
    };
    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}
module.exports = parse;
}}),
"[project]/node_modules/cross-spawn/lib/enoent.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const isWin = process.platform === 'win32';
function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
    });
}
function hookChildProcess(cp, parsed) {
    if ("TURBOPACK compile-time truthy", 1) {
        return;
    }
    //TURBOPACK unreachable
    ;
    const originalEmit = undefined;
}
function verifyENOENT(status, parsed) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return null;
}
function verifyENOENTSync(status, parsed) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return null;
}
module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
};
}}),
"[project]/node_modules/cross-spawn/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const cp = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
const parse = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/parse.js [app-route] (ecmascript)");
const enoent = __turbopack_context__.r("[project]/node_modules/cross-spawn/lib/enoent.js [app-route] (ecmascript)");
function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);
    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
}
function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);
    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
}
module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;
module.exports._parse = parse;
module.exports._enoent = enoent;
}}),
"[project]/node_modules/shebang-regex/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = /^#!(.*)/;
}}),
"[project]/node_modules/shebang-command/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
const shebangRegex = __turbopack_context__.r("[project]/node_modules/shebang-regex/index.js [app-route] (ecmascript)");
module.exports = (string = '')=>{
    const match = string.match(shebangRegex);
    if (!match) {
        return null;
    }
    const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
    const binary = path.split('/').pop();
    if (binary === 'env') {
        return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
};
}}),
"[project]/node_modules/exit-hook/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "asyncExitHook": ()=>asyncExitHook,
    "default": ()=>exitHook,
    "gracefulExit": ()=>gracefulExit
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
;
const asyncCallbacks = new Set();
const callbacks = new Set();
let isCalled = false;
let isRegistered = false;
async function exit(shouldManuallyExit, isSynchronous, signal) {
    if (isCalled) {
        return;
    }
    isCalled = true;
    if (asyncCallbacks.size > 0 && isSynchronous) {
        console.error([
            'SYNCHRONOUS TERMINATION NOTICE:',
            'When explicitly exiting the process via process.exit or via a parent process,',
            'asynchronous tasks in your exitHooks will not run. Either remove these tasks,',
            'use gracefulExit() instead of process.exit(), or ensure your parent process',
            'sends a SIGINT to the process running this code.'
        ].join(' '));
    }
    const exitCode = 128 + signal;
    const done = (force = false)=>{
        if (force === true || shouldManuallyExit === true) {
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].exit(exitCode); // eslint-disable-line unicorn/no-process-exit
        }
    };
    for (const callback of callbacks){
        callback(exitCode);
    }
    if (isSynchronous) {
        done();
        return;
    }
    const promises = [];
    let forceAfter = 0;
    for (const [callback, wait] of asyncCallbacks){
        forceAfter = Math.max(forceAfter, wait);
        promises.push(Promise.resolve(callback(exitCode)));
    }
    // Force exit if we exceeded our wait value
    const asyncTimer = setTimeout(()=>{
        done(true);
    }, forceAfter);
    await Promise.all(promises);
    clearTimeout(asyncTimer);
    done();
}
function addHook(options) {
    const { onExit, wait, isSynchronous } = options;
    const asyncCallbackConfig = [
        onExit,
        wait
    ];
    if (isSynchronous) {
        callbacks.add(onExit);
    } else {
        asyncCallbacks.add(asyncCallbackConfig);
    }
    if (!isRegistered) {
        isRegistered = true;
        // Exit cases that support asynchronous handling
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].once('beforeExit', exit.bind(undefined, true, false, -128));
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].once('SIGINT', exit.bind(undefined, true, false, 2));
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].once('SIGTERM', exit.bind(undefined, true, false, 15));
        // Explicit exit events. Calling will force an immediate exit and run all
        // synchronous hooks. Explicit exits must not extend the node process
        // artificially. Will log errors if asynchronous calls exist.
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].once('exit', exit.bind(undefined, false, true, 0));
        // PM2 Cluster shutdown message. Caught to support async handlers with pm2,
        // needed because explicitly calling process.exit() doesn't trigger the
        // beforeExit event, and the exit event cannot support async handlers,
        // since the event loop is never called after it.
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].on('message', (message)=>{
            if (message === 'shutdown') {
                exit(true, true, -128);
            }
        });
    }
    return ()=>{
        if (isSynchronous) {
            callbacks.delete(onExit);
        } else {
            asyncCallbacks.delete(asyncCallbackConfig);
        }
    };
}
function exitHook(onExit) {
    if (typeof onExit !== 'function') {
        throw new TypeError('onExit must be a function');
    }
    return addHook({
        onExit,
        isSynchronous: true
    });
}
function asyncExitHook(onExit, options = {}) {
    if (typeof onExit !== 'function') {
        throw new TypeError('onExit must be a function');
    }
    if (!(typeof options.wait === 'number' && options.wait > 0)) {
        throw new TypeError('wait must be set to a positive numeric value');
    }
    return addHook({
        onExit,
        wait: options.wait,
        isSynchronous: false
    });
}
function gracefulExit(signal = 0) {
    exit(true, false, -128 + signal);
}
}),
"[project]/node_modules/uuid/dist/esm/sha1.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
function sha1(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
    }
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHash"])('sha1').update(bytes).digest();
}
const __TURBOPACK__default__export__ = sha1;
}),
"[project]/node_modules/uuid/dist/esm/regex.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
}),
"[project]/node_modules/uuid/dist/esm/validate.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/regex.js [app-route] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}),
"[project]/node_modules/uuid/dist/esm/parse.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/validate.js [app-route] (ecmascript)");
;
function parse(uuid) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Invalid UUID');
    }
    let v;
    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff, v / 0x100000000 & 0xff, v >>> 24 & 0xff, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff);
}
const __TURBOPACK__default__export__ = parse;
}),
"[project]/node_modules/uuid/dist/esm/stringify.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__,
    "unsafeStringify": ()=>unsafeStringify
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/validate.js [app-route] (ecmascript)");
;
const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}),
"[project]/node_modules/uuid/dist/esm/v35.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "DNS": ()=>DNS,
    "URL": ()=>URL,
    "default": ()=>v35,
    "stringToBytes": ()=>stringToBytes
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/parse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/stringify.js [app-route] (ecmascript)");
;
;
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = new Uint8Array(str.length);
    for(let i = 0; i < str.length; ++i){
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(version, hash, value, namespace, buf, offset) {
    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;
    const namespaceBytes = typeof namespace === 'string' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(namespace) : namespace;
    if (typeof namespace === 'string') {
        namespace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(namespace);
    }
    if (namespace?.length !== 16) {
        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    }
    let bytes = new Uint8Array(16 + valueBytes.length);
    bytes.set(namespaceBytes);
    bytes.set(valueBytes, namespaceBytes.length);
    bytes = hash(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = bytes[i];
        }
        return buf;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["unsafeStringify"])(bytes);
}
}),
"[project]/node_modules/uuid/dist/esm/v5.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$sha1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/sha1.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/v35.js [app-route] (ecmascript)");
;
;
;
function v5(value, namespace, buf, offset) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(0x50, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$sha1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"], value, namespace, buf, offset);
}
v5.DNS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DNS"];
v5.URL = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["URL"];
const __TURBOPACK__default__export__ = v5;
}),
"[project]/node_modules/uuid/dist/esm/v5.js [app-route] (ecmascript) <locals> <export default as v5>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "v5": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/v5.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/escape-string-regexp/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>escapeStringRegexp
});
function escapeStringRegexp(string) {
    if (typeof string !== 'string') {
        throw new TypeError('Expected a string');
    }
    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
}),
"[project]/node_modules/@sindresorhus/transliterate/replacements.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
const replacements = [
    // German umlauts
    [
        'ß',
        'ss'
    ],
    [
        'ẞ',
        'Ss'
    ],
    [
        'ä',
        'ae'
    ],
    [
        'Ä',
        'Ae'
    ],
    [
        'ö',
        'oe'
    ],
    [
        'Ö',
        'Oe'
    ],
    [
        'ü',
        'ue'
    ],
    [
        'Ü',
        'Ue'
    ],
    // Latin
    [
        'À',
        'A'
    ],
    [
        'Á',
        'A'
    ],
    [
        'Â',
        'A'
    ],
    [
        'Ã',
        'A'
    ],
    [
        'Ä',
        'Ae'
    ],
    [
        'Å',
        'A'
    ],
    [
        'Æ',
        'AE'
    ],
    [
        'Ç',
        'C'
    ],
    [
        'È',
        'E'
    ],
    [
        'É',
        'E'
    ],
    [
        'Ê',
        'E'
    ],
    [
        'Ë',
        'E'
    ],
    [
        'Ì',
        'I'
    ],
    [
        'Í',
        'I'
    ],
    [
        'Î',
        'I'
    ],
    [
        'Ï',
        'I'
    ],
    [
        'Ð',
        'D'
    ],
    [
        'Ñ',
        'N'
    ],
    [
        'Ò',
        'O'
    ],
    [
        'Ó',
        'O'
    ],
    [
        'Ô',
        'O'
    ],
    [
        'Õ',
        'O'
    ],
    [
        'Ö',
        'Oe'
    ],
    [
        'Ő',
        'O'
    ],
    [
        'Ø',
        'O'
    ],
    [
        'Ù',
        'U'
    ],
    [
        'Ú',
        'U'
    ],
    [
        'Û',
        'U'
    ],
    [
        'Ü',
        'Ue'
    ],
    [
        'Ű',
        'U'
    ],
    [
        'Ý',
        'Y'
    ],
    [
        'Þ',
        'TH'
    ],
    [
        'ß',
        'ss'
    ],
    [
        'à',
        'a'
    ],
    [
        'á',
        'a'
    ],
    [
        'â',
        'a'
    ],
    [
        'ã',
        'a'
    ],
    [
        'ä',
        'ae'
    ],
    [
        'å',
        'a'
    ],
    [
        'æ',
        'ae'
    ],
    [
        'ç',
        'c'
    ],
    [
        'è',
        'e'
    ],
    [
        'é',
        'e'
    ],
    [
        'ê',
        'e'
    ],
    [
        'ë',
        'e'
    ],
    [
        'ì',
        'i'
    ],
    [
        'í',
        'i'
    ],
    [
        'î',
        'i'
    ],
    [
        'ï',
        'i'
    ],
    [
        'ð',
        'd'
    ],
    [
        'ñ',
        'n'
    ],
    [
        'ò',
        'o'
    ],
    [
        'ó',
        'o'
    ],
    [
        'ô',
        'o'
    ],
    [
        'õ',
        'o'
    ],
    [
        'ö',
        'oe'
    ],
    [
        'ő',
        'o'
    ],
    [
        'ø',
        'o'
    ],
    [
        'ù',
        'u'
    ],
    [
        'ú',
        'u'
    ],
    [
        'û',
        'u'
    ],
    [
        'ü',
        'ue'
    ],
    [
        'ű',
        'u'
    ],
    [
        'ý',
        'y'
    ],
    [
        'þ',
        'th'
    ],
    [
        'ÿ',
        'y'
    ],
    [
        'ẞ',
        'SS'
    ],
    // Vietnamese
    [
        'à',
        'a'
    ],
    [
        'À',
        'A'
    ],
    [
        'á',
        'a'
    ],
    [
        'Á',
        'A'
    ],
    [
        'â',
        'a'
    ],
    [
        'Â',
        'A'
    ],
    [
        'ã',
        'a'
    ],
    [
        'Ã',
        'A'
    ],
    [
        'è',
        'e'
    ],
    [
        'È',
        'E'
    ],
    [
        'é',
        'e'
    ],
    [
        'É',
        'E'
    ],
    [
        'ê',
        'e'
    ],
    [
        'Ê',
        'E'
    ],
    [
        'ì',
        'i'
    ],
    [
        'Ì',
        'I'
    ],
    [
        'í',
        'i'
    ],
    [
        'Í',
        'I'
    ],
    [
        'ò',
        'o'
    ],
    [
        'Ò',
        'O'
    ],
    [
        'ó',
        'o'
    ],
    [
        'Ó',
        'O'
    ],
    [
        'ô',
        'o'
    ],
    [
        'Ô',
        'O'
    ],
    [
        'õ',
        'o'
    ],
    [
        'Õ',
        'O'
    ],
    [
        'ù',
        'u'
    ],
    [
        'Ù',
        'U'
    ],
    [
        'ú',
        'u'
    ],
    [
        'Ú',
        'U'
    ],
    [
        'ý',
        'y'
    ],
    [
        'Ý',
        'Y'
    ],
    [
        'ă',
        'a'
    ],
    [
        'Ă',
        'A'
    ],
    [
        'Đ',
        'D'
    ],
    [
        'đ',
        'd'
    ],
    [
        'ĩ',
        'i'
    ],
    [
        'Ĩ',
        'I'
    ],
    [
        'ũ',
        'u'
    ],
    [
        'Ũ',
        'U'
    ],
    [
        'ơ',
        'o'
    ],
    [
        'Ơ',
        'O'
    ],
    [
        'ư',
        'u'
    ],
    [
        'Ư',
        'U'
    ],
    [
        'ạ',
        'a'
    ],
    [
        'Ạ',
        'A'
    ],
    [
        'ả',
        'a'
    ],
    [
        'Ả',
        'A'
    ],
    [
        'ấ',
        'a'
    ],
    [
        'Ấ',
        'A'
    ],
    [
        'ầ',
        'a'
    ],
    [
        'Ầ',
        'A'
    ],
    [
        'ẩ',
        'a'
    ],
    [
        'Ẩ',
        'A'
    ],
    [
        'ẫ',
        'a'
    ],
    [
        'Ẫ',
        'A'
    ],
    [
        'ậ',
        'a'
    ],
    [
        'Ậ',
        'A'
    ],
    [
        'ắ',
        'a'
    ],
    [
        'Ắ',
        'A'
    ],
    [
        'ằ',
        'a'
    ],
    [
        'Ằ',
        'A'
    ],
    [
        'ẳ',
        'a'
    ],
    [
        'Ẳ',
        'A'
    ],
    [
        'ẵ',
        'a'
    ],
    [
        'Ẵ',
        'A'
    ],
    [
        'ặ',
        'a'
    ],
    [
        'Ặ',
        'A'
    ],
    [
        'ẹ',
        'e'
    ],
    [
        'Ẹ',
        'E'
    ],
    [
        'ẻ',
        'e'
    ],
    [
        'Ẻ',
        'E'
    ],
    [
        'ẽ',
        'e'
    ],
    [
        'Ẽ',
        'E'
    ],
    [
        'ế',
        'e'
    ],
    [
        'Ế',
        'E'
    ],
    [
        'ề',
        'e'
    ],
    [
        'Ề',
        'E'
    ],
    [
        'ể',
        'e'
    ],
    [
        'Ể',
        'E'
    ],
    [
        'ễ',
        'e'
    ],
    [
        'Ễ',
        'E'
    ],
    [
        'ệ',
        'e'
    ],
    [
        'Ệ',
        'E'
    ],
    [
        'ỉ',
        'i'
    ],
    [
        'Ỉ',
        'I'
    ],
    [
        'ị',
        'i'
    ],
    [
        'Ị',
        'I'
    ],
    [
        'ọ',
        'o'
    ],
    [
        'Ọ',
        'O'
    ],
    [
        'ỏ',
        'o'
    ],
    [
        'Ỏ',
        'O'
    ],
    [
        'ố',
        'o'
    ],
    [
        'Ố',
        'O'
    ],
    [
        'ồ',
        'o'
    ],
    [
        'Ồ',
        'O'
    ],
    [
        'ổ',
        'o'
    ],
    [
        'Ổ',
        'O'
    ],
    [
        'ỗ',
        'o'
    ],
    [
        'Ỗ',
        'O'
    ],
    [
        'ộ',
        'o'
    ],
    [
        'Ộ',
        'O'
    ],
    [
        'ớ',
        'o'
    ],
    [
        'Ớ',
        'O'
    ],
    [
        'ờ',
        'o'
    ],
    [
        'Ờ',
        'O'
    ],
    [
        'ở',
        'o'
    ],
    [
        'Ở',
        'O'
    ],
    [
        'ỡ',
        'o'
    ],
    [
        'Ỡ',
        'O'
    ],
    [
        'ợ',
        'o'
    ],
    [
        'Ợ',
        'O'
    ],
    [
        'ụ',
        'u'
    ],
    [
        'Ụ',
        'U'
    ],
    [
        'ủ',
        'u'
    ],
    [
        'Ủ',
        'U'
    ],
    [
        'ứ',
        'u'
    ],
    [
        'Ứ',
        'U'
    ],
    [
        'ừ',
        'u'
    ],
    [
        'Ừ',
        'U'
    ],
    [
        'ử',
        'u'
    ],
    [
        'Ử',
        'U'
    ],
    [
        'ữ',
        'u'
    ],
    [
        'Ữ',
        'U'
    ],
    [
        'ự',
        'u'
    ],
    [
        'Ự',
        'U'
    ],
    [
        'ỳ',
        'y'
    ],
    [
        'Ỳ',
        'Y'
    ],
    [
        'ỵ',
        'y'
    ],
    [
        'Ỵ',
        'Y'
    ],
    [
        'ỷ',
        'y'
    ],
    [
        'Ỷ',
        'Y'
    ],
    [
        'ỹ',
        'y'
    ],
    [
        'Ỹ',
        'Y'
    ],
    // Arabic
    [
        'ء',
        'e'
    ],
    [
        'آ',
        'a'
    ],
    [
        'أ',
        'a'
    ],
    [
        'ؤ',
        'w'
    ],
    [
        'إ',
        'i'
    ],
    [
        'ئ',
        'y'
    ],
    [
        'ا',
        'a'
    ],
    [
        'ب',
        'b'
    ],
    [
        'ة',
        't'
    ],
    [
        'ت',
        't'
    ],
    [
        'ث',
        'th'
    ],
    [
        'ج',
        'j'
    ],
    [
        'ح',
        'h'
    ],
    [
        'خ',
        'kh'
    ],
    [
        'د',
        'd'
    ],
    [
        'ذ',
        'dh'
    ],
    [
        'ر',
        'r'
    ],
    [
        'ز',
        'z'
    ],
    [
        'س',
        's'
    ],
    [
        'ش',
        'sh'
    ],
    [
        'ص',
        's'
    ],
    [
        'ض',
        'd'
    ],
    [
        'ط',
        't'
    ],
    [
        'ظ',
        'z'
    ],
    [
        'ع',
        'e'
    ],
    [
        'غ',
        'gh'
    ],
    [
        'ـ',
        '_'
    ],
    [
        'ف',
        'f'
    ],
    [
        'ق',
        'q'
    ],
    [
        'ك',
        'k'
    ],
    [
        'ل',
        'l'
    ],
    [
        'م',
        'm'
    ],
    [
        'ن',
        'n'
    ],
    [
        'ه',
        'h'
    ],
    [
        'و',
        'w'
    ],
    [
        'ى',
        'a'
    ],
    [
        'ي',
        'y'
    ],
    [
        'َ‎',
        'a'
    ],
    [
        'ُ',
        'u'
    ],
    [
        'ِ‎',
        'i'
    ],
    [
        '٠',
        '0'
    ],
    [
        '١',
        '1'
    ],
    [
        '٢',
        '2'
    ],
    [
        '٣',
        '3'
    ],
    [
        '٤',
        '4'
    ],
    [
        '٥',
        '5'
    ],
    [
        '٦',
        '6'
    ],
    [
        '٧',
        '7'
    ],
    [
        '٨',
        '8'
    ],
    [
        '٩',
        '9'
    ],
    // Persian / Farsi
    [
        'چ',
        'ch'
    ],
    [
        'ک',
        'k'
    ],
    [
        'گ',
        'g'
    ],
    [
        'پ',
        'p'
    ],
    [
        'ژ',
        'zh'
    ],
    [
        'ی',
        'y'
    ],
    [
        '۰',
        '0'
    ],
    [
        '۱',
        '1'
    ],
    [
        '۲',
        '2'
    ],
    [
        '۳',
        '3'
    ],
    [
        '۴',
        '4'
    ],
    [
        '۵',
        '5'
    ],
    [
        '۶',
        '6'
    ],
    [
        '۷',
        '7'
    ],
    [
        '۸',
        '8'
    ],
    [
        '۹',
        '9'
    ],
    // Pashto
    [
        'ټ',
        'p'
    ],
    [
        'ځ',
        'z'
    ],
    [
        'څ',
        'c'
    ],
    [
        'ډ',
        'd'
    ],
    [
        'ﺫ',
        'd'
    ],
    [
        'ﺭ',
        'r'
    ],
    [
        'ړ',
        'r'
    ],
    [
        'ﺯ',
        'z'
    ],
    [
        'ږ',
        'g'
    ],
    [
        'ښ',
        'x'
    ],
    [
        'ګ',
        'g'
    ],
    [
        'ڼ',
        'n'
    ],
    [
        'ۀ',
        'e'
    ],
    [
        'ې',
        'e'
    ],
    [
        'ۍ',
        'ai'
    ],
    // Urdu
    [
        'ٹ',
        't'
    ],
    [
        'ڈ',
        'd'
    ],
    [
        'ڑ',
        'r'
    ],
    [
        'ں',
        'n'
    ],
    [
        'ہ',
        'h'
    ],
    [
        'ھ',
        'h'
    ],
    [
        'ے',
        'e'
    ],
    // Russian
    [
        'А',
        'A'
    ],
    [
        'а',
        'a'
    ],
    [
        'Б',
        'B'
    ],
    [
        'б',
        'b'
    ],
    [
        'В',
        'V'
    ],
    [
        'в',
        'v'
    ],
    [
        'Г',
        'G'
    ],
    [
        'г',
        'g'
    ],
    [
        'Д',
        'D'
    ],
    [
        'д',
        'd'
    ],
    [
        'ъе',
        'ye'
    ],
    [
        'Ъе',
        'Ye'
    ],
    [
        'ъЕ',
        'yE'
    ],
    [
        'ЪЕ',
        'YE'
    ],
    [
        'Е',
        'E'
    ],
    [
        'е',
        'e'
    ],
    [
        'Ё',
        'Yo'
    ],
    [
        'ё',
        'yo'
    ],
    [
        'Ж',
        'Zh'
    ],
    [
        'ж',
        'zh'
    ],
    [
        'З',
        'Z'
    ],
    [
        'з',
        'z'
    ],
    [
        'И',
        'I'
    ],
    [
        'и',
        'i'
    ],
    [
        'ый',
        'iy'
    ],
    [
        'Ый',
        'Iy'
    ],
    [
        'ЫЙ',
        'IY'
    ],
    [
        'ыЙ',
        'iY'
    ],
    [
        'Й',
        'Y'
    ],
    [
        'й',
        'y'
    ],
    [
        'К',
        'K'
    ],
    [
        'к',
        'k'
    ],
    [
        'Л',
        'L'
    ],
    [
        'л',
        'l'
    ],
    [
        'М',
        'M'
    ],
    [
        'м',
        'm'
    ],
    [
        'Н',
        'N'
    ],
    [
        'н',
        'n'
    ],
    [
        'О',
        'O'
    ],
    [
        'о',
        'o'
    ],
    [
        'П',
        'P'
    ],
    [
        'п',
        'p'
    ],
    [
        'Р',
        'R'
    ],
    [
        'р',
        'r'
    ],
    [
        'С',
        'S'
    ],
    [
        'с',
        's'
    ],
    [
        'Т',
        'T'
    ],
    [
        'т',
        't'
    ],
    [
        'У',
        'U'
    ],
    [
        'у',
        'u'
    ],
    [
        'Ф',
        'F'
    ],
    [
        'ф',
        'f'
    ],
    [
        'Х',
        'Kh'
    ],
    [
        'х',
        'kh'
    ],
    [
        'Ц',
        'Ts'
    ],
    [
        'ц',
        'ts'
    ],
    [
        'Ч',
        'Ch'
    ],
    [
        'ч',
        'ch'
    ],
    [
        'Ш',
        'Sh'
    ],
    [
        'ш',
        'sh'
    ],
    [
        'Щ',
        'Sch'
    ],
    [
        'щ',
        'sch'
    ],
    [
        'Ъ',
        ''
    ],
    [
        'ъ',
        ''
    ],
    [
        'Ы',
        'Y'
    ],
    [
        'ы',
        'y'
    ],
    [
        'Ь',
        ''
    ],
    [
        'ь',
        ''
    ],
    [
        'Э',
        'E'
    ],
    [
        'э',
        'e'
    ],
    [
        'Ю',
        'Yu'
    ],
    [
        'ю',
        'yu'
    ],
    [
        'Я',
        'Ya'
    ],
    [
        'я',
        'ya'
    ],
    // Romanian
    [
        'ă',
        'a'
    ],
    [
        'Ă',
        'A'
    ],
    [
        'ș',
        's'
    ],
    [
        'Ș',
        'S'
    ],
    [
        'ț',
        't'
    ],
    [
        'Ț',
        'T'
    ],
    [
        'ţ',
        't'
    ],
    [
        'Ţ',
        'T'
    ],
    // Turkish
    [
        'ş',
        's'
    ],
    [
        'Ş',
        'S'
    ],
    [
        'ç',
        'c'
    ],
    [
        'Ç',
        'C'
    ],
    [
        'ğ',
        'g'
    ],
    [
        'Ğ',
        'G'
    ],
    [
        'ı',
        'i'
    ],
    [
        'İ',
        'I'
    ],
    // Armenian
    [
        'ա',
        'a'
    ],
    [
        'Ա',
        'A'
    ],
    [
        'բ',
        'b'
    ],
    [
        'Բ',
        'B'
    ],
    [
        'գ',
        'g'
    ],
    [
        'Գ',
        'G'
    ],
    [
        'դ',
        'd'
    ],
    [
        'Դ',
        'D'
    ],
    [
        'ե',
        'ye'
    ],
    [
        'Ե',
        'Ye'
    ],
    [
        'զ',
        'z'
    ],
    [
        'Զ',
        'Z'
    ],
    [
        'է',
        'e'
    ],
    [
        'Է',
        'E'
    ],
    [
        'ը',
        'y'
    ],
    [
        'Ը',
        'Y'
    ],
    [
        'թ',
        't'
    ],
    [
        'Թ',
        'T'
    ],
    [
        'ժ',
        'zh'
    ],
    [
        'Ժ',
        'Zh'
    ],
    [
        'ի',
        'i'
    ],
    [
        'Ի',
        'I'
    ],
    [
        'լ',
        'l'
    ],
    [
        'Լ',
        'L'
    ],
    [
        'խ',
        'kh'
    ],
    [
        'Խ',
        'Kh'
    ],
    [
        'ծ',
        'ts'
    ],
    [
        'Ծ',
        'Ts'
    ],
    [
        'կ',
        'k'
    ],
    [
        'Կ',
        'K'
    ],
    [
        'հ',
        'h'
    ],
    [
        'Հ',
        'H'
    ],
    [
        'ձ',
        'dz'
    ],
    [
        'Ձ',
        'Dz'
    ],
    [
        'ղ',
        'gh'
    ],
    [
        'Ղ',
        'Gh'
    ],
    [
        'ճ',
        'tch'
    ],
    [
        'Ճ',
        'Tch'
    ],
    [
        'մ',
        'm'
    ],
    [
        'Մ',
        'M'
    ],
    [
        'յ',
        'y'
    ],
    [
        'Յ',
        'Y'
    ],
    [
        'ն',
        'n'
    ],
    [
        'Ն',
        'N'
    ],
    [
        'շ',
        'sh'
    ],
    [
        'Շ',
        'Sh'
    ],
    [
        'ո',
        'vo'
    ],
    [
        'Ո',
        'Vo'
    ],
    [
        'չ',
        'ch'
    ],
    [
        'Չ',
        'Ch'
    ],
    [
        'պ',
        'p'
    ],
    [
        'Պ',
        'P'
    ],
    [
        'ջ',
        'j'
    ],
    [
        'Ջ',
        'J'
    ],
    [
        'ռ',
        'r'
    ],
    [
        'Ռ',
        'R'
    ],
    [
        'ս',
        's'
    ],
    [
        'Ս',
        'S'
    ],
    [
        'վ',
        'v'
    ],
    [
        'Վ',
        'V'
    ],
    [
        'տ',
        't'
    ],
    [
        'Տ',
        'T'
    ],
    [
        'ր',
        'r'
    ],
    [
        'Ր',
        'R'
    ],
    [
        'ց',
        'c'
    ],
    [
        'Ց',
        'C'
    ],
    [
        'ու',
        'u'
    ],
    [
        'ՈՒ',
        'U'
    ],
    [
        'Ու',
        'U'
    ],
    [
        'փ',
        'p'
    ],
    [
        'Փ',
        'P'
    ],
    [
        'ք',
        'q'
    ],
    [
        'Ք',
        'Q'
    ],
    [
        'օ',
        'o'
    ],
    [
        'Օ',
        'O'
    ],
    [
        'ֆ',
        'f'
    ],
    [
        'Ֆ',
        'F'
    ],
    [
        'և',
        'yev'
    ],
    // Georgian
    [
        'ა',
        'a'
    ],
    [
        'ბ',
        'b'
    ],
    [
        'გ',
        'g'
    ],
    [
        'დ',
        'd'
    ],
    [
        'ე',
        'e'
    ],
    [
        'ვ',
        'v'
    ],
    [
        'ზ',
        'z'
    ],
    [
        'თ',
        't'
    ],
    [
        'ი',
        'i'
    ],
    [
        'კ',
        'k'
    ],
    [
        'ლ',
        'l'
    ],
    [
        'მ',
        'm'
    ],
    [
        'ნ',
        'n'
    ],
    [
        'ო',
        'o'
    ],
    [
        'პ',
        'p'
    ],
    [
        'ჟ',
        'zh'
    ],
    [
        'რ',
        'r'
    ],
    [
        'ს',
        's'
    ],
    [
        'ტ',
        't'
    ],
    [
        'უ',
        'u'
    ],
    [
        'ფ',
        'ph'
    ],
    [
        'ქ',
        'q'
    ],
    [
        'ღ',
        'gh'
    ],
    [
        'ყ',
        'k'
    ],
    [
        'შ',
        'sh'
    ],
    [
        'ჩ',
        'ch'
    ],
    [
        'ც',
        'ts'
    ],
    [
        'ძ',
        'dz'
    ],
    [
        'წ',
        'ts'
    ],
    [
        'ჭ',
        'tch'
    ],
    [
        'ხ',
        'kh'
    ],
    [
        'ჯ',
        'j'
    ],
    [
        'ჰ',
        'h'
    ],
    // Czech
    [
        'č',
        'c'
    ],
    [
        'ď',
        'd'
    ],
    [
        'ě',
        'e'
    ],
    [
        'ň',
        'n'
    ],
    [
        'ř',
        'r'
    ],
    [
        'š',
        's'
    ],
    [
        'ť',
        't'
    ],
    [
        'ů',
        'u'
    ],
    [
        'ž',
        'z'
    ],
    [
        'Č',
        'C'
    ],
    [
        'Ď',
        'D'
    ],
    [
        'Ě',
        'E'
    ],
    [
        'Ň',
        'N'
    ],
    [
        'Ř',
        'R'
    ],
    [
        'Š',
        'S'
    ],
    [
        'Ť',
        'T'
    ],
    [
        'Ů',
        'U'
    ],
    [
        'Ž',
        'Z'
    ],
    // Dhivehi
    [
        'ހ',
        'h'
    ],
    [
        'ށ',
        'sh'
    ],
    [
        'ނ',
        'n'
    ],
    [
        'ރ',
        'r'
    ],
    [
        'ބ',
        'b'
    ],
    [
        'ޅ',
        'lh'
    ],
    [
        'ކ',
        'k'
    ],
    [
        'އ',
        'a'
    ],
    [
        'ވ',
        'v'
    ],
    [
        'މ',
        'm'
    ],
    [
        'ފ',
        'f'
    ],
    [
        'ދ',
        'dh'
    ],
    [
        'ތ',
        'th'
    ],
    [
        'ލ',
        'l'
    ],
    [
        'ގ',
        'g'
    ],
    [
        'ޏ',
        'gn'
    ],
    [
        'ސ',
        's'
    ],
    [
        'ޑ',
        'd'
    ],
    [
        'ޒ',
        'z'
    ],
    [
        'ޓ',
        't'
    ],
    [
        'ޔ',
        'y'
    ],
    [
        'ޕ',
        'p'
    ],
    [
        'ޖ',
        'j'
    ],
    [
        'ޗ',
        'ch'
    ],
    [
        'ޘ',
        'tt'
    ],
    [
        'ޙ',
        'hh'
    ],
    [
        'ޚ',
        'kh'
    ],
    [
        'ޛ',
        'th'
    ],
    [
        'ޜ',
        'z'
    ],
    [
        'ޝ',
        'sh'
    ],
    [
        'ޞ',
        's'
    ],
    [
        'ޟ',
        'd'
    ],
    [
        'ޠ',
        't'
    ],
    [
        'ޡ',
        'z'
    ],
    [
        'ޢ',
        'a'
    ],
    [
        'ޣ',
        'gh'
    ],
    [
        'ޤ',
        'q'
    ],
    [
        'ޥ',
        'w'
    ],
    [
        'ަ',
        'a'
    ],
    [
        'ާ',
        'aa'
    ],
    [
        'ި',
        'i'
    ],
    [
        'ީ',
        'ee'
    ],
    [
        'ު',
        'u'
    ],
    [
        'ޫ',
        'oo'
    ],
    [
        'ެ',
        'e'
    ],
    [
        'ޭ',
        'ey'
    ],
    [
        'ޮ',
        'o'
    ],
    [
        'ޯ',
        'oa'
    ],
    [
        'ް',
        ''
    ],
    // Greek
    [
        'α',
        'a'
    ],
    [
        'β',
        'v'
    ],
    [
        'γ',
        'g'
    ],
    [
        'δ',
        'd'
    ],
    [
        'ε',
        'e'
    ],
    [
        'ζ',
        'z'
    ],
    [
        'η',
        'i'
    ],
    [
        'θ',
        'th'
    ],
    [
        'ι',
        'i'
    ],
    [
        'κ',
        'k'
    ],
    [
        'λ',
        'l'
    ],
    [
        'μ',
        'm'
    ],
    [
        'ν',
        'n'
    ],
    [
        'ξ',
        'ks'
    ],
    [
        'ο',
        'o'
    ],
    [
        'π',
        'p'
    ],
    [
        'ρ',
        'r'
    ],
    [
        'σ',
        's'
    ],
    [
        'τ',
        't'
    ],
    [
        'υ',
        'y'
    ],
    [
        'φ',
        'f'
    ],
    [
        'χ',
        'x'
    ],
    [
        'ψ',
        'ps'
    ],
    [
        'ω',
        'o'
    ],
    [
        'ά',
        'a'
    ],
    [
        'έ',
        'e'
    ],
    [
        'ί',
        'i'
    ],
    [
        'ό',
        'o'
    ],
    [
        'ύ',
        'y'
    ],
    [
        'ή',
        'i'
    ],
    [
        'ώ',
        'o'
    ],
    [
        'ς',
        's'
    ],
    [
        'ϊ',
        'i'
    ],
    [
        'ΰ',
        'y'
    ],
    [
        'ϋ',
        'y'
    ],
    [
        'ΐ',
        'i'
    ],
    [
        'Α',
        'A'
    ],
    [
        'Β',
        'B'
    ],
    [
        'Γ',
        'G'
    ],
    [
        'Δ',
        'D'
    ],
    [
        'Ε',
        'E'
    ],
    [
        'Ζ',
        'Z'
    ],
    [
        'Η',
        'I'
    ],
    [
        'Θ',
        'TH'
    ],
    [
        'Ι',
        'I'
    ],
    [
        'Κ',
        'K'
    ],
    [
        'Λ',
        'L'
    ],
    [
        'Μ',
        'M'
    ],
    [
        'Ν',
        'N'
    ],
    [
        'Ξ',
        'KS'
    ],
    [
        'Ο',
        'O'
    ],
    [
        'Π',
        'P'
    ],
    [
        'Ρ',
        'R'
    ],
    [
        'Σ',
        'S'
    ],
    [
        'Τ',
        'T'
    ],
    [
        'Υ',
        'Y'
    ],
    [
        'Φ',
        'F'
    ],
    [
        'Χ',
        'X'
    ],
    [
        'Ψ',
        'PS'
    ],
    [
        'Ω',
        'O'
    ],
    [
        'Ά',
        'A'
    ],
    [
        'Έ',
        'E'
    ],
    [
        'Ί',
        'I'
    ],
    [
        'Ό',
        'O'
    ],
    [
        'Ύ',
        'Y'
    ],
    [
        'Ή',
        'I'
    ],
    [
        'Ώ',
        'O'
    ],
    [
        'Ϊ',
        'I'
    ],
    [
        'Ϋ',
        'Y'
    ],
    // Disabled as it conflicts with German and Latin.
    // Hungarian
    // ['ä', 'a'],
    // ['Ä', 'A'],
    // ['ö', 'o'],
    // ['Ö', 'O'],
    // ['ü', 'u'],
    // ['Ü', 'U'],
    // ['ű', 'u'],
    // ['Ű', 'U'],
    // Latvian
    [
        'ā',
        'a'
    ],
    [
        'ē',
        'e'
    ],
    [
        'ģ',
        'g'
    ],
    [
        'ī',
        'i'
    ],
    [
        'ķ',
        'k'
    ],
    [
        'ļ',
        'l'
    ],
    [
        'ņ',
        'n'
    ],
    [
        'ū',
        'u'
    ],
    [
        'Ā',
        'A'
    ],
    [
        'Ē',
        'E'
    ],
    [
        'Ģ',
        'G'
    ],
    [
        'Ī',
        'I'
    ],
    [
        'Ķ',
        'K'
    ],
    [
        'Ļ',
        'L'
    ],
    [
        'Ņ',
        'N'
    ],
    [
        'Ū',
        'U'
    ],
    [
        'č',
        'c'
    ],
    [
        'š',
        's'
    ],
    [
        'ž',
        'z'
    ],
    [
        'Č',
        'C'
    ],
    [
        'Š',
        'S'
    ],
    [
        'Ž',
        'Z'
    ],
    // Lithuanian
    [
        'ą',
        'a'
    ],
    [
        'č',
        'c'
    ],
    [
        'ę',
        'e'
    ],
    [
        'ė',
        'e'
    ],
    [
        'į',
        'i'
    ],
    [
        'š',
        's'
    ],
    [
        'ų',
        'u'
    ],
    [
        'ū',
        'u'
    ],
    [
        'ž',
        'z'
    ],
    [
        'Ą',
        'A'
    ],
    [
        'Č',
        'C'
    ],
    [
        'Ę',
        'E'
    ],
    [
        'Ė',
        'E'
    ],
    [
        'Į',
        'I'
    ],
    [
        'Š',
        'S'
    ],
    [
        'Ų',
        'U'
    ],
    [
        'Ū',
        'U'
    ],
    // Macedonian
    [
        'Ќ',
        'Kj'
    ],
    [
        'ќ',
        'kj'
    ],
    [
        'Љ',
        'Lj'
    ],
    [
        'љ',
        'lj'
    ],
    [
        'Њ',
        'Nj'
    ],
    [
        'њ',
        'nj'
    ],
    [
        'Тс',
        'Ts'
    ],
    [
        'тс',
        'ts'
    ],
    // Polish
    [
        'ą',
        'a'
    ],
    [
        'ć',
        'c'
    ],
    [
        'ę',
        'e'
    ],
    [
        'ł',
        'l'
    ],
    [
        'ń',
        'n'
    ],
    [
        'ś',
        's'
    ],
    [
        'ź',
        'z'
    ],
    [
        'ż',
        'z'
    ],
    [
        'Ą',
        'A'
    ],
    [
        'Ć',
        'C'
    ],
    [
        'Ę',
        'E'
    ],
    [
        'Ł',
        'L'
    ],
    [
        'Ń',
        'N'
    ],
    [
        'Ś',
        'S'
    ],
    [
        'Ź',
        'Z'
    ],
    [
        'Ż',
        'Z'
    ],
    // Disabled as it conflicts with Vietnamese.
    // Serbian
    // ['љ', 'lj'],
    // ['њ', 'nj'],
    // ['Љ', 'Lj'],
    // ['Њ', 'Nj'],
    // ['đ', 'dj'],
    // ['Đ', 'Dj'],
    // ['ђ', 'dj'],
    // ['ј', 'j'],
    // ['ћ', 'c'],
    // ['џ', 'dz'],
    // ['Ђ', 'Dj'],
    // ['Ј', 'j'],
    // ['Ћ', 'C'],
    // ['Џ', 'Dz'],
    // Disabled as it conflicts with German and Latin.
    // Slovak
    // ['ä', 'a'],
    // ['Ä', 'A'],
    // ['ľ', 'l'],
    // ['ĺ', 'l'],
    // ['ŕ', 'r'],
    // ['Ľ', 'L'],
    // ['Ĺ', 'L'],
    // ['Ŕ', 'R'],
    // Disabled as it conflicts with German and Latin.
    // Swedish
    // ['å', 'o'],
    // ['Å', 'o'],
    // ['ä', 'a'],
    // ['Ä', 'A'],
    // ['ë', 'e'],
    // ['Ë', 'E'],
    // ['ö', 'o'],
    // ['Ö', 'O'],
    // Ukrainian
    [
        'Є',
        'Ye'
    ],
    [
        'І',
        'I'
    ],
    [
        'Ї',
        'Yi'
    ],
    [
        'Ґ',
        'G'
    ],
    [
        'є',
        'ye'
    ],
    [
        'і',
        'i'
    ],
    [
        'ї',
        'yi'
    ],
    [
        'ґ',
        'g'
    ],
    // Dutch
    [
        'Ĳ',
        'IJ'
    ],
    [
        'ĳ',
        'ij'
    ],
    // Danish
    // ['Æ', 'Ae'],
    // ['Ø', 'Oe'],
    // ['Å', 'Aa'],
    // ['æ', 'ae'],
    // ['ø', 'oe'],
    // ['å', 'aa']
    // Currencies
    [
        '¢',
        'c'
    ],
    [
        '¥',
        'Y'
    ],
    [
        '߿',
        'b'
    ],
    [
        '৳',
        't'
    ],
    [
        '૱',
        'Bo'
    ],
    [
        '฿',
        'B'
    ],
    [
        '₠',
        'CE'
    ],
    [
        '₡',
        'C'
    ],
    [
        '₢',
        'Cr'
    ],
    [
        '₣',
        'F'
    ],
    [
        '₥',
        'm'
    ],
    [
        '₦',
        'N'
    ],
    [
        '₧',
        'Pt'
    ],
    [
        '₨',
        'Rs'
    ],
    [
        '₩',
        'W'
    ],
    [
        '₫',
        's'
    ],
    [
        '€',
        'E'
    ],
    [
        '₭',
        'K'
    ],
    [
        '₮',
        'T'
    ],
    [
        '₯',
        'Dp'
    ],
    [
        '₰',
        'S'
    ],
    [
        '₱',
        'P'
    ],
    [
        '₲',
        'G'
    ],
    [
        '₳',
        'A'
    ],
    [
        '₴',
        'S'
    ],
    [
        '₵',
        'C'
    ],
    [
        '₶',
        'tt'
    ],
    [
        '₷',
        'S'
    ],
    [
        '₸',
        'T'
    ],
    [
        '₹',
        'R'
    ],
    [
        '₺',
        'L'
    ],
    [
        '₽',
        'P'
    ],
    [
        '₿',
        'B'
    ],
    [
        '﹩',
        '$'
    ],
    [
        '￠',
        'c'
    ],
    [
        '￥',
        'Y'
    ],
    [
        '￦',
        'W'
    ],
    // Latin
    [
        '𝐀',
        'A'
    ],
    [
        '𝐁',
        'B'
    ],
    [
        '𝐂',
        'C'
    ],
    [
        '𝐃',
        'D'
    ],
    [
        '𝐄',
        'E'
    ],
    [
        '𝐅',
        'F'
    ],
    [
        '𝐆',
        'G'
    ],
    [
        '𝐇',
        'H'
    ],
    [
        '𝐈',
        'I'
    ],
    [
        '𝐉',
        'J'
    ],
    [
        '𝐊',
        'K'
    ],
    [
        '𝐋',
        'L'
    ],
    [
        '𝐌',
        'M'
    ],
    [
        '𝐍',
        'N'
    ],
    [
        '𝐎',
        'O'
    ],
    [
        '𝐏',
        'P'
    ],
    [
        '𝐐',
        'Q'
    ],
    [
        '𝐑',
        'R'
    ],
    [
        '𝐒',
        'S'
    ],
    [
        '𝐓',
        'T'
    ],
    [
        '𝐔',
        'U'
    ],
    [
        '𝐕',
        'V'
    ],
    [
        '𝐖',
        'W'
    ],
    [
        '𝐗',
        'X'
    ],
    [
        '𝐘',
        'Y'
    ],
    [
        '𝐙',
        'Z'
    ],
    [
        '𝐚',
        'a'
    ],
    [
        '𝐛',
        'b'
    ],
    [
        '𝐜',
        'c'
    ],
    [
        '𝐝',
        'd'
    ],
    [
        '𝐞',
        'e'
    ],
    [
        '𝐟',
        'f'
    ],
    [
        '𝐠',
        'g'
    ],
    [
        '𝐡',
        'h'
    ],
    [
        '𝐢',
        'i'
    ],
    [
        '𝐣',
        'j'
    ],
    [
        '𝐤',
        'k'
    ],
    [
        '𝐥',
        'l'
    ],
    [
        '𝐦',
        'm'
    ],
    [
        '𝐧',
        'n'
    ],
    [
        '𝐨',
        'o'
    ],
    [
        '𝐩',
        'p'
    ],
    [
        '𝐪',
        'q'
    ],
    [
        '𝐫',
        'r'
    ],
    [
        '𝐬',
        's'
    ],
    [
        '𝐭',
        't'
    ],
    [
        '𝐮',
        'u'
    ],
    [
        '𝐯',
        'v'
    ],
    [
        '𝐰',
        'w'
    ],
    [
        '𝐱',
        'x'
    ],
    [
        '𝐲',
        'y'
    ],
    [
        '𝐳',
        'z'
    ],
    [
        '𝐴',
        'A'
    ],
    [
        '𝐵',
        'B'
    ],
    [
        '𝐶',
        'C'
    ],
    [
        '𝐷',
        'D'
    ],
    [
        '𝐸',
        'E'
    ],
    [
        '𝐹',
        'F'
    ],
    [
        '𝐺',
        'G'
    ],
    [
        '𝐻',
        'H'
    ],
    [
        '𝐼',
        'I'
    ],
    [
        '𝐽',
        'J'
    ],
    [
        '𝐾',
        'K'
    ],
    [
        '𝐿',
        'L'
    ],
    [
        '𝑀',
        'M'
    ],
    [
        '𝑁',
        'N'
    ],
    [
        '𝑂',
        'O'
    ],
    [
        '𝑃',
        'P'
    ],
    [
        '𝑄',
        'Q'
    ],
    [
        '𝑅',
        'R'
    ],
    [
        '𝑆',
        'S'
    ],
    [
        '𝑇',
        'T'
    ],
    [
        '𝑈',
        'U'
    ],
    [
        '𝑉',
        'V'
    ],
    [
        '𝑊',
        'W'
    ],
    [
        '𝑋',
        'X'
    ],
    [
        '𝑌',
        'Y'
    ],
    [
        '𝑍',
        'Z'
    ],
    [
        '𝑎',
        'a'
    ],
    [
        '𝑏',
        'b'
    ],
    [
        '𝑐',
        'c'
    ],
    [
        '𝑑',
        'd'
    ],
    [
        '𝑒',
        'e'
    ],
    [
        '𝑓',
        'f'
    ],
    [
        '𝑔',
        'g'
    ],
    [
        '𝑖',
        'i'
    ],
    [
        '𝑗',
        'j'
    ],
    [
        '𝑘',
        'k'
    ],
    [
        '𝑙',
        'l'
    ],
    [
        '𝑚',
        'm'
    ],
    [
        '𝑛',
        'n'
    ],
    [
        '𝑜',
        'o'
    ],
    [
        '𝑝',
        'p'
    ],
    [
        '𝑞',
        'q'
    ],
    [
        '𝑟',
        'r'
    ],
    [
        '𝑠',
        's'
    ],
    [
        '𝑡',
        't'
    ],
    [
        '𝑢',
        'u'
    ],
    [
        '𝑣',
        'v'
    ],
    [
        '𝑤',
        'w'
    ],
    [
        '𝑥',
        'x'
    ],
    [
        '𝑦',
        'y'
    ],
    [
        '𝑧',
        'z'
    ],
    [
        '𝑨',
        'A'
    ],
    [
        '𝑩',
        'B'
    ],
    [
        '𝑪',
        'C'
    ],
    [
        '𝑫',
        'D'
    ],
    [
        '𝑬',
        'E'
    ],
    [
        '𝑭',
        'F'
    ],
    [
        '𝑮',
        'G'
    ],
    [
        '𝑯',
        'H'
    ],
    [
        '𝑰',
        'I'
    ],
    [
        '𝑱',
        'J'
    ],
    [
        '𝑲',
        'K'
    ],
    [
        '𝑳',
        'L'
    ],
    [
        '𝑴',
        'M'
    ],
    [
        '𝑵',
        'N'
    ],
    [
        '𝑶',
        'O'
    ],
    [
        '𝑷',
        'P'
    ],
    [
        '𝑸',
        'Q'
    ],
    [
        '𝑹',
        'R'
    ],
    [
        '𝑺',
        'S'
    ],
    [
        '𝑻',
        'T'
    ],
    [
        '𝑼',
        'U'
    ],
    [
        '𝑽',
        'V'
    ],
    [
        '𝑾',
        'W'
    ],
    [
        '𝑿',
        'X'
    ],
    [
        '𝒀',
        'Y'
    ],
    [
        '𝒁',
        'Z'
    ],
    [
        '𝒂',
        'a'
    ],
    [
        '𝒃',
        'b'
    ],
    [
        '𝒄',
        'c'
    ],
    [
        '𝒅',
        'd'
    ],
    [
        '𝒆',
        'e'
    ],
    [
        '𝒇',
        'f'
    ],
    [
        '𝒈',
        'g'
    ],
    [
        '𝒉',
        'h'
    ],
    [
        '𝒊',
        'i'
    ],
    [
        '𝒋',
        'j'
    ],
    [
        '𝒌',
        'k'
    ],
    [
        '𝒍',
        'l'
    ],
    [
        '𝒎',
        'm'
    ],
    [
        '𝒏',
        'n'
    ],
    [
        '𝒐',
        'o'
    ],
    [
        '𝒑',
        'p'
    ],
    [
        '𝒒',
        'q'
    ],
    [
        '𝒓',
        'r'
    ],
    [
        '𝒔',
        's'
    ],
    [
        '𝒕',
        't'
    ],
    [
        '𝒖',
        'u'
    ],
    [
        '𝒗',
        'v'
    ],
    [
        '𝒘',
        'w'
    ],
    [
        '𝒙',
        'x'
    ],
    [
        '𝒚',
        'y'
    ],
    [
        '𝒛',
        'z'
    ],
    [
        '𝒜',
        'A'
    ],
    [
        '𝒞',
        'C'
    ],
    [
        '𝒟',
        'D'
    ],
    [
        '𝒢',
        'g'
    ],
    [
        '𝒥',
        'J'
    ],
    [
        '𝒦',
        'K'
    ],
    [
        '𝒩',
        'N'
    ],
    [
        '𝒪',
        'O'
    ],
    [
        '𝒫',
        'P'
    ],
    [
        '𝒬',
        'Q'
    ],
    [
        '𝒮',
        'S'
    ],
    [
        '𝒯',
        'T'
    ],
    [
        '𝒰',
        'U'
    ],
    [
        '𝒱',
        'V'
    ],
    [
        '𝒲',
        'W'
    ],
    [
        '𝒳',
        'X'
    ],
    [
        '𝒴',
        'Y'
    ],
    [
        '𝒵',
        'Z'
    ],
    [
        '𝒶',
        'a'
    ],
    [
        '𝒷',
        'b'
    ],
    [
        '𝒸',
        'c'
    ],
    [
        '𝒹',
        'd'
    ],
    [
        '𝒻',
        'f'
    ],
    [
        '𝒽',
        'h'
    ],
    [
        '𝒾',
        'i'
    ],
    [
        '𝒿',
        'j'
    ],
    [
        '𝓀',
        'h'
    ],
    [
        '𝓁',
        'l'
    ],
    [
        '𝓂',
        'm'
    ],
    [
        '𝓃',
        'n'
    ],
    [
        '𝓅',
        'p'
    ],
    [
        '𝓆',
        'q'
    ],
    [
        '𝓇',
        'r'
    ],
    [
        '𝓈',
        's'
    ],
    [
        '𝓉',
        't'
    ],
    [
        '𝓊',
        'u'
    ],
    [
        '𝓋',
        'v'
    ],
    [
        '𝓌',
        'w'
    ],
    [
        '𝓍',
        'x'
    ],
    [
        '𝓎',
        'y'
    ],
    [
        '𝓏',
        'z'
    ],
    [
        '𝓐',
        'A'
    ],
    [
        '𝓑',
        'B'
    ],
    [
        '𝓒',
        'C'
    ],
    [
        '𝓓',
        'D'
    ],
    [
        '𝓔',
        'E'
    ],
    [
        '𝓕',
        'F'
    ],
    [
        '𝓖',
        'G'
    ],
    [
        '𝓗',
        'H'
    ],
    [
        '𝓘',
        'I'
    ],
    [
        '𝓙',
        'J'
    ],
    [
        '𝓚',
        'K'
    ],
    [
        '𝓛',
        'L'
    ],
    [
        '𝓜',
        'M'
    ],
    [
        '𝓝',
        'N'
    ],
    [
        '𝓞',
        'O'
    ],
    [
        '𝓟',
        'P'
    ],
    [
        '𝓠',
        'Q'
    ],
    [
        '𝓡',
        'R'
    ],
    [
        '𝓢',
        'S'
    ],
    [
        '𝓣',
        'T'
    ],
    [
        '𝓤',
        'U'
    ],
    [
        '𝓥',
        'V'
    ],
    [
        '𝓦',
        'W'
    ],
    [
        '𝓧',
        'X'
    ],
    [
        '𝓨',
        'Y'
    ],
    [
        '𝓩',
        'Z'
    ],
    [
        '𝓪',
        'a'
    ],
    [
        '𝓫',
        'b'
    ],
    [
        '𝓬',
        'c'
    ],
    [
        '𝓭',
        'd'
    ],
    [
        '𝓮',
        'e'
    ],
    [
        '𝓯',
        'f'
    ],
    [
        '𝓰',
        'g'
    ],
    [
        '𝓱',
        'h'
    ],
    [
        '𝓲',
        'i'
    ],
    [
        '𝓳',
        'j'
    ],
    [
        '𝓴',
        'k'
    ],
    [
        '𝓵',
        'l'
    ],
    [
        '𝓶',
        'm'
    ],
    [
        '𝓷',
        'n'
    ],
    [
        '𝓸',
        'o'
    ],
    [
        '𝓹',
        'p'
    ],
    [
        '𝓺',
        'q'
    ],
    [
        '𝓻',
        'r'
    ],
    [
        '𝓼',
        's'
    ],
    [
        '𝓽',
        't'
    ],
    [
        '𝓾',
        'u'
    ],
    [
        '𝓿',
        'v'
    ],
    [
        '𝔀',
        'w'
    ],
    [
        '𝔁',
        'x'
    ],
    [
        '𝔂',
        'y'
    ],
    [
        '𝔃',
        'z'
    ],
    [
        '𝔄',
        'A'
    ],
    [
        '𝔅',
        'B'
    ],
    [
        '𝔇',
        'D'
    ],
    [
        '𝔈',
        'E'
    ],
    [
        '𝔉',
        'F'
    ],
    [
        '𝔊',
        'G'
    ],
    [
        '𝔍',
        'J'
    ],
    [
        '𝔎',
        'K'
    ],
    [
        '𝔏',
        'L'
    ],
    [
        '𝔐',
        'M'
    ],
    [
        '𝔑',
        'N'
    ],
    [
        '𝔒',
        'O'
    ],
    [
        '𝔓',
        'P'
    ],
    [
        '𝔔',
        'Q'
    ],
    [
        '𝔖',
        'S'
    ],
    [
        '𝔗',
        'T'
    ],
    [
        '𝔘',
        'U'
    ],
    [
        '𝔙',
        'V'
    ],
    [
        '𝔚',
        'W'
    ],
    [
        '𝔛',
        'X'
    ],
    [
        '𝔜',
        'Y'
    ],
    [
        '𝔞',
        'a'
    ],
    [
        '𝔟',
        'b'
    ],
    [
        '𝔠',
        'c'
    ],
    [
        '𝔡',
        'd'
    ],
    [
        '𝔢',
        'e'
    ],
    [
        '𝔣',
        'f'
    ],
    [
        '𝔤',
        'g'
    ],
    [
        '𝔥',
        'h'
    ],
    [
        '𝔦',
        'i'
    ],
    [
        '𝔧',
        'j'
    ],
    [
        '𝔨',
        'k'
    ],
    [
        '𝔩',
        'l'
    ],
    [
        '𝔪',
        'm'
    ],
    [
        '𝔫',
        'n'
    ],
    [
        '𝔬',
        'o'
    ],
    [
        '𝔭',
        'p'
    ],
    [
        '𝔮',
        'q'
    ],
    [
        '𝔯',
        'r'
    ],
    [
        '𝔰',
        's'
    ],
    [
        '𝔱',
        't'
    ],
    [
        '𝔲',
        'u'
    ],
    [
        '𝔳',
        'v'
    ],
    [
        '𝔴',
        'w'
    ],
    [
        '𝔵',
        'x'
    ],
    [
        '𝔶',
        'y'
    ],
    [
        '𝔷',
        'z'
    ],
    [
        '𝔸',
        'A'
    ],
    [
        '𝔹',
        'B'
    ],
    [
        '𝔻',
        'D'
    ],
    [
        '𝔼',
        'E'
    ],
    [
        '𝔽',
        'F'
    ],
    [
        '𝔾',
        'G'
    ],
    [
        '𝕀',
        'I'
    ],
    [
        '𝕁',
        'J'
    ],
    [
        '𝕂',
        'K'
    ],
    [
        '𝕃',
        'L'
    ],
    [
        '𝕄',
        'M'
    ],
    [
        '𝕆',
        'N'
    ],
    [
        '𝕊',
        'S'
    ],
    [
        '𝕋',
        'T'
    ],
    [
        '𝕌',
        'U'
    ],
    [
        '𝕍',
        'V'
    ],
    [
        '𝕎',
        'W'
    ],
    [
        '𝕏',
        'X'
    ],
    [
        '𝕐',
        'Y'
    ],
    [
        '𝕒',
        'a'
    ],
    [
        '𝕓',
        'b'
    ],
    [
        '𝕔',
        'c'
    ],
    [
        '𝕕',
        'd'
    ],
    [
        '𝕖',
        'e'
    ],
    [
        '𝕗',
        'f'
    ],
    [
        '𝕘',
        'g'
    ],
    [
        '𝕙',
        'h'
    ],
    [
        '𝕚',
        'i'
    ],
    [
        '𝕛',
        'j'
    ],
    [
        '𝕜',
        'k'
    ],
    [
        '𝕝',
        'l'
    ],
    [
        '𝕞',
        'm'
    ],
    [
        '𝕟',
        'n'
    ],
    [
        '𝕠',
        'o'
    ],
    [
        '𝕡',
        'p'
    ],
    [
        '𝕢',
        'q'
    ],
    [
        '𝕣',
        'r'
    ],
    [
        '𝕤',
        's'
    ],
    [
        '𝕥',
        't'
    ],
    [
        '𝕦',
        'u'
    ],
    [
        '𝕧',
        'v'
    ],
    [
        '𝕨',
        'w'
    ],
    [
        '𝕩',
        'x'
    ],
    [
        '𝕪',
        'y'
    ],
    [
        '𝕫',
        'z'
    ],
    [
        '𝕬',
        'A'
    ],
    [
        '𝕭',
        'B'
    ],
    [
        '𝕮',
        'C'
    ],
    [
        '𝕯',
        'D'
    ],
    [
        '𝕰',
        'E'
    ],
    [
        '𝕱',
        'F'
    ],
    [
        '𝕲',
        'G'
    ],
    [
        '𝕳',
        'H'
    ],
    [
        '𝕴',
        'I'
    ],
    [
        '𝕵',
        'J'
    ],
    [
        '𝕶',
        'K'
    ],
    [
        '𝕷',
        'L'
    ],
    [
        '𝕸',
        'M'
    ],
    [
        '𝕹',
        'N'
    ],
    [
        '𝕺',
        'O'
    ],
    [
        '𝕻',
        'P'
    ],
    [
        '𝕼',
        'Q'
    ],
    [
        '𝕽',
        'R'
    ],
    [
        '𝕾',
        'S'
    ],
    [
        '𝕿',
        'T'
    ],
    [
        '𝖀',
        'U'
    ],
    [
        '𝖁',
        'V'
    ],
    [
        '𝖂',
        'W'
    ],
    [
        '𝖃',
        'X'
    ],
    [
        '𝖄',
        'Y'
    ],
    [
        '𝖅',
        'Z'
    ],
    [
        '𝖆',
        'a'
    ],
    [
        '𝖇',
        'b'
    ],
    [
        '𝖈',
        'c'
    ],
    [
        '𝖉',
        'd'
    ],
    [
        '𝖊',
        'e'
    ],
    [
        '𝖋',
        'f'
    ],
    [
        '𝖌',
        'g'
    ],
    [
        '𝖍',
        'h'
    ],
    [
        '𝖎',
        'i'
    ],
    [
        '𝖏',
        'j'
    ],
    [
        '𝖐',
        'k'
    ],
    [
        '𝖑',
        'l'
    ],
    [
        '𝖒',
        'm'
    ],
    [
        '𝖓',
        'n'
    ],
    [
        '𝖔',
        'o'
    ],
    [
        '𝖕',
        'p'
    ],
    [
        '𝖖',
        'q'
    ],
    [
        '𝖗',
        'r'
    ],
    [
        '𝖘',
        's'
    ],
    [
        '𝖙',
        't'
    ],
    [
        '𝖚',
        'u'
    ],
    [
        '𝖛',
        'v'
    ],
    [
        '𝖜',
        'w'
    ],
    [
        '𝖝',
        'x'
    ],
    [
        '𝖞',
        'y'
    ],
    [
        '𝖟',
        'z'
    ],
    [
        '𝖠',
        'A'
    ],
    [
        '𝖡',
        'B'
    ],
    [
        '𝖢',
        'C'
    ],
    [
        '𝖣',
        'D'
    ],
    [
        '𝖤',
        'E'
    ],
    [
        '𝖥',
        'F'
    ],
    [
        '𝖦',
        'G'
    ],
    [
        '𝖧',
        'H'
    ],
    [
        '𝖨',
        'I'
    ],
    [
        '𝖩',
        'J'
    ],
    [
        '𝖪',
        'K'
    ],
    [
        '𝖫',
        'L'
    ],
    [
        '𝖬',
        'M'
    ],
    [
        '𝖭',
        'N'
    ],
    [
        '𝖮',
        'O'
    ],
    [
        '𝖯',
        'P'
    ],
    [
        '𝖰',
        'Q'
    ],
    [
        '𝖱',
        'R'
    ],
    [
        '𝖲',
        'S'
    ],
    [
        '𝖳',
        'T'
    ],
    [
        '𝖴',
        'U'
    ],
    [
        '𝖵',
        'V'
    ],
    [
        '𝖶',
        'W'
    ],
    [
        '𝖷',
        'X'
    ],
    [
        '𝖸',
        'Y'
    ],
    [
        '𝖹',
        'Z'
    ],
    [
        '𝖺',
        'a'
    ],
    [
        '𝖻',
        'b'
    ],
    [
        '𝖼',
        'c'
    ],
    [
        '𝖽',
        'd'
    ],
    [
        '𝖾',
        'e'
    ],
    [
        '𝖿',
        'f'
    ],
    [
        '𝗀',
        'g'
    ],
    [
        '𝗁',
        'h'
    ],
    [
        '𝗂',
        'i'
    ],
    [
        '𝗃',
        'j'
    ],
    [
        '𝗄',
        'k'
    ],
    [
        '𝗅',
        'l'
    ],
    [
        '𝗆',
        'm'
    ],
    [
        '𝗇',
        'n'
    ],
    [
        '𝗈',
        'o'
    ],
    [
        '𝗉',
        'p'
    ],
    [
        '𝗊',
        'q'
    ],
    [
        '𝗋',
        'r'
    ],
    [
        '𝗌',
        's'
    ],
    [
        '𝗍',
        't'
    ],
    [
        '𝗎',
        'u'
    ],
    [
        '𝗏',
        'v'
    ],
    [
        '𝗐',
        'w'
    ],
    [
        '𝗑',
        'x'
    ],
    [
        '𝗒',
        'y'
    ],
    [
        '𝗓',
        'z'
    ],
    [
        '𝗔',
        'A'
    ],
    [
        '𝗕',
        'B'
    ],
    [
        '𝗖',
        'C'
    ],
    [
        '𝗗',
        'D'
    ],
    [
        '𝗘',
        'E'
    ],
    [
        '𝗙',
        'F'
    ],
    [
        '𝗚',
        'G'
    ],
    [
        '𝗛',
        'H'
    ],
    [
        '𝗜',
        'I'
    ],
    [
        '𝗝',
        'J'
    ],
    [
        '𝗞',
        'K'
    ],
    [
        '𝗟',
        'L'
    ],
    [
        '𝗠',
        'M'
    ],
    [
        '𝗡',
        'N'
    ],
    [
        '𝗢',
        'O'
    ],
    [
        '𝗣',
        'P'
    ],
    [
        '𝗤',
        'Q'
    ],
    [
        '𝗥',
        'R'
    ],
    [
        '𝗦',
        'S'
    ],
    [
        '𝗧',
        'T'
    ],
    [
        '𝗨',
        'U'
    ],
    [
        '𝗩',
        'V'
    ],
    [
        '𝗪',
        'W'
    ],
    [
        '𝗫',
        'X'
    ],
    [
        '𝗬',
        'Y'
    ],
    [
        '𝗭',
        'Z'
    ],
    [
        '𝗮',
        'a'
    ],
    [
        '𝗯',
        'b'
    ],
    [
        '𝗰',
        'c'
    ],
    [
        '𝗱',
        'd'
    ],
    [
        '𝗲',
        'e'
    ],
    [
        '𝗳',
        'f'
    ],
    [
        '𝗴',
        'g'
    ],
    [
        '𝗵',
        'h'
    ],
    [
        '𝗶',
        'i'
    ],
    [
        '𝗷',
        'j'
    ],
    [
        '𝗸',
        'k'
    ],
    [
        '𝗹',
        'l'
    ],
    [
        '𝗺',
        'm'
    ],
    [
        '𝗻',
        'n'
    ],
    [
        '𝗼',
        'o'
    ],
    [
        '𝗽',
        'p'
    ],
    [
        '𝗾',
        'q'
    ],
    [
        '𝗿',
        'r'
    ],
    [
        '𝘀',
        's'
    ],
    [
        '𝘁',
        't'
    ],
    [
        '𝘂',
        'u'
    ],
    [
        '𝘃',
        'v'
    ],
    [
        '𝘄',
        'w'
    ],
    [
        '𝘅',
        'x'
    ],
    [
        '𝘆',
        'y'
    ],
    [
        '𝘇',
        'z'
    ],
    [
        '𝘈',
        'A'
    ],
    [
        '𝘉',
        'B'
    ],
    [
        '𝘊',
        'C'
    ],
    [
        '𝘋',
        'D'
    ],
    [
        '𝘌',
        'E'
    ],
    [
        '𝘍',
        'F'
    ],
    [
        '𝘎',
        'G'
    ],
    [
        '𝘏',
        'H'
    ],
    [
        '𝘐',
        'I'
    ],
    [
        '𝘑',
        'J'
    ],
    [
        '𝘒',
        'K'
    ],
    [
        '𝘓',
        'L'
    ],
    [
        '𝘔',
        'M'
    ],
    [
        '𝘕',
        'N'
    ],
    [
        '𝘖',
        'O'
    ],
    [
        '𝘗',
        'P'
    ],
    [
        '𝘘',
        'Q'
    ],
    [
        '𝘙',
        'R'
    ],
    [
        '𝘚',
        'S'
    ],
    [
        '𝘛',
        'T'
    ],
    [
        '𝘜',
        'U'
    ],
    [
        '𝘝',
        'V'
    ],
    [
        '𝘞',
        'W'
    ],
    [
        '𝘟',
        'X'
    ],
    [
        '𝘠',
        'Y'
    ],
    [
        '𝘡',
        'Z'
    ],
    [
        '𝘢',
        'a'
    ],
    [
        '𝘣',
        'b'
    ],
    [
        '𝘤',
        'c'
    ],
    [
        '𝘥',
        'd'
    ],
    [
        '𝘦',
        'e'
    ],
    [
        '𝘧',
        'f'
    ],
    [
        '𝘨',
        'g'
    ],
    [
        '𝘩',
        'h'
    ],
    [
        '𝘪',
        'i'
    ],
    [
        '𝘫',
        'j'
    ],
    [
        '𝘬',
        'k'
    ],
    [
        '𝘭',
        'l'
    ],
    [
        '𝘮',
        'm'
    ],
    [
        '𝘯',
        'n'
    ],
    [
        '𝘰',
        'o'
    ],
    [
        '𝘱',
        'p'
    ],
    [
        '𝘲',
        'q'
    ],
    [
        '𝘳',
        'r'
    ],
    [
        '𝘴',
        's'
    ],
    [
        '𝘵',
        't'
    ],
    [
        '𝘶',
        'u'
    ],
    [
        '𝘷',
        'v'
    ],
    [
        '𝘸',
        'w'
    ],
    [
        '𝘹',
        'x'
    ],
    [
        '𝘺',
        'y'
    ],
    [
        '𝘻',
        'z'
    ],
    [
        '𝘼',
        'A'
    ],
    [
        '𝘽',
        'B'
    ],
    [
        '𝘾',
        'C'
    ],
    [
        '𝘿',
        'D'
    ],
    [
        '𝙀',
        'E'
    ],
    [
        '𝙁',
        'F'
    ],
    [
        '𝙂',
        'G'
    ],
    [
        '𝙃',
        'H'
    ],
    [
        '𝙄',
        'I'
    ],
    [
        '𝙅',
        'J'
    ],
    [
        '𝙆',
        'K'
    ],
    [
        '𝙇',
        'L'
    ],
    [
        '𝙈',
        'M'
    ],
    [
        '𝙉',
        'N'
    ],
    [
        '𝙊',
        'O'
    ],
    [
        '𝙋',
        'P'
    ],
    [
        '𝙌',
        'Q'
    ],
    [
        '𝙍',
        'R'
    ],
    [
        '𝙎',
        'S'
    ],
    [
        '𝙏',
        'T'
    ],
    [
        '𝙐',
        'U'
    ],
    [
        '𝙑',
        'V'
    ],
    [
        '𝙒',
        'W'
    ],
    [
        '𝙓',
        'X'
    ],
    [
        '𝙔',
        'Y'
    ],
    [
        '𝙕',
        'Z'
    ],
    [
        '𝙖',
        'a'
    ],
    [
        '𝙗',
        'b'
    ],
    [
        '𝙘',
        'c'
    ],
    [
        '𝙙',
        'd'
    ],
    [
        '𝙚',
        'e'
    ],
    [
        '𝙛',
        'f'
    ],
    [
        '𝙜',
        'g'
    ],
    [
        '𝙝',
        'h'
    ],
    [
        '𝙞',
        'i'
    ],
    [
        '𝙟',
        'j'
    ],
    [
        '𝙠',
        'k'
    ],
    [
        '𝙡',
        'l'
    ],
    [
        '𝙢',
        'm'
    ],
    [
        '𝙣',
        'n'
    ],
    [
        '𝙤',
        'o'
    ],
    [
        '𝙥',
        'p'
    ],
    [
        '𝙦',
        'q'
    ],
    [
        '𝙧',
        'r'
    ],
    [
        '𝙨',
        's'
    ],
    [
        '𝙩',
        't'
    ],
    [
        '𝙪',
        'u'
    ],
    [
        '𝙫',
        'v'
    ],
    [
        '𝙬',
        'w'
    ],
    [
        '𝙭',
        'x'
    ],
    [
        '𝙮',
        'y'
    ],
    [
        '𝙯',
        'z'
    ],
    [
        '𝙰',
        'A'
    ],
    [
        '𝙱',
        'B'
    ],
    [
        '𝙲',
        'C'
    ],
    [
        '𝙳',
        'D'
    ],
    [
        '𝙴',
        'E'
    ],
    [
        '𝙵',
        'F'
    ],
    [
        '𝙶',
        'G'
    ],
    [
        '𝙷',
        'H'
    ],
    [
        '𝙸',
        'I'
    ],
    [
        '𝙹',
        'J'
    ],
    [
        '𝙺',
        'K'
    ],
    [
        '𝙻',
        'L'
    ],
    [
        '𝙼',
        'M'
    ],
    [
        '𝙽',
        'N'
    ],
    [
        '𝙾',
        'O'
    ],
    [
        '𝙿',
        'P'
    ],
    [
        '𝚀',
        'Q'
    ],
    [
        '𝚁',
        'R'
    ],
    [
        '𝚂',
        'S'
    ],
    [
        '𝚃',
        'T'
    ],
    [
        '𝚄',
        'U'
    ],
    [
        '𝚅',
        'V'
    ],
    [
        '𝚆',
        'W'
    ],
    [
        '𝚇',
        'X'
    ],
    [
        '𝚈',
        'Y'
    ],
    [
        '𝚉',
        'Z'
    ],
    [
        '𝚊',
        'a'
    ],
    [
        '𝚋',
        'b'
    ],
    [
        '𝚌',
        'c'
    ],
    [
        '𝚍',
        'd'
    ],
    [
        '𝚎',
        'e'
    ],
    [
        '𝚏',
        'f'
    ],
    [
        '𝚐',
        'g'
    ],
    [
        '𝚑',
        'h'
    ],
    [
        '𝚒',
        'i'
    ],
    [
        '𝚓',
        'j'
    ],
    [
        '𝚔',
        'k'
    ],
    [
        '𝚕',
        'l'
    ],
    [
        '𝚖',
        'm'
    ],
    [
        '𝚗',
        'n'
    ],
    [
        '𝚘',
        'o'
    ],
    [
        '𝚙',
        'p'
    ],
    [
        '𝚚',
        'q'
    ],
    [
        '𝚛',
        'r'
    ],
    [
        '𝚜',
        's'
    ],
    [
        '𝚝',
        't'
    ],
    [
        '𝚞',
        'u'
    ],
    [
        '𝚟',
        'v'
    ],
    [
        '𝚠',
        'w'
    ],
    [
        '𝚡',
        'x'
    ],
    [
        '𝚢',
        'y'
    ],
    [
        '𝚣',
        'z'
    ],
    // Dotless letters
    [
        '𝚤',
        'l'
    ],
    [
        '𝚥',
        'j'
    ],
    // Greek
    [
        '𝛢',
        'A'
    ],
    [
        '𝛣',
        'B'
    ],
    [
        '𝛤',
        'G'
    ],
    [
        '𝛥',
        'D'
    ],
    [
        '𝛦',
        'E'
    ],
    [
        '𝛧',
        'Z'
    ],
    [
        '𝛨',
        'I'
    ],
    [
        '𝛩',
        'TH'
    ],
    [
        '𝛪',
        'I'
    ],
    [
        '𝛫',
        'K'
    ],
    [
        '𝛬',
        'L'
    ],
    [
        '𝛭',
        'M'
    ],
    [
        '𝛮',
        'N'
    ],
    [
        '𝛯',
        'KS'
    ],
    [
        '𝛰',
        'O'
    ],
    [
        '𝛱',
        'P'
    ],
    [
        '𝛲',
        'R'
    ],
    [
        '𝛳',
        'TH'
    ],
    [
        '𝛴',
        'S'
    ],
    [
        '𝛵',
        'T'
    ],
    [
        '𝛶',
        'Y'
    ],
    [
        '𝛷',
        'F'
    ],
    [
        '𝛸',
        'x'
    ],
    [
        '𝛹',
        'PS'
    ],
    [
        '𝛺',
        'O'
    ],
    [
        '𝛻',
        'D'
    ],
    [
        '𝛼',
        'a'
    ],
    [
        '𝛽',
        'b'
    ],
    [
        '𝛾',
        'g'
    ],
    [
        '𝛿',
        'd'
    ],
    [
        '𝜀',
        'e'
    ],
    [
        '𝜁',
        'z'
    ],
    [
        '𝜂',
        'i'
    ],
    [
        '𝜃',
        'th'
    ],
    [
        '𝜄',
        'i'
    ],
    [
        '𝜅',
        'k'
    ],
    [
        '𝜆',
        'l'
    ],
    [
        '𝜇',
        'm'
    ],
    [
        '𝜈',
        'n'
    ],
    [
        '𝜉',
        'ks'
    ],
    [
        '𝜊',
        'o'
    ],
    [
        '𝜋',
        'p'
    ],
    [
        '𝜌',
        'r'
    ],
    [
        '𝜍',
        's'
    ],
    [
        '𝜎',
        's'
    ],
    [
        '𝜏',
        't'
    ],
    [
        '𝜐',
        'y'
    ],
    [
        '𝜑',
        'f'
    ],
    [
        '𝜒',
        'x'
    ],
    [
        '𝜓',
        'ps'
    ],
    [
        '𝜔',
        'o'
    ],
    [
        '𝜕',
        'd'
    ],
    [
        '𝜖',
        'E'
    ],
    [
        '𝜗',
        'TH'
    ],
    [
        '𝜘',
        'K'
    ],
    [
        '𝜙',
        'f'
    ],
    [
        '𝜚',
        'r'
    ],
    [
        '𝜛',
        'p'
    ],
    [
        '𝜜',
        'A'
    ],
    [
        '𝜝',
        'V'
    ],
    [
        '𝜞',
        'G'
    ],
    [
        '𝜟',
        'D'
    ],
    [
        '𝜠',
        'E'
    ],
    [
        '𝜡',
        'Z'
    ],
    [
        '𝜢',
        'I'
    ],
    [
        '𝜣',
        'TH'
    ],
    [
        '𝜤',
        'I'
    ],
    [
        '𝜥',
        'K'
    ],
    [
        '𝜦',
        'L'
    ],
    [
        '𝜧',
        'M'
    ],
    [
        '𝜨',
        'N'
    ],
    [
        '𝜩',
        'KS'
    ],
    [
        '𝜪',
        'O'
    ],
    [
        '𝜫',
        'P'
    ],
    [
        '𝜬',
        'S'
    ],
    [
        '𝜭',
        'TH'
    ],
    [
        '𝜮',
        'S'
    ],
    [
        '𝜯',
        'T'
    ],
    [
        '𝜰',
        'Y'
    ],
    [
        '𝜱',
        'F'
    ],
    [
        '𝜲',
        'X'
    ],
    [
        '𝜳',
        'PS'
    ],
    [
        '𝜴',
        'O'
    ],
    [
        '𝜵',
        'D'
    ],
    [
        '𝜶',
        'a'
    ],
    [
        '𝜷',
        'v'
    ],
    [
        '𝜸',
        'g'
    ],
    [
        '𝜹',
        'd'
    ],
    [
        '𝜺',
        'e'
    ],
    [
        '𝜻',
        'z'
    ],
    [
        '𝜼',
        'i'
    ],
    [
        '𝜽',
        'th'
    ],
    [
        '𝜾',
        'i'
    ],
    [
        '𝜿',
        'k'
    ],
    [
        '𝝀',
        'l'
    ],
    [
        '𝝁',
        'm'
    ],
    [
        '𝝂',
        'n'
    ],
    [
        '𝝃',
        'ks'
    ],
    [
        '𝝄',
        'o'
    ],
    [
        '𝝅',
        'p'
    ],
    [
        '𝝆',
        'r'
    ],
    [
        '𝝇',
        's'
    ],
    [
        '𝝈',
        's'
    ],
    [
        '𝝉',
        't'
    ],
    [
        '𝝊',
        'y'
    ],
    [
        '𝝋',
        'f'
    ],
    [
        '𝝌',
        'x'
    ],
    [
        '𝝍',
        'ps'
    ],
    [
        '𝝎',
        'o'
    ],
    [
        '𝝏',
        'a'
    ],
    [
        '𝝐',
        'e'
    ],
    [
        '𝝑',
        'i'
    ],
    [
        '𝝒',
        'k'
    ],
    [
        '𝝓',
        'f'
    ],
    [
        '𝝔',
        'r'
    ],
    [
        '𝝕',
        'p'
    ],
    [
        '𝝖',
        'A'
    ],
    [
        '𝝗',
        'B'
    ],
    [
        '𝝘',
        'G'
    ],
    [
        '𝝙',
        'D'
    ],
    [
        '𝝚',
        'E'
    ],
    [
        '𝝛',
        'Z'
    ],
    [
        '𝝜',
        'I'
    ],
    [
        '𝝝',
        'TH'
    ],
    [
        '𝝞',
        'I'
    ],
    [
        '𝝟',
        'K'
    ],
    [
        '𝝠',
        'L'
    ],
    [
        '𝝡',
        'M'
    ],
    [
        '𝝢',
        'N'
    ],
    [
        '𝝣',
        'KS'
    ],
    [
        '𝝤',
        'O'
    ],
    [
        '𝝥',
        'P'
    ],
    [
        '𝝦',
        'R'
    ],
    [
        '𝝧',
        'TH'
    ],
    [
        '𝝨',
        'S'
    ],
    [
        '𝝩',
        'T'
    ],
    [
        '𝝪',
        'Y'
    ],
    [
        '𝝫',
        'F'
    ],
    [
        '𝝬',
        'X'
    ],
    [
        '𝝭',
        'PS'
    ],
    [
        '𝝮',
        'O'
    ],
    [
        '𝝯',
        'D'
    ],
    [
        '𝝰',
        'a'
    ],
    [
        '𝝱',
        'v'
    ],
    [
        '𝝲',
        'g'
    ],
    [
        '𝝳',
        'd'
    ],
    [
        '𝝴',
        'e'
    ],
    [
        '𝝵',
        'z'
    ],
    [
        '𝝶',
        'i'
    ],
    [
        '𝝷',
        'th'
    ],
    [
        '𝝸',
        'i'
    ],
    [
        '𝝹',
        'k'
    ],
    [
        '𝝺',
        'l'
    ],
    [
        '𝝻',
        'm'
    ],
    [
        '𝝼',
        'n'
    ],
    [
        '𝝽',
        'ks'
    ],
    [
        '𝝾',
        'o'
    ],
    [
        '𝝿',
        'p'
    ],
    [
        '𝞀',
        'r'
    ],
    [
        '𝞁',
        's'
    ],
    [
        '𝞂',
        's'
    ],
    [
        '𝞃',
        't'
    ],
    [
        '𝞄',
        'y'
    ],
    [
        '𝞅',
        'f'
    ],
    [
        '𝞆',
        'x'
    ],
    [
        '𝞇',
        'ps'
    ],
    [
        '𝞈',
        'o'
    ],
    [
        '𝞉',
        'a'
    ],
    [
        '𝞊',
        'e'
    ],
    [
        '𝞋',
        'i'
    ],
    [
        '𝞌',
        'k'
    ],
    [
        '𝞍',
        'f'
    ],
    [
        '𝞎',
        'r'
    ],
    [
        '𝞏',
        'p'
    ],
    [
        '𝞐',
        'A'
    ],
    [
        '𝞑',
        'V'
    ],
    [
        '𝞒',
        'G'
    ],
    [
        '𝞓',
        'D'
    ],
    [
        '𝞔',
        'E'
    ],
    [
        '𝞕',
        'Z'
    ],
    [
        '𝞖',
        'I'
    ],
    [
        '𝞗',
        'TH'
    ],
    [
        '𝞘',
        'I'
    ],
    [
        '𝞙',
        'K'
    ],
    [
        '𝞚',
        'L'
    ],
    [
        '𝞛',
        'M'
    ],
    [
        '𝞜',
        'N'
    ],
    [
        '𝞝',
        'KS'
    ],
    [
        '𝞞',
        'O'
    ],
    [
        '𝞟',
        'P'
    ],
    [
        '𝞠',
        'S'
    ],
    [
        '𝞡',
        'TH'
    ],
    [
        '𝞢',
        'S'
    ],
    [
        '𝞣',
        'T'
    ],
    [
        '𝞤',
        'Y'
    ],
    [
        '𝞥',
        'F'
    ],
    [
        '𝞦',
        'X'
    ],
    [
        '𝞧',
        'PS'
    ],
    [
        '𝞨',
        'O'
    ],
    [
        '𝞩',
        'D'
    ],
    [
        '𝞪',
        'av'
    ],
    [
        '𝞫',
        'g'
    ],
    [
        '𝞬',
        'd'
    ],
    [
        '𝞭',
        'e'
    ],
    [
        '𝞮',
        'z'
    ],
    [
        '𝞯',
        'i'
    ],
    [
        '𝞰',
        'i'
    ],
    [
        '𝞱',
        'th'
    ],
    [
        '𝞲',
        'i'
    ],
    [
        '𝞳',
        'k'
    ],
    [
        '𝞴',
        'l'
    ],
    [
        '𝞵',
        'm'
    ],
    [
        '𝞶',
        'n'
    ],
    [
        '𝞷',
        'ks'
    ],
    [
        '𝞸',
        'o'
    ],
    [
        '𝞹',
        'p'
    ],
    [
        '𝞺',
        'r'
    ],
    [
        '𝞻',
        's'
    ],
    [
        '𝞼',
        's'
    ],
    [
        '𝞽',
        't'
    ],
    [
        '𝞾',
        'y'
    ],
    [
        '𝞿',
        'f'
    ],
    [
        '𝟀',
        'x'
    ],
    [
        '𝟁',
        'ps'
    ],
    [
        '𝟂',
        'o'
    ],
    [
        '𝟃',
        'a'
    ],
    [
        '𝟄',
        'e'
    ],
    [
        '𝟅',
        'i'
    ],
    [
        '𝟆',
        'k'
    ],
    [
        '𝟇',
        'f'
    ],
    [
        '𝟈',
        'r'
    ],
    [
        '𝟉',
        'p'
    ],
    [
        '𝟊',
        'F'
    ],
    [
        '𝟋',
        'f'
    ],
    [
        '⒜',
        '(a)'
    ],
    [
        '⒝',
        '(b)'
    ],
    [
        '⒞',
        '(c)'
    ],
    [
        '⒟',
        '(d)'
    ],
    [
        '⒠',
        '(e)'
    ],
    [
        '⒡',
        '(f)'
    ],
    [
        '⒢',
        '(g)'
    ],
    [
        '⒣',
        '(h)'
    ],
    [
        '⒤',
        '(i)'
    ],
    [
        '⒥',
        '(j)'
    ],
    [
        '⒦',
        '(k)'
    ],
    [
        '⒧',
        '(l)'
    ],
    [
        '⒨',
        '(m)'
    ],
    [
        '⒩',
        '(n)'
    ],
    [
        '⒪',
        '(o)'
    ],
    [
        '⒫',
        '(p)'
    ],
    [
        '⒬',
        '(q)'
    ],
    [
        '⒭',
        '(r)'
    ],
    [
        '⒮',
        '(s)'
    ],
    [
        '⒯',
        '(t)'
    ],
    [
        '⒰',
        '(u)'
    ],
    [
        '⒱',
        '(v)'
    ],
    [
        '⒲',
        '(w)'
    ],
    [
        '⒳',
        '(x)'
    ],
    [
        '⒴',
        '(y)'
    ],
    [
        '⒵',
        '(z)'
    ],
    [
        'Ⓐ',
        '(A)'
    ],
    [
        'Ⓑ',
        '(B)'
    ],
    [
        'Ⓒ',
        '(C)'
    ],
    [
        'Ⓓ',
        '(D)'
    ],
    [
        'Ⓔ',
        '(E)'
    ],
    [
        'Ⓕ',
        '(F)'
    ],
    [
        'Ⓖ',
        '(G)'
    ],
    [
        'Ⓗ',
        '(H)'
    ],
    [
        'Ⓘ',
        '(I)'
    ],
    [
        'Ⓙ',
        '(J)'
    ],
    [
        'Ⓚ',
        '(K)'
    ],
    [
        'Ⓛ',
        '(L)'
    ],
    [
        'Ⓝ',
        '(N)'
    ],
    [
        'Ⓞ',
        '(O)'
    ],
    [
        'Ⓟ',
        '(P)'
    ],
    [
        'Ⓠ',
        '(Q)'
    ],
    [
        'Ⓡ',
        '(R)'
    ],
    [
        'Ⓢ',
        '(S)'
    ],
    [
        'Ⓣ',
        '(T)'
    ],
    [
        'Ⓤ',
        '(U)'
    ],
    [
        'Ⓥ',
        '(V)'
    ],
    [
        'Ⓦ',
        '(W)'
    ],
    [
        'Ⓧ',
        '(X)'
    ],
    [
        'Ⓨ',
        '(Y)'
    ],
    [
        'Ⓩ',
        '(Z)'
    ],
    [
        'ⓐ',
        '(a)'
    ],
    [
        'ⓑ',
        '(b)'
    ],
    [
        'ⓒ',
        '(b)'
    ],
    [
        'ⓓ',
        '(c)'
    ],
    [
        'ⓔ',
        '(e)'
    ],
    [
        'ⓕ',
        '(f)'
    ],
    [
        'ⓖ',
        '(g)'
    ],
    [
        'ⓗ',
        '(h)'
    ],
    [
        'ⓘ',
        '(i)'
    ],
    [
        'ⓙ',
        '(j)'
    ],
    [
        'ⓚ',
        '(k)'
    ],
    [
        'ⓛ',
        '(l)'
    ],
    [
        'ⓜ',
        '(m)'
    ],
    [
        'ⓝ',
        '(n)'
    ],
    [
        'ⓞ',
        '(o)'
    ],
    [
        'ⓟ',
        '(p)'
    ],
    [
        'ⓠ',
        '(q)'
    ],
    [
        'ⓡ',
        '(r)'
    ],
    [
        'ⓢ',
        '(s)'
    ],
    [
        'ⓣ',
        '(t)'
    ],
    [
        'ⓤ',
        '(u)'
    ],
    [
        'ⓥ',
        '(v)'
    ],
    [
        'ⓦ',
        '(w)'
    ],
    [
        'ⓧ',
        '(x)'
    ],
    [
        'ⓨ',
        '(y)'
    ],
    [
        'ⓩ',
        '(z)'
    ],
    // Maltese
    [
        'Ċ',
        'C'
    ],
    [
        'ċ',
        'c'
    ],
    [
        'Ġ',
        'G'
    ],
    [
        'ġ',
        'g'
    ],
    [
        'Ħ',
        'H'
    ],
    [
        'ħ',
        'h'
    ],
    [
        'Ż',
        'Z'
    ],
    [
        'ż',
        'z'
    ],
    // Numbers
    [
        '𝟎',
        '0'
    ],
    [
        '𝟏',
        '1'
    ],
    [
        '𝟐',
        '2'
    ],
    [
        '𝟑',
        '3'
    ],
    [
        '𝟒',
        '4'
    ],
    [
        '𝟓',
        '5'
    ],
    [
        '𝟔',
        '6'
    ],
    [
        '𝟕',
        '7'
    ],
    [
        '𝟖',
        '8'
    ],
    [
        '𝟗',
        '9'
    ],
    [
        '𝟘',
        '0'
    ],
    [
        '𝟙',
        '1'
    ],
    [
        '𝟚',
        '2'
    ],
    [
        '𝟛',
        '3'
    ],
    [
        '𝟜',
        '4'
    ],
    [
        '𝟝',
        '5'
    ],
    [
        '𝟞',
        '6'
    ],
    [
        '𝟟',
        '7'
    ],
    [
        '𝟠',
        '8'
    ],
    [
        '𝟡',
        '9'
    ],
    [
        '𝟢',
        '0'
    ],
    [
        '𝟣',
        '1'
    ],
    [
        '𝟤',
        '2'
    ],
    [
        '𝟥',
        '3'
    ],
    [
        '𝟦',
        '4'
    ],
    [
        '𝟧',
        '5'
    ],
    [
        '𝟨',
        '6'
    ],
    [
        '𝟩',
        '7'
    ],
    [
        '𝟪',
        '8'
    ],
    [
        '𝟫',
        '9'
    ],
    [
        '𝟬',
        '0'
    ],
    [
        '𝟭',
        '1'
    ],
    [
        '𝟮',
        '2'
    ],
    [
        '𝟯',
        '3'
    ],
    [
        '𝟰',
        '4'
    ],
    [
        '𝟱',
        '5'
    ],
    [
        '𝟲',
        '6'
    ],
    [
        '𝟳',
        '7'
    ],
    [
        '𝟴',
        '8'
    ],
    [
        '𝟵',
        '9'
    ],
    [
        '𝟶',
        '0'
    ],
    [
        '𝟷',
        '1'
    ],
    [
        '𝟸',
        '2'
    ],
    [
        '𝟹',
        '3'
    ],
    [
        '𝟺',
        '4'
    ],
    [
        '𝟻',
        '5'
    ],
    [
        '𝟼',
        '6'
    ],
    [
        '𝟽',
        '7'
    ],
    [
        '𝟾',
        '8'
    ],
    [
        '𝟿',
        '9'
    ],
    [
        '①',
        '1'
    ],
    [
        '②',
        '2'
    ],
    [
        '③',
        '3'
    ],
    [
        '④',
        '4'
    ],
    [
        '⑤',
        '5'
    ],
    [
        '⑥',
        '6'
    ],
    [
        '⑦',
        '7'
    ],
    [
        '⑧',
        '8'
    ],
    [
        '⑨',
        '9'
    ],
    [
        '⑩',
        '10'
    ],
    [
        '⑪',
        '11'
    ],
    [
        '⑫',
        '12'
    ],
    [
        '⑬',
        '13'
    ],
    [
        '⑭',
        '14'
    ],
    [
        '⑮',
        '15'
    ],
    [
        '⑯',
        '16'
    ],
    [
        '⑰',
        '17'
    ],
    [
        '⑱',
        '18'
    ],
    [
        '⑲',
        '19'
    ],
    [
        '⑳',
        '20'
    ],
    [
        '⑴',
        '1'
    ],
    [
        '⑵',
        '2'
    ],
    [
        '⑶',
        '3'
    ],
    [
        '⑷',
        '4'
    ],
    [
        '⑸',
        '5'
    ],
    [
        '⑹',
        '6'
    ],
    [
        '⑺',
        '7'
    ],
    [
        '⑻',
        '8'
    ],
    [
        '⑼',
        '9'
    ],
    [
        '⑽',
        '10'
    ],
    [
        '⑾',
        '11'
    ],
    [
        '⑿',
        '12'
    ],
    [
        '⒀',
        '13'
    ],
    [
        '⒁',
        '14'
    ],
    [
        '⒂',
        '15'
    ],
    [
        '⒃',
        '16'
    ],
    [
        '⒄',
        '17'
    ],
    [
        '⒅',
        '18'
    ],
    [
        '⒆',
        '19'
    ],
    [
        '⒇',
        '20'
    ],
    [
        '⒈',
        '1.'
    ],
    [
        '⒉',
        '2.'
    ],
    [
        '⒊',
        '3.'
    ],
    [
        '⒋',
        '4.'
    ],
    [
        '⒌',
        '5.'
    ],
    [
        '⒍',
        '6.'
    ],
    [
        '⒎',
        '7.'
    ],
    [
        '⒏',
        '8.'
    ],
    [
        '⒐',
        '9.'
    ],
    [
        '⒑',
        '10.'
    ],
    [
        '⒒',
        '11.'
    ],
    [
        '⒓',
        '12.'
    ],
    [
        '⒔',
        '13.'
    ],
    [
        '⒕',
        '14.'
    ],
    [
        '⒖',
        '15.'
    ],
    [
        '⒗',
        '16.'
    ],
    [
        '⒘',
        '17.'
    ],
    [
        '⒙',
        '18.'
    ],
    [
        '⒚',
        '19.'
    ],
    [
        '⒛',
        '20.'
    ],
    [
        '⓪',
        '0'
    ],
    [
        '⓫',
        '11'
    ],
    [
        '⓬',
        '12'
    ],
    [
        '⓭',
        '13'
    ],
    [
        '⓮',
        '14'
    ],
    [
        '⓯',
        '15'
    ],
    [
        '⓰',
        '16'
    ],
    [
        '⓱',
        '17'
    ],
    [
        '⓲',
        '18'
    ],
    [
        '⓳',
        '19'
    ],
    [
        '⓴',
        '20'
    ],
    [
        '⓵',
        '1'
    ],
    [
        '⓶',
        '2'
    ],
    [
        '⓷',
        '3'
    ],
    [
        '⓸',
        '4'
    ],
    [
        '⓹',
        '5'
    ],
    [
        '⓺',
        '6'
    ],
    [
        '⓻',
        '7'
    ],
    [
        '⓼',
        '8'
    ],
    [
        '⓽',
        '9'
    ],
    [
        '⓾',
        '10'
    ],
    [
        '⓿',
        '0'
    ],
    // Punctuation
    [
        '🙰',
        '&'
    ],
    [
        '🙱',
        '&'
    ],
    [
        '🙲',
        '&'
    ],
    [
        '🙳',
        '&'
    ],
    [
        '🙴',
        '&'
    ],
    [
        '🙵',
        '&'
    ],
    [
        '🙶',
        '"'
    ],
    [
        '🙷',
        '"'
    ],
    [
        '🙸',
        '"'
    ],
    [
        '‽',
        '?!'
    ],
    [
        '🙹',
        '?!'
    ],
    [
        '🙺',
        '?!'
    ],
    [
        '🙻',
        '?!'
    ],
    [
        '🙼',
        '/'
    ],
    [
        '🙽',
        '\\'
    ],
    // Alchemy
    [
        '🜇',
        'AR'
    ],
    [
        '🜈',
        'V'
    ],
    [
        '🜉',
        'V'
    ],
    [
        '🜆',
        'VR'
    ],
    [
        '🜅',
        'VF'
    ],
    [
        '🜩',
        '2'
    ],
    [
        '🜪',
        '5'
    ],
    [
        '🝡',
        'f'
    ],
    [
        '🝢',
        'W'
    ],
    [
        '🝣',
        'U'
    ],
    [
        '🝧',
        'V'
    ],
    [
        '🝨',
        'T'
    ],
    [
        '🝪',
        'V'
    ],
    [
        '🝫',
        'MB'
    ],
    [
        '🝬',
        'VB'
    ],
    [
        '🝲',
        '3B'
    ],
    [
        '🝳',
        '3B'
    ],
    // Emojis
    [
        '💯',
        '100'
    ],
    [
        '🔙',
        'BACK'
    ],
    [
        '🔚',
        'END'
    ],
    [
        '🔛',
        'ON!'
    ],
    [
        '🔜',
        'SOON'
    ],
    [
        '🔝',
        'TOP'
    ],
    [
        '🔞',
        '18'
    ],
    [
        '🔤',
        'abc'
    ],
    [
        '🔠',
        'ABCD'
    ],
    [
        '🔡',
        'abcd'
    ],
    [
        '🔢',
        '1234'
    ],
    [
        '🔣',
        'T&@%'
    ],
    [
        '#️⃣',
        '#'
    ],
    [
        '*️⃣',
        '*'
    ],
    [
        '0️⃣',
        '0'
    ],
    [
        '1️⃣',
        '1'
    ],
    [
        '2️⃣',
        '2'
    ],
    [
        '3️⃣',
        '3'
    ],
    [
        '4️⃣',
        '4'
    ],
    [
        '5️⃣',
        '5'
    ],
    [
        '6️⃣',
        '6'
    ],
    [
        '7️⃣',
        '7'
    ],
    [
        '8️⃣',
        '8'
    ],
    [
        '9️⃣',
        '9'
    ],
    [
        '🔟',
        '10'
    ],
    [
        '🅰️',
        'A'
    ],
    [
        '🅱️',
        'B'
    ],
    [
        '🆎',
        'AB'
    ],
    [
        '🆑',
        'CL'
    ],
    [
        '🅾️',
        'O'
    ],
    [
        '🅿',
        'P'
    ],
    [
        '🆘',
        'SOS'
    ],
    [
        '🅲',
        'C'
    ],
    [
        '🅳',
        'D'
    ],
    [
        '🅴',
        'E'
    ],
    [
        '🅵',
        'F'
    ],
    [
        '🅶',
        'G'
    ],
    [
        '🅷',
        'H'
    ],
    [
        '🅸',
        'I'
    ],
    [
        '🅹',
        'J'
    ],
    [
        '🅺',
        'K'
    ],
    [
        '🅻',
        'L'
    ],
    [
        '🅼',
        'M'
    ],
    [
        '🅽',
        'N'
    ],
    [
        '🆀',
        'Q'
    ],
    [
        '🆁',
        'R'
    ],
    [
        '🆂',
        'S'
    ],
    [
        '🆃',
        'T'
    ],
    [
        '🆄',
        'U'
    ],
    [
        '🆅',
        'V'
    ],
    [
        '🆆',
        'W'
    ],
    [
        '🆇',
        'X'
    ],
    [
        '🆈',
        'Y'
    ],
    [
        '🆉',
        'Z'
    ]
];
const __TURBOPACK__default__export__ = replacements;
}),
"[project]/node_modules/@sindresorhus/transliterate/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>transliterate
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escape$2d$string$2d$regexp$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escape-string-regexp/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$transliterate$2f$replacements$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/transliterate/replacements.js [app-route] (ecmascript)");
;
;
const doCustomReplacements = (string, replacements)=>{
    for (const [key, value] of replacements){
        // TODO: Use `String#replaceAll()` when targeting Node.js 16.
        string = string.replace(new RegExp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escape$2d$string$2d$regexp$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(key), 'g'), value);
    }
    return string;
};
function transliterate(string, options) {
    if (typeof string !== 'string') {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
    }
    options = {
        customReplacements: [],
        ...options
    };
    const customReplacements = new Map([
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$transliterate$2f$replacements$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
        ...options.customReplacements
    ]);
    string = string.normalize();
    string = doCustomReplacements(string, customReplacements);
    string = string.normalize('NFD').replace(/\p{Diacritic}/gu, '').normalize();
    return string;
}
}),
"[project]/node_modules/@sindresorhus/slugify/overridable-replacements.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
const overridableReplacements = [
    [
        '&',
        ' and '
    ],
    [
        '🦄',
        ' unicorn '
    ],
    [
        '♥',
        ' love '
    ]
];
const __TURBOPACK__default__export__ = overridableReplacements;
}),
"[project]/node_modules/@sindresorhus/slugify/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>slugify,
    "slugifyWithCounter": ()=>slugifyWithCounter
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escape$2d$string$2d$regexp$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escape-string-regexp/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$transliterate$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/transliterate/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$slugify$2f$overridable$2d$replacements$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/slugify/overridable-replacements.js [app-route] (ecmascript)");
;
;
;
const decamelize = (string)=>{
    return string// Separate capitalized words.
    .replace(/([A-Z]{2,})(\d+)/g, '$1 $2').replace(/([a-z\d]+)([A-Z]{2,})/g, '$1 $2').replace(/([a-z\d])([A-Z])/g, '$1 $2')// `[a-rt-z]` matches all lowercase characters except `s`.
    // This avoids matching plural acronyms like `APIs`.
    .replace(/([A-Z]+)([A-Z][a-rt-z\d]+)/g, '$1 $2');
};
const removeMootSeparators = (string, separator)=>{
    const escapedSeparator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escape$2d$string$2d$regexp$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(separator);
    return string.replace(new RegExp(`${escapedSeparator}{2,}`, 'g'), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, 'g'), '');
};
const buildPatternSlug = (options)=>{
    let negationSetPattern = 'a-z\\d';
    negationSetPattern += options.lowercase ? '' : 'A-Z';
    if (options.preserveCharacters.length > 0) {
        for (const character of options.preserveCharacters){
            if (character === options.separator) {
                throw new Error(`The separator character \`${options.separator}\` cannot be included in preserved characters: ${options.preserveCharacters}`);
            }
            negationSetPattern += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escape$2d$string$2d$regexp$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(character);
        }
    }
    return new RegExp(`[^${negationSetPattern}]+`, 'g');
};
function slugify(string, options) {
    if (typeof string !== 'string') {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
    }
    options = {
        separator: '-',
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        preserveTrailingDash: false,
        preserveCharacters: [],
        ...options
    };
    const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith('_');
    const shouldAppendDash = options.preserveTrailingDash && string.endsWith('-');
    const customReplacements = new Map([
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$slugify$2f$overridable$2d$replacements$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
        ...options.customReplacements
    ]);
    string = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$transliterate$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(string, {
        customReplacements
    });
    if (options.decamelize) {
        string = decamelize(string);
    }
    const patternSlug = buildPatternSlug(options);
    if (options.lowercase) {
        string = string.toLowerCase();
    }
    // Detect contractions/possessives by looking for any word followed by a `'t`
    // or `'s` in isolation and then remove it.
    string = string.replace(/([a-zA-Z\d]+)'([ts])(\s|$)/g, '$1$2$3');
    string = string.replace(patternSlug, options.separator);
    string = string.replace(/\\/g, '');
    if (options.separator) {
        string = removeMootSeparators(string, options.separator);
    }
    if (shouldPrependUnderscore) {
        string = `_${string}`;
    }
    if (shouldAppendDash) {
        string = `${string}-`;
    }
    return string;
}
function slugifyWithCounter() {
    const occurrences = new Map();
    const countable = (string, options)=>{
        string = slugify(string, options);
        if (!string) {
            return '';
        }
        const stringLower = string.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, '')) || 0;
        const counter = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter === 'number' ? counter + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
            string = `${string}-${newCounter}`;
        }
        return string;
    };
    countable.reset = ()=>{
        occurrences.clear();
    };
    return countable;
}
}),
"[project]/node_modules/bytes/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ /**
 * Module exports.
 * @public
 */ module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;
/**
 * Module variables.
 * @private
 */ var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
};
var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */ function bytes(value, options) {
    if (typeof value === 'string') {
        return parse(value);
    }
    if (typeof value === 'number') {
        return format(value, options);
    }
    return null;
}
/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */ function format(value, options) {
    if (!Number.isFinite(value)) {
        return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || '';
    var unitSeparator = options && options.unitSeparator || '';
    var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || '';
    if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
            unit = 'PB';
        } else if (mag >= map.tb) {
            unit = 'TB';
        } else if (mag >= map.gb) {
            unit = 'GB';
        } else if (mag >= map.mb) {
            unit = 'MB';
        } else if (mag >= map.kb) {
            unit = 'KB';
        } else {
            unit = 'B';
        }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, '$1');
    }
    if (thousandsSeparator) {
        str = str.split('.').map(function(s, i) {
            return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join('.');
    }
    return str + unitSeparator + unit;
}
/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */ function parse(val) {
    if (typeof val === 'number' && !isNaN(val)) {
        return val;
    }
    if (typeof val !== 'string') {
        return null;
    }
    // Test if the string passed is valid
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = 'b';
    if (!results) {
        // Nothing could be extracted from the given string
        floatValue = parseInt(val, 10);
        unit = 'b';
    } else {
        // Retrieve the value and the unit
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
        return null;
    }
    return Math.floor(map[unit] * floatValue);
}
}}),
"[project]/node_modules/depd/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 */ var relative = __turbopack_context__.r("[externals]/path [external] (path, cjs)").relative;
/**
 * Module exports.
 */ module.exports = depd;
/**
 * Get the path to base files on.
 */ var basePath = process.cwd();
/**
 * Determine if namespace is contained in the string.
 */ function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for(var i = 0; i < vals.length; i++){
        var val = vals[i];
        // namespace contained
        if (val && (val === '*' || val.toLowerCase() === ns)) {
            return true;
        }
    }
    return false;
}
/**
 * Convert a data descriptor to accessor descriptor.
 */ function convertDataDescriptorToAccessor(obj, prop, message) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
        return value;
    };
    if (descriptor.writable) {
        descriptor.set = function setter(val) {
            return value = val;
        };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
}
/**
 * Create arguments string to keep arity.
 */ function createArgumentsString(arity) {
    var str = '';
    for(var i = 0; i < arity; i++){
        str += ', arg' + i;
    }
    return str.substr(2);
}
/**
 * Create stack string from stack.
 */ function createStackString(stack) {
    var str = this.name + ': ' + this.namespace;
    if (this.message) {
        str += ' deprecated ' + this.message;
    }
    for(var i = 0; i < stack.length; i++){
        str += '\n    at ' + stack[i].toString();
    }
    return str;
}
/**
 * Create deprecate for namespace in caller.
 */ function depd(namespace) {
    if (!namespace) {
        throw new TypeError('argument namespace is required');
    }
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    var file = site[0];
    function deprecate(message) {
        // call to self as log
        log.call(deprecate, message);
    }
    deprecate._file = file;
    deprecate._ignored = isignored(namespace);
    deprecate._namespace = namespace;
    deprecate._traced = istraced(namespace);
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
}
/**
 * Determine if event emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */ function eehaslisteners(emitter, type) {
    var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
}
/**
 * Determine if namespace is ignored.
 */ function isignored(namespace) {
    if (process.noDeprecation) {
        // --no-deprecation support
        return true;
    }
    var str = process.env.NO_DEPRECATION || '';
    // namespace ignored
    return containsNamespace(str, namespace);
}
/**
 * Determine if namespace is traced.
 */ function istraced(namespace) {
    if (process.traceDeprecation) {
        // --trace-deprecation support
        return true;
    }
    var str = process.env.TRACE_DEPRECATION || '';
    // namespace traced
    return containsNamespace(str, namespace);
}
/**
 * Display deprecation message.
 */ function log(message, site) {
    var haslisteners = eehaslisteners(process, 'deprecation');
    // abort early if no destination
    if (!haslisteners && this._ignored) {
        return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack = getStack();
    var file = this._file;
    if (site) {
        // provided site
        depSite = site;
        callSite = callSiteLocation(stack[1]);
        callSite.name = depSite.name;
        file = callSite[0];
    } else {
        // get call site
        i = 2;
        depSite = callSiteLocation(stack[i]);
        callSite = depSite;
    }
    // get caller of deprecated thing in relation to file
    for(; i < stack.length; i++){
        caller = callSiteLocation(stack[i]);
        callFile = caller[0];
        if (callFile === file) {
            seen = true;
        } else if (callFile === this._file) {
            file = this._file;
        } else if (seen) {
            break;
        }
    }
    var key = caller ? depSite.join(':') + '__' + caller.join(':') : undefined;
    if (key !== undefined && key in this._warned) {
        // already warned
        return;
    }
    this._warned[key] = true;
    // generate automatic message from call site
    var msg = message;
    if (!msg) {
        msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
    }
    // emit deprecation if listeners exist
    if (haslisteners) {
        var err = DeprecationError(this._namespace, msg, stack.slice(i));
        process.emit('deprecation', err);
        return;
    }
    // format and write message
    var format = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format.call(this, msg, caller, stack.slice(i));
    process.stderr.write(output + '\n', 'utf8');
}
/**
 * Get call site location as array.
 */ function callSiteLocation(callSite) {
    var file = callSite.getFileName() || '<anonymous>';
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
        file = callSite.getEvalOrigin() + ', ' + file;
    }
    var site = [
        file,
        line,
        colm
    ];
    site.callSite = callSite;
    site.name = callSite.getFunctionName();
    return site;
}
/**
 * Generate a default message from the site.
 */ function defaultMessage(site) {
    var callSite = site.callSite;
    var funcName = site.name;
    // make useful anonymous name
    if (!funcName) {
        funcName = '<anonymous@' + formatLocation(site) + '>';
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();
    // ignore useless type name
    if (typeName === 'Object') {
        typeName = undefined;
    }
    // make useful type name
    if (typeName === 'Function') {
        typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
}
/**
 * Format deprecation message without color.
 */ function formatPlain(msg, caller, stack) {
    var timestamp = new Date().toUTCString();
    var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;
    // add stack trace
    if (this._traced) {
        for(var i = 0; i < stack.length; i++){
            formatted += '\n    at ' + stack[i].toString();
        }
        return formatted;
    }
    if (caller) {
        formatted += ' at ' + formatLocation(caller);
    }
    return formatted;
}
/**
 * Format deprecation message with color.
 */ function formatColor(msg, caller, stack) {
    var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m' // reset
    ;
    // add stack trace
    if (this._traced) {
        for(var i = 0; i < stack.length; i++){
            formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m'; // cyan
        }
        return formatted;
    }
    if (caller) {
        formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
    }
    return formatted;
}
/**
 * Format call site location.
 */ function formatLocation(callSite) {
    return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
}
/**
 * Get the stack as array of call sites.
 */ function getStack() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit);
    // capture the stack
    Error.captureStackTrace(obj);
    // slice this function off the top
    var stack = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack;
}
/**
 * Capture call site stack from v8.
 */ function prepareObjectStackTrace(obj, stack) {
    return stack;
}
/**
 * Return a wrapped function in a deprecation message.
 */ function wrapfunction(fn, message) {
    if (typeof fn !== 'function') {
        throw new TypeError('argument fn must be a function');
    }
    var args = createArgumentsString(fn.length);
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;
    // eslint-disable-next-line no-new-func
    var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '"use strict"\n' + 'return function (' + args + ') {' + 'log.call(deprecate, message, site)\n' + 'return fn.apply(this, arguments)\n' + '}')(fn, log, this, message, site);
    return deprecatedfn;
}
/**
 * Wrap property in a deprecation message.
 */ function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('argument obj must be object');
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
        throw new TypeError('must call property on owner object');
    }
    if (!descriptor.configurable) {
        throw new TypeError('property must be configurable');
    }
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    // set site name
    site.name = prop;
    // convert data descriptor
    if ('value' in descriptor) {
        descriptor = convertDataDescriptorToAccessor(obj, prop, message);
    }
    var get = descriptor.get;
    var set = descriptor.set;
    // wrap getter
    if (typeof get === 'function') {
        descriptor.get = function getter() {
            log.call(deprecate, message, site);
            return get.apply(this, arguments);
        };
    }
    // wrap setter
    if (typeof set === 'function') {
        descriptor.set = function setter() {
            log.call(deprecate, message, site);
            return set.apply(this, arguments);
        };
    }
    Object.defineProperty(obj, prop, descriptor);
}
/**
 * Create DeprecationError for deprecation
 */ function DeprecationError(namespace, message, stack) {
    var error = new Error();
    var stackString;
    Object.defineProperty(error, 'constructor', {
        value: DeprecationError
    });
    Object.defineProperty(error, 'message', {
        configurable: true,
        enumerable: false,
        value: message,
        writable: true
    });
    Object.defineProperty(error, 'name', {
        enumerable: false,
        configurable: true,
        value: 'DeprecationError',
        writable: true
    });
    Object.defineProperty(error, 'namespace', {
        configurable: true,
        enumerable: false,
        value: namespace,
        writable: true
    });
    Object.defineProperty(error, 'stack', {
        configurable: true,
        enumerable: false,
        get: function() {
            if (stackString !== undefined) {
                return stackString;
            }
            // prepare stack trace
            return stackString = createStackString.call(this, stack);
        },
        set: function setter(val) {
            stackString = val;
        }
    });
    return error;
}
}}),
"[project]/node_modules/setprototypeof/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint no-proto: 0 */ module.exports = Object.setPrototypeOf || (({
    __proto__: []
}) instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
}
function mixinProperties(obj, proto) {
    for(var prop in proto){
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
            obj[prop] = proto[prop];
        }
    }
    return obj;
}
}}),
"[project]/node_modules/http-errors/node_modules/statuses/codes.json (json)": ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"100\":\"Continue\",\"101\":\"Switching Protocols\",\"102\":\"Processing\",\"103\":\"Early Hints\",\"200\":\"OK\",\"201\":\"Created\",\"202\":\"Accepted\",\"203\":\"Non-Authoritative Information\",\"204\":\"No Content\",\"205\":\"Reset Content\",\"206\":\"Partial Content\",\"207\":\"Multi-Status\",\"208\":\"Already Reported\",\"226\":\"IM Used\",\"300\":\"Multiple Choices\",\"301\":\"Moved Permanently\",\"302\":\"Found\",\"303\":\"See Other\",\"304\":\"Not Modified\",\"305\":\"Use Proxy\",\"307\":\"Temporary Redirect\",\"308\":\"Permanent Redirect\",\"400\":\"Bad Request\",\"401\":\"Unauthorized\",\"402\":\"Payment Required\",\"403\":\"Forbidden\",\"404\":\"Not Found\",\"405\":\"Method Not Allowed\",\"406\":\"Not Acceptable\",\"407\":\"Proxy Authentication Required\",\"408\":\"Request Timeout\",\"409\":\"Conflict\",\"410\":\"Gone\",\"411\":\"Length Required\",\"412\":\"Precondition Failed\",\"413\":\"Payload Too Large\",\"414\":\"URI Too Long\",\"415\":\"Unsupported Media Type\",\"416\":\"Range Not Satisfiable\",\"417\":\"Expectation Failed\",\"418\":\"I'm a Teapot\",\"421\":\"Misdirected Request\",\"422\":\"Unprocessable Entity\",\"423\":\"Locked\",\"424\":\"Failed Dependency\",\"425\":\"Too Early\",\"426\":\"Upgrade Required\",\"428\":\"Precondition Required\",\"429\":\"Too Many Requests\",\"431\":\"Request Header Fields Too Large\",\"451\":\"Unavailable For Legal Reasons\",\"500\":\"Internal Server Error\",\"501\":\"Not Implemented\",\"502\":\"Bad Gateway\",\"503\":\"Service Unavailable\",\"504\":\"Gateway Timeout\",\"505\":\"HTTP Version Not Supported\",\"506\":\"Variant Also Negotiates\",\"507\":\"Insufficient Storage\",\"508\":\"Loop Detected\",\"509\":\"Bandwidth Limit Exceeded\",\"510\":\"Not Extended\",\"511\":\"Network Authentication Required\"}"));}),
"[project]/node_modules/http-errors/node_modules/statuses/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var codes = __turbopack_context__.r("[project]/node_modules/http-errors/node_modules/statuses/codes.json (json)");
/**
 * Module exports.
 * @public
 */ module.exports = status;
// status code to message map
status.message = codes;
// status message (lower-case) to code map
status.code = createMessageToStatusCodeMap(codes);
// array of status codes
status.codes = createStatusCodeList(codes);
// status codes for redirects
status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
};
// status codes for empty bodies
status.empty = {
    204: true,
    205: true,
    304: true
};
// status codes for when you should retry the request
status.retry = {
    502: true,
    503: true,
    504: true
};
/**
 * Create a map of message to status code.
 * @private
 */ function createMessageToStatusCodeMap(codes) {
    var map = {};
    Object.keys(codes).forEach(function forEachCode(code) {
        var message = codes[code];
        var status = Number(code);
        // populate map
        map[message.toLowerCase()] = status;
    });
    return map;
}
/**
 * Create a list of all status codes.
 * @private
 */ function createStatusCodeList(codes) {
    return Object.keys(codes).map(function mapCode(code) {
        return Number(code);
    });
}
/**
 * Get the status code for given message.
 * @private
 */ function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
}
/**
 * Get the status message for given code.
 * @private
 */ function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error('invalid status code: ' + code);
    }
    return status.message[code];
}
/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */ function status(code) {
    if (typeof code === 'number') {
        return getStatusMessage(code);
    }
    if (typeof code !== 'string') {
        throw new TypeError('code must be a number or string');
    }
    // '403'
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
        return getStatusMessage(n);
    }
    return getStatusCode(code);
}
}}),
"[project]/node_modules/inherits/inherits_browser.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
} else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
}
}}),
"[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
try {
    var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
    /* istanbul ignore next */ if (typeof util.inherits !== 'function') throw '';
    module.exports = util.inherits;
} catch (e) {
    /* istanbul ignore next */ module.exports = __turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-route] (ecmascript)");
}
}}),
"[project]/node_modules/toidentifier/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module exports.
 * @public
 */ module.exports = toIdentifier;
/**
 * Trasform the given string into a JavaScript identifier
 *
 * @param {string} str
 * @returns {string}
 * @public
 */ function toIdentifier(str) {
    return str.split(' ').map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join('').replace(/[^ _0-9a-z]/gi, '');
}
}}),
"[project]/node_modules/http-errors/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var deprecate = __turbopack_context__.r("[project]/node_modules/depd/index.js [app-route] (ecmascript)")('http-errors');
var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/setprototypeof/index.js [app-route] (ecmascript)");
var statuses = __turbopack_context__.r("[project]/node_modules/http-errors/node_modules/statuses/index.js [app-route] (ecmascript)");
var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)");
var toIdentifier = __turbopack_context__.r("[project]/node_modules/toidentifier/index.js [app-route] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = createError;
module.exports.HttpError = createHttpErrorConstructor();
module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
/**
 * Get the code class of a status code.
 * @private
 */ function codeClass(status) {
    return Number(String(status).charAt(0) + '00');
}
/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */ function createError() {
    // so much arity going on ~_~
    var err;
    var msg;
    var status = 500;
    var props = {};
    for(var i = 0; i < arguments.length; i++){
        var arg = arguments[i];
        var type = typeof arg;
        if (type === 'object' && arg instanceof Error) {
            err = arg;
            status = err.status || err.statusCode || status;
        } else if (type === 'number' && i === 0) {
            status = arg;
        } else if (type === 'string') {
            msg = arg;
        } else if (type === 'object') {
            props = arg;
        } else {
            throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type);
        }
    }
    if (typeof status === 'number' && (status < 400 || status >= 600)) {
        deprecate('non-error status code; use only 4xx or 5xx status codes');
    }
    if (typeof status !== 'number' || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
    }
    // constructor
    var HttpError = createError[status] || createError[codeClass(status)];
    if (!err) {
        // create error
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        // add properties to generic error
        err.expose = status < 500;
        err.status = err.statusCode = status;
    }
    for(var key in props){
        if (key !== 'status' && key !== 'statusCode') {
            err[key] = props[key];
        }
    }
    return err;
}
/**
 * Create HTTP error abstract base class.
 * @private
 */ function createHttpErrorConstructor() {
    function HttpError() {
        throw new TypeError('cannot construct abstract class');
    }
    inherits(HttpError, Error);
    return HttpError;
}
/**
 * Create a constructor for a client error.
 * @private
 */ function createClientErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ClientError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ClientError);
        // adjust the [[Prototype]]
        setPrototypeOf(err, ClientError.prototype);
        // redefine the error message
        Object.defineProperty(err, 'message', {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
        });
        // redefine the error name
        Object.defineProperty(err, 'name', {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
        });
        return err;
    }
    inherits(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
}
/**
 * Create function to test is a value is a HttpError.
 * @private
 */ function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
        if (!val || typeof val !== 'object') {
            return false;
        }
        if (val instanceof HttpError) {
            return true;
        }
        return val instanceof Error && typeof val.expose === 'boolean' && typeof val.statusCode === 'number' && val.status === val.statusCode;
    };
}
/**
 * Create a constructor for a server error.
 * @private
 */ function createServerErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ServerError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ServerError);
        // adjust the [[Prototype]]
        setPrototypeOf(err, ServerError.prototype);
        // redefine the error message
        Object.defineProperty(err, 'message', {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
        });
        // redefine the error name
        Object.defineProperty(err, 'name', {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
        });
        return err;
    }
    inherits(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
}
/**
 * Set the name of a function, if possible.
 * @private
 */ function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, 'name');
    if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, 'name', desc);
    }
}
/**
 * Populate the exports object with constructors for every error class.
 * @private
 */ function populateConstructorExports(exports, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch(codeClass(code)){
            case 400:
                CodeError = createClientErrorConstructor(HttpError, name, code);
                break;
            case 500:
                CodeError = createServerErrorConstructor(HttpError, name, code);
                break;
        }
        if (CodeError) {
            // export the constructor
            exports[code] = CodeError;
            exports[name] = CodeError;
        }
    });
}
/**
 * Get a class name from a name identifier.
 * @private
 */ function toClassName(name) {
    return name.substr(-5) !== 'Error' ? name + 'Error' : name;
}
}}),
"[project]/node_modules/safer-buffer/safer.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
var Buffer = buffer.Buffer;
var safer = {};
var key;
for(key in buffer){
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === 'SlowBuffer' || key === 'Buffer') continue;
    safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for(key in Buffer){
    if (!Buffer.hasOwnProperty(key)) continue;
    if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
    Safer[key] = Buffer[key];
}
safer.Buffer.prototype = Buffer.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === 'number') {
            throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === 'undefined') {
            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
        }
        return Buffer(value, encodingOrOffset, length);
    };
}
if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== 'number') {
            throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer(size);
        if (!fill || fill.length === 0) {
            buf.fill(0);
        } else if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
        return buf;
    };
}
if (!safer.kStringMaxLength) {
    try {
        safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
    } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
    }
}
if (!safer.constants) {
    safer.constants = {
        MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
}
module.exports = safer;
}}),
"[project]/node_modules/unpipe/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module exports.
 * @public
 */ module.exports = unpipe;
/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */ function hasPipeDataListeners(stream) {
    var listeners = stream.listeners('data');
    for(var i = 0; i < listeners.length; i++){
        if (listeners[i].name === 'ondata') {
            return true;
        }
    }
    return false;
}
/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */ function unpipe(stream) {
    if (!stream) {
        throw new TypeError('argument stream is required');
    }
    if (typeof stream.unpipe === 'function') {
        // new-style
        stream.unpipe();
        return;
    }
    // Node.js 0.8 hack
    if (!hasPipeDataListeners(stream)) {
        return;
    }
    var listener;
    var listeners = stream.listeners('close');
    for(var i = 0; i < listeners.length; i++){
        listener = listeners[i];
        if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
            continue;
        }
        // invoke the listener
        listener.call(stream);
    }
}
}}),
"[project]/node_modules/raw-body/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var asyncHooks = tryRequireAsyncHooks();
var bytes = __turbopack_context__.r("[project]/node_modules/bytes/index.js [app-route] (ecmascript)");
var createError = __turbopack_context__.r("[project]/node_modules/http-errors/index.js [app-route] (ecmascript)");
var iconv = __turbopack_context__.r("[project]/node_modules/iconv-lite/lib/index.js [app-route] (ecmascript)");
var unpipe = __turbopack_context__.r("[project]/node_modules/unpipe/index.js [app-route] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = getRawBody;
/**
 * Module variables.
 * @private
 */ var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */ function getDecoder(encoding) {
    if (!encoding) return null;
    try {
        return iconv.getDecoder(encoding);
    } catch (e) {
        // error getting decoder
        if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
        // the encoding was not found
        throw createError(415, 'specified encoding unsupported', {
            encoding: encoding,
            type: 'encoding.unsupported'
        });
    }
}
/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */ function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    // light validation
    if (stream === undefined) {
        throw new TypeError('argument stream is required');
    } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
        throw new TypeError('argument stream must be a stream');
    }
    if (options === true || typeof options === 'string') {
        // short cut for encoding
        opts = {
            encoding: options
        };
    }
    if (typeof options === 'function') {
        done = options;
        opts = {};
    }
    // validate callback is a function, if provided
    if (done !== undefined && typeof done !== 'function') {
        throw new TypeError('argument callback must be a function');
    }
    // require the callback without promises
    if (!done && !("TURBOPACK ident replacement", globalThis).Promise) {
        throw new TypeError('argument callback is required');
    }
    // get encoding
    var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';
    // convert the limit to an integer
    var limit = bytes.parse(opts.limit);
    // convert the expected length to an integer
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
        // classic callback style
        return readStream(stream, encoding, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
            if (err) return reject(err);
            resolve(buf);
        });
    });
}
/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */ function halt(stream) {
    // unpipe everything from the stream
    unpipe(stream);
    // pause stream
    if (typeof stream.pause === 'function') {
        stream.pause();
    }
}
/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */ function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync = true;
    // check the length and limit options.
    // note: we intentionally leave the stream paused,
    // so users should handle the stream themselves.
    if (limit !== null && length !== null && length > limit) {
        return done(createError(413, 'request entity too large', {
            expected: length,
            length: length,
            limit: limit,
            type: 'entity.too.large'
        }));
    }
    // streams1: assert request encoding is buffer.
    // streams2+: assert the stream encoding is buffer.
    //   stream._decoder: streams1
    //   state.encoding: streams2
    //   state.decoder: streams2, specifically < 0.10.6
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
        // developer error
        return done(createError(500, 'stream encoding should not be set', {
            type: 'stream.encoding.set'
        }));
    }
    if (typeof stream.readable !== 'undefined' && !stream.readable) {
        return done(createError(500, 'stream is not readable', {
            type: 'stream.not.readable'
        }));
    }
    var received = 0;
    var decoder;
    try {
        decoder = getDecoder(encoding);
    } catch (err) {
        return done(err);
    }
    var buffer = decoder ? '' : [];
    // attach listeners
    stream.on('aborted', onAborted);
    stream.on('close', cleanup);
    stream.on('data', onData);
    stream.on('end', onEnd);
    stream.on('error', onEnd);
    // mark sync section complete
    sync = false;
    function done() {
        var args = new Array(arguments.length);
        // copy arguments
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        // mark complete
        complete = true;
        if (sync) {
            process.nextTick(invokeCallback);
        } else {
            invokeCallback();
        }
        function invokeCallback() {
            cleanup();
            if (args[0]) {
                // halt the stream on error
                halt(stream);
            }
            callback.apply(null, args);
        }
    }
    function onAborted() {
        if (complete) return;
        done(createError(400, 'request aborted', {
            code: 'ECONNABORTED',
            expected: length,
            length: length,
            received: received,
            type: 'request.aborted'
        }));
    }
    function onData(chunk) {
        if (complete) return;
        received += chunk.length;
        if (limit !== null && received > limit) {
            done(createError(413, 'request entity too large', {
                limit: limit,
                received: received,
                type: 'entity.too.large'
            }));
        } else if (decoder) {
            buffer += decoder.write(chunk);
        } else {
            buffer.push(chunk);
        }
    }
    function onEnd(err) {
        if (complete) return;
        if (err) return done(err);
        if (length !== null && received !== length) {
            done(createError(400, 'request size did not match content length', {
                expected: length,
                length: length,
                received: received,
                type: 'request.size.invalid'
            }));
        } else {
            var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
            done(null, string);
        }
    }
    function cleanup() {
        buffer = null;
        stream.removeListener('aborted', onAborted);
        stream.removeListener('data', onData);
        stream.removeListener('end', onEnd);
        stream.removeListener('error', onEnd);
        stream.removeListener('close', cleanup);
    }
}
/**
 * Try to require async_hooks
 * @private
 */ function tryRequireAsyncHooks() {
    try {
        return __turbopack_context__.r("[externals]/async_hooks [external] (async_hooks, cjs)");
    } catch (e) {
        return {};
    }
}
/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */ function wrap(fn) {
    var res;
    // create anonymous resource
    if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
    }
    // incompatible node.js
    if (!res || !res.runInAsyncScope) {
        return fn;
    }
    // return bound function
    return res.runInAsyncScope.bind(res, fn, null);
}
}}),
"[project]/node_modules/content-type/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */ var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex
;
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/ // eslint-disable-line no-control-regex
;
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */ var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g // eslint-disable-line no-control-regex
;
/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */ var QUOTE_REGEXP = /([\\"])/g;
/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */ var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
/**
 * Module exports.
 * @public
 */ exports.format = format;
exports.parse = parse;
/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */ function format(obj) {
    if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required');
    }
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || !TYPE_REGEXP.test(type)) {
        throw new TypeError('invalid type');
    }
    var string = type;
    // append parameters
    if (parameters && typeof parameters === 'object') {
        var param;
        var params = Object.keys(parameters).sort();
        for(var i = 0; i < params.length; i++){
            param = params[i];
            if (!TOKEN_REGEXP.test(param)) {
                throw new TypeError('invalid parameter name');
            }
            string += '; ' + param + '=' + qstring(parameters[param]);
        }
    }
    return string;
}
/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */ function parse(string) {
    if (!string) {
        throw new TypeError('argument string is required');
    }
    // support req/res-like objects as argument
    var header = typeof string === 'object' ? getcontenttype(string) : string;
    if (typeof header !== 'string') {
        throw new TypeError('argument string is required to be a string');
    }
    var index = header.indexOf(';');
    var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type)) {
        throw new TypeError('invalid media type');
    }
    var obj = new ContentType(type.toLowerCase());
    // parse parameters
    if (index !== -1) {
        var key;
        var match;
        var value;
        PARAM_REGEXP.lastIndex = index;
        while(match = PARAM_REGEXP.exec(header)){
            if (match.index !== index) {
                throw new TypeError('invalid parameter format');
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value = match[2];
            if (value.charCodeAt(0) === 0x22 /* " */ ) {
                // remove quotes
                value = value.slice(1, -1);
                // remove escapes
                if (value.indexOf('\\') !== -1) {
                    value = value.replace(QESC_REGEXP, '$1');
                }
            }
            obj.parameters[key] = value;
        }
        if (index !== header.length) {
            throw new TypeError('invalid parameter format');
        }
    }
    return obj;
}
/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */ function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === 'function') {
        // res-like
        header = obj.getHeader('content-type');
    } else if (typeof obj.headers === 'object') {
        // req-like
        header = obj.headers && obj.headers['content-type'];
    }
    if (typeof header !== 'string') {
        throw new TypeError('content-type header is missing from object');
    }
    return header;
}
/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function qstring(val) {
    var str = String(val);
    // no need to quote tokens
    if (TOKEN_REGEXP.test(str)) {
        return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
        throw new TypeError('invalid parameter value');
    }
    return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
}
/**
 * Class to represent a content type.
 * @private
 */ function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
}
}}),

};

//# sourceMappingURL=node_modules_d6f00366._.js.map