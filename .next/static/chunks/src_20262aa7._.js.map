{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport const getInitials = (str: string): string => {\n  if (typeof str !== \"string\" || !str.trim()) return \"?\";\n\n  return (\n    str\n      .trim()\n      .split(/\\s+/)\n      .filter(Boolean)\n      .map((word) => word[0])\n      .join(\"\")\n      .toUpperCase() || \"?\"\n  );\n};\n\nexport function formatCurrency(\n  amount: number,\n  opts?: {\n    currency?: string;\n    locale?: string;\n    minimumFractionDigits?: number;\n    maximumFractionDigits?: number;\n    noDecimals?: boolean;\n  },\n) {\n  const {\n    currency = \"USD\",\n    locale = \"en-US\",\n    minimumFractionDigits,\n    maximumFractionDigits,\n    noDecimals,\n  } = opts ?? {};\n\n  const formatOptions: Intl.NumberFormatOptions = {\n    style: \"currency\",\n    currency,\n    minimumFractionDigits: noDecimals ? 0 : minimumFractionDigits,\n    maximumFractionDigits: noDecimals ? 0 : maximumFractionDigits,\n  };\n\n  return new Intl.NumberFormat(locale, formatOptions).format(amount);\n}\n\nexport function formatTimeRemaining(timeLeftMs: number): string {\n  if (timeLeftMs <= 0) return \"Expired\";\n\n  const days = Math.floor(timeLeftMs / (1000 * 60 * 60 * 24));\n  const hours = Math.floor(\n    (timeLeftMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60),\n  );\n  const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));\n  const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);\n\n  const parts = [];\n  if (days > 0) parts.push(`${days}d`);\n  if (hours > 0) parts.push(`${hours}h`);\n  if (minutes > 0) parts.push(`${minutes}m`);\n  if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`);\n\n  return parts.join(\" \") + \" remaining\";\n}\n\nexport function getTimeBreakdown(timeLeftMs: number) {\n  const days = Math.floor(timeLeftMs / (1000 * 60 * 60 * 24));\n  const hours = Math.floor(\n    (timeLeftMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60),\n  );\n  const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));\n  const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);\n\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    isExpired: timeLeftMs <= 0,\n    isExpiringSoon: timeLeftMs <= 300000, // 5 minutes\n  };\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AAEO,SAAS;IAAG,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,SAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAG,OAAH,QAAA,SAAA,CAAA,KAAuB;;IACxC,OAAO,CAAA,GAAA,8JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,OAAI,AAAD,EAAE;AACtB;AAEO,MAAM,cAAc,CAAC;IAC1B,IAAI,OAAO,QAAQ,YAAY,CAAC,IAAI,IAAI,IAAI,OAAO;IAEnD,OACE,IACG,IAAI,GACJ,KAAK,CAAC,OACN,MAAM,CAAC,SACP,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,EAAE,EACrB,IAAI,CAAC,IACL,WAAW,MAAM;AAExB;AAEO,SAAS,eACd,MAAc,EACd,IAMC;IAED,MAAM,EACJ,WAAW,KAAK,EAChB,SAAS,OAAO,EAChB,qBAAqB,EACrB,qBAAqB,EACrB,UAAU,EACX,GAAG,iBAAA,kBAAA,OAAQ,CAAC;IAEb,MAAM,gBAA0C;QAC9C,OAAO;QACP;QACA,uBAAuB,aAAa,IAAI;QACxC,uBAAuB,aAAa,IAAI;IAC1C;IAEA,OAAO,IAAI,KAAK,YAAY,CAAC,QAAQ,eAAe,MAAM,CAAC;AAC7D;AAEO,SAAS,oBAAoB,UAAkB;IACpD,IAAI,cAAc,GAAG,OAAO;IAE5B,MAAM,OAAO,KAAK,KAAK,CAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE;IACzD,MAAM,QAAQ,KAAK,KAAK,CACtB,AAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE,IAAK,CAAC,OAAO,KAAK,EAAE;IAExD,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,KAAK,EAAE,IAAK,CAAC,OAAO,EAAE;IACvE,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,EAAE,IAAK;IAExD,MAAM,QAAQ,EAAE;IAChB,IAAI,OAAO,GAAG,MAAM,IAAI,CAAC,AAAC,GAAO,OAAL,MAAK;IACjC,IAAI,QAAQ,GAAG,MAAM,IAAI,CAAC,AAAC,GAAQ,OAAN,OAAM;IACnC,IAAI,UAAU,GAAG,MAAM,IAAI,CAAC,AAAC,GAAU,OAAR,SAAQ;IACvC,IAAI,UAAU,KAAK,MAAM,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,AAAC,GAAU,OAAR,SAAQ;IAE7D,OAAO,MAAM,IAAI,CAAC,OAAO;AAC3B;AAEO,SAAS,iBAAiB,UAAkB;IACjD,MAAM,OAAO,KAAK,KAAK,CAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE;IACzD,MAAM,QAAQ,KAAK,KAAK,CACtB,AAAC,aAAa,CAAC,OAAO,KAAK,KAAK,EAAE,IAAK,CAAC,OAAO,KAAK,EAAE;IAExD,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,KAAK,EAAE,IAAK,CAAC,OAAO,EAAE;IACvE,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,aAAa,CAAC,OAAO,EAAE,IAAK;IAExD,OAAO;QACL;QACA;QACA;QACA;QACA,WAAW,cAAc;QACzB,gBAAgB,cAAc;IAChC;AACF","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/chat-utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\nimport { ChatMessage } from \"./chat-types\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function generateId(): string {\n  return Math.random().toString(36).substr(2, 9);\n}\n\nexport function sanitizeText(text: string): string {\n  // Basic sanitization - in production you might want more robust sanitization\n  return text.trim();\n}\n\nexport function formatTimestamp(date: Date): string {\n  return new Intl.DateTimeFormat(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  }).format(date);\n}\n\nexport function formatMessageDate(date: Date): string {\n  const now = new Date();\n  const diffInMs = now.getTime() - date.getTime();\n  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n\n  if (diffInDays === 0) {\n    return formatTimestamp(date);\n  } else if (diffInDays === 1) {\n    return `Yesterday ${formatTimestamp(date)}`;\n  } else if (diffInDays < 7) {\n    return `${diffInDays} days ago`;\n  } else {\n    return new Intl.DateTimeFormat(\"en-US\", {\n      month: \"short\",\n      day: \"numeric\",\n      year: date.getFullYear() !== now.getFullYear() ? \"numeric\" : undefined,\n    }).format(date);\n  }\n}\n\nexport function createMessage(\n  role: \"user\" | \"assistant\",\n  content: string,\n  attachments?: any[],\n): ChatMessage {\n  return {\n    id: generateId(),\n    role,\n    content,\n    timestamp: new Date(),\n    attachments,\n    metadata: {\n      createdAt: new Date().toISOString(),\n    },\n  };\n}\n\nexport function isValidFileType(file: File): boolean {\n  const allowedTypes = [\n    \"text/plain\",\n    \"application/pdf\",\n    \"image/jpeg\",\n    \"image/jpg\",\n    \"image/png\",\n    \"image/gif\",\n    \"image/webp\",\n    \"application/json\",\n    \"text/csv\",\n    \"application/vnd.ms-excel\",\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  ];\n\n  return allowedTypes.includes(file.type);\n}\n\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return \"0 B\";\n\n  const k = 1024;\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n}\n\nexport function truncateText(text: string, maxLength: number): string {\n  if (text.length <= maxLength) return text;\n  return text.substring(0, maxLength) + \"...\";\n}\n\nexport function scrollToBottom(element?: Element | null) {\n  if (element) {\n    element.scrollTop = element.scrollHeight;\n  } else {\n    window.scrollTo(0, document.body.scrollHeight);\n  }\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number,\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;;;AAGO,SAAS;IAAG,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,SAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAG,OAAH,QAAA,SAAA,CAAA,KAAuB;;IACxC,OAAO,CAAA,GAAA,8JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,OAAI,AAAD,EAAE;AACtB;AAEO,SAAS;IACd,OAAO,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG;AAC9C;AAEO,SAAS,aAAa,IAAY;IACvC,6EAA6E;IAC7E,OAAO,KAAK,IAAI;AAClB;AAEO,SAAS,gBAAgB,IAAU;IACxC,OAAO,IAAI,KAAK,cAAc,CAAC,SAAS;QACtC,MAAM;QACN,QAAQ;QACR,QAAQ;IACV,GAAG,MAAM,CAAC;AACZ;AAEO,SAAS,kBAAkB,IAAU;IAC1C,MAAM,MAAM,IAAI;IAChB,MAAM,WAAW,IAAI,OAAO,KAAK,KAAK,OAAO;IAC7C,MAAM,aAAa,KAAK,KAAK,CAAC,WAAW,CAAC,OAAO,KAAK,KAAK,EAAE;IAE7D,IAAI,eAAe,GAAG;QACpB,OAAO,gBAAgB;IACzB,OAAO,IAAI,eAAe,GAAG;QAC3B,OAAO,AAAC,aAAkC,OAAtB,gBAAgB;IACtC,OAAO,IAAI,aAAa,GAAG;QACzB,OAAO,AAAC,GAAa,OAAX,YAAW;IACvB,OAAO;QACL,OAAO,IAAI,KAAK,cAAc,CAAC,SAAS;YACtC,OAAO;YACP,KAAK;YACL,MAAM,KAAK,WAAW,OAAO,IAAI,WAAW,KAAK,YAAY;QAC/D,GAAG,MAAM,CAAC;IACZ;AACF;AAEO,SAAS,cACd,IAA0B,EAC1B,OAAe,EACf,WAAmB;IAEnB,OAAO;QACL,IAAI;QACJ;QACA;QACA,WAAW,IAAI;QACf;QACA,UAAU;YACR,WAAW,IAAI,OAAO,WAAW;QACnC;IACF;AACF;AAEO,SAAS,gBAAgB,IAAU;IACxC,MAAM,eAAe;QACnB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,OAAO,aAAa,QAAQ,CAAC,KAAK,IAAI;AACxC;AAEO,SAAS,eAAe,KAAa;IAC1C,IAAI,UAAU,GAAG,OAAO;IAExB,MAAM,IAAI;IACV,MAAM,QAAQ;QAAC;QAAK;QAAM;QAAM;KAAK;IACrC,MAAM,IAAI,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,SAAS,KAAK,GAAG,CAAC;IAEhD,OAAO,WAAW,CAAC,QAAQ,KAAK,GAAG,CAAC,GAAG,EAAE,EAAE,OAAO,CAAC,MAAM,MAAM,KAAK,CAAC,EAAE;AACzE;AAEO,SAAS,aAAa,IAAY,EAAE,SAAiB;IAC1D,IAAI,KAAK,MAAM,IAAI,WAAW,OAAO;IACrC,OAAO,KAAK,SAAS,CAAC,GAAG,aAAa;AACxC;AAEO,SAAS,eAAe,OAAwB;IACrD,IAAI,SAAS;QACX,QAAQ,SAAS,GAAG,QAAQ,YAAY;IAC1C,OAAO;QACL,OAAO,QAAQ,CAAC,GAAG,SAAS,IAAI,CAAC,YAAY;IAC/C;AACF;AAEO,SAAS,SACd,IAAO,EACP,IAAY;IAEZ,IAAI;IACJ,OAAO;yCAAI;YAAA;;QACT,aAAa;QACb,UAAU,WAAW,IAAM,QAAQ,OAAO;IAC5C;AACF","debugId":null}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/types.ts"],"sourcesContent":["import { LogHandler } from \"@mastra/mcp\";\nimport { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport { StreamableHTTPClientTransportOptions } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type { ClientCapabilities } from \"@modelcontextprotocol/sdk/types.js\";\n\n// Shared model definitions\nexport type ModelProvider = \"anthropic\" | \"openai\" | \"ollama\";\n\nexport interface ModelDefinition {\n  id: Model | string;\n  name: string;\n  provider: ModelProvider;\n}\n\nexport enum Model {\n  CLAUDE_OPUS_4_0 = \"claude-opus-4-0\",\n  CLAUDE_SONNET_4_0 = \"claude-sonnet-4-0\",\n  CLAUDE_3_7_SONNET_LATEST = \"claude-3-7-sonnet-latest\",\n  CLAUDE_3_5_SONNET_LATEST = \"claude-3-5-sonnet-latest\",\n  CLAUDE_3_5_HAIKU_LATEST = \"claude-3-5-haiku-latest\",\n  O3_MINI = \"o3-mini\",\n  O3 = \"o3\",\n  O4_MINI = \"o4-mini\",\n  GPT_4_1 = \"gpt-4.1\",\n  GPT_4_1_MINI = \"gpt-4.1-mini\",\n  GPT_4_1_NANO = \"gpt-4.1-nano\",\n  GPT_4O = \"gpt-4o\",\n  GPT_4O_MINI = \"gpt-4o-mini\",\n  GPT_4_TURBO = \"gpt-4-turbo\",\n  GPT_4 = \"gpt-4\",\n  GPT_3_5_TURBO = \"gpt-3.5-turbo\",\n  O1 = \"o1\",\n}\n\nexport const SUPPORTED_MODELS: ModelDefinition[] = [\n  {\n    id: Model.CLAUDE_OPUS_4_0,\n    name: \"Claude Opus 4\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_SONNET_4_0,\n    name: \"Claude Sonnet 4\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_3_7_SONNET_LATEST,\n    name: \"Claude Sonnet 3.7\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_3_5_SONNET_LATEST,\n    name: \"Claude Sonnet 3.5\",\n    provider: \"anthropic\",\n  },\n  {\n    id: Model.CLAUDE_3_5_HAIKU_LATEST,\n    name: \"Claude Haiku 3.5\",\n    provider: \"anthropic\",\n  },\n  { id: Model.O3_MINI, name: \"O3 Mini\", provider: \"openai\" },\n  { id: Model.O3, name: \"O3\", provider: \"openai\" },\n  { id: Model.O4_MINI, name: \"O4 Mini\", provider: \"openai\" },\n  { id: Model.GPT_4_1, name: \"GPT-4.1\", provider: \"openai\" },\n  { id: Model.GPT_4_1_MINI, name: \"GPT-4.1 Mini\", provider: \"openai\" },\n  { id: Model.GPT_4_1_NANO, name: \"GPT-4.1 Nano\", provider: \"openai\" },\n  { id: Model.GPT_4O, name: \"GPT-4o\", provider: \"openai\" },\n  { id: Model.GPT_4O_MINI, name: \"GPT-4o Mini\", provider: \"openai\" },\n  { id: Model.GPT_4_TURBO, name: \"GPT-4 Turbo\", provider: \"openai\" },\n  { id: Model.GPT_4, name: \"GPT-4\", provider: \"openai\" },\n  { id: Model.GPT_3_5_TURBO, name: \"GPT-3.5 Turbo\", provider: \"openai\" },\n  { id: Model.O1, name: \"O1\", provider: \"openai\" },\n];\n\n// Helper function to get model by ID\nexport const getModelById = (id: string): ModelDefinition | undefined => {\n  return SUPPORTED_MODELS.find((model) => model.id === id);\n};\n\n// Helper function to check if model is supported\nexport const isModelSupported = (id: string): boolean => {\n  return SUPPORTED_MODELS.some((model) => model.id === id);\n};\n\nexport type BaseServerOptions = {\n  name?: string;\n  logger?: LogHandler;\n  timeout?: number;\n  capabilities?: ClientCapabilities;\n  enableServerLogs?: boolean;\n};\n\nexport type StdioServerDefinition = BaseServerOptions & {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n  url?: never;\n  requestInit?: never;\n  eventSourceInit?: never;\n  reconnectionOptions?: never;\n  sessionId?: never;\n  oauth?: never;\n};\n\nexport type HttpServerDefinition = BaseServerOptions & {\n  url: URL;\n  command?: never;\n  args?: never;\n  env?: never;\n  requestInit?: StreamableHTTPClientTransportOptions[\"requestInit\"];\n  eventSourceInit?: SSEClientTransportOptions[\"eventSourceInit\"];\n  reconnectionOptions?: StreamableHTTPClientTransportOptions[\"reconnectionOptions\"];\n  sessionId?: StreamableHTTPClientTransportOptions[\"sessionId\"];\n  oauth?: any;\n};\n\nexport interface ServerFormData {\n  name: string;\n  type: \"stdio\" | \"http\";\n  command?: string;\n  args?: string[];\n  url?: string;\n  headers?: Record<string, string>;\n  env?: Record<string, string>;\n  useOAuth?: boolean;\n  oauthScopes?: string[];\n}\n\nexport type MastraMCPServerDefinition =\n  | StdioServerDefinition\n  | HttpServerDefinition;\n\nexport interface OauthTokens {\n  client_id: string;\n  client_secret: string;\n  access_token: string;\n  refresh_token: string;\n  expires_in: number;\n  scope: string;\n}\n"],"names":[],"mappings":";;;;;;AAcO,IAAA,AAAK,+BAAA;;;;;;;;;;;;;;;;;;WAAA;;AAoBL,MAAM,mBAAsC;IACjD;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QACE,EAAE;QACF,MAAM;QACN,UAAU;IACZ;IACA;QAAE,EAAE;QAAiB,MAAM;QAAW,UAAU;IAAS;IACzD;QAAE,EAAE;QAAY,MAAM;QAAM,UAAU;IAAS;IAC/C;QAAE,EAAE;QAAiB,MAAM;QAAW,UAAU;IAAS;IACzD;QAAE,EAAE;QAAiB,MAAM;QAAW,UAAU;IAAS;IACzD;QAAE,EAAE;QAAsB,MAAM;QAAgB,UAAU;IAAS;IACnE;QAAE,EAAE;QAAsB,MAAM;QAAgB,UAAU;IAAS;IACnE;QAAE,EAAE;QAAgB,MAAM;QAAU,UAAU;IAAS;IACvD;QAAE,EAAE;QAAqB,MAAM;QAAe,UAAU;IAAS;IACjE;QAAE,EAAE;QAAqB,MAAM;QAAe,UAAU;IAAS;IACjE;QAAE,EAAE;QAAe,MAAM;QAAS,UAAU;IAAS;IACrD;QAAE,EAAE;QAAuB,MAAM;QAAiB,UAAU;IAAS;IACrE;QAAE,EAAE;QAAY,MAAM;QAAM,UAAU;IAAS;CAChD;AAGM,MAAM,eAAe,CAAC;IAC3B,OAAO,iBAAiB,IAAI,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;AACvD;AAGO,MAAM,mBAAmB,CAAC;IAC/B,OAAO,iBAAiB,IAAI,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;AACvD","debugId":null}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/ollama-utils.ts"],"sourcesContent":["interface OllamaModel {\n  name: string;\n  modified_at: string;\n  size: number;\n  digest: string;\n  details: {\n    format: string;\n    family: string;\n    families: string[] | null;\n    parameter_size: string;\n    quantization_level: string;\n  };\n}\n\ninterface OllamaModelsResponse {\n  models: OllamaModel[];\n}\n\nexport class OllamaClient {\n  private baseUrl: string;\n\n  constructor(baseUrl: string = \"http://localhost:11434\") {\n    this.baseUrl = baseUrl;\n  }\n\n  setBaseUrl(baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n\n  async isOllamaRunning(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/version`, {\n        method: \"GET\",\n        signal: AbortSignal.timeout(3000), // 3 second timeout\n      });\n      return response.ok;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async getAvailableModels(): Promise<string[]> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/tags`, {\n        method: \"GET\",\n        signal: AbortSignal.timeout(5000), // 5 second timeout\n      });\n\n      if (!response.ok) {\n        return [];\n      }\n\n      const data: OllamaModelsResponse = await response.json();\n      return data.models.map((model) => model.name);\n    } catch (error) {\n      console.warn(\"Failed to fetch Ollama models:\", error);\n      return [];\n    }\n  }\n\n  async checkModelExists(modelName: string): Promise<boolean> {\n    const availableModels = await this.getAvailableModels();\n    return availableModels.some(\n      (model) => model === modelName || model.startsWith(`${modelName}:`),\n    );\n  }\n\n  async getFilteredAvailableModels(\n    supportedModels: string[],\n  ): Promise<string[]> {\n    const availableModels = await this.getAvailableModels();\n\n    return supportedModels.filter((supportedModel) =>\n      availableModels.some(\n        (availableModel) =>\n          availableModel === supportedModel ||\n          availableModel.startsWith(`${supportedModel}:`),\n      ),\n    );\n  }\n}\n\n// Create a singleton instance\nexport const ollamaClient = new OllamaClient();\n\n// Utility functions\nexport const detectOllamaModels = async (\n  baseUrl?: string,\n): Promise<{\n  isRunning: boolean;\n  availableModels: string[];\n}> => {\n  // Use a temporary client with the provided base URL if given\n  const client = baseUrl ? new OllamaClient(baseUrl) : ollamaClient;\n\n  const isRunning = await client.isOllamaRunning();\n\n  if (!isRunning) {\n    return { isRunning: false, availableModels: [] };\n  }\n\n  const availableModels = await client.getAvailableModels();\n\n  return {\n    isRunning: true,\n    availableModels,\n  };\n};\n"],"names":[],"mappings":";;;;;;;AAkBO,MAAM;IAOX,WAAW,OAAe,EAAE;QAC1B,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,MAAM,kBAAoC;QACxC,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,AAAC,GAAe,OAAb,IAAI,CAAC,OAAO,EAAC,iBAAe;gBAC1D,QAAQ;gBACR,QAAQ,YAAY,OAAO,CAAC;YAC9B;YACA,OAAO,SAAS,EAAE;QACpB,EAAE,OAAO,OAAO;YACd,OAAO;QACT;IACF;IAEA,MAAM,qBAAwC;QAC5C,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,AAAC,GAAe,OAAb,IAAI,CAAC,OAAO,EAAC,cAAY;gBACvD,QAAQ;gBACR,QAAQ,YAAY,OAAO,CAAC;YAC9B;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBAChB,OAAO,EAAE;YACX;YAEA,MAAM,OAA6B,MAAM,SAAS,IAAI;YACtD,OAAO,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC,QAAU,MAAM,IAAI;QAC9C,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,kCAAkC;YAC/C,OAAO,EAAE;QACX;IACF;IAEA,MAAM,iBAAiB,SAAiB,EAAoB;QAC1D,MAAM,kBAAkB,MAAM,IAAI,CAAC,kBAAkB;QACrD,OAAO,gBAAgB,IAAI,CACzB,CAAC,QAAU,UAAU,aAAa,MAAM,UAAU,CAAC,AAAC,GAAY,OAAV,WAAU;IAEpE;IAEA,MAAM,2BACJ,eAAyB,EACN;QACnB,MAAM,kBAAkB,MAAM,IAAI,CAAC,kBAAkB;QAErD,OAAO,gBAAgB,MAAM,CAAC,CAAC,iBAC7B,gBAAgB,IAAI,CAClB,CAAC,iBACC,mBAAmB,kBACnB,eAAe,UAAU,CAAC,AAAC,GAAiB,OAAf,gBAAe;IAGpD;IA1DA,YAAY,UAAkB,wBAAwB,CAAE;QAFxD,+KAAQ,WAAR,KAAA;QAGE,IAAI,CAAC,OAAO,GAAG;IACjB;AAyDF;AAGO,MAAM,eAAe,IAAI;AAGzB,MAAM,qBAAqB,OAChC;IAKA,6DAA6D;IAC7D,MAAM,SAAS,UAAU,IAAI,aAAa,WAAW;IAErD,MAAM,YAAY,MAAM,OAAO,eAAe;IAE9C,IAAI,CAAC,WAAW;QACd,OAAO;YAAE,WAAW;YAAO,iBAAiB,EAAE;QAAC;IACjD;IAEA,MAAM,kBAAkB,MAAM,OAAO,kBAAkB;IAEvD,OAAO;QACL,WAAW;QACX;IACF;AACF","debugId":null}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/date-utils.ts"],"sourcesContent":["import { format, parseISO } from \"date-fns\";\n\nexport const formatDate = (\n  date: string | Date,\n  formatString = \"HH:mm:ss.SSS\",\n): string => {\n  const dateToFormat = typeof date === \"string\" ? parseISO(date) : date;\n  return format(dateToFormat, formatString);\n};\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAEO,MAAM,aAAa,SACxB;QACA,gFAAe;IAEf,MAAM,eAAe,OAAO,SAAS,WAAW,CAAA,GAAA,2IAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ;IACjE,OAAO,CAAA,GAAA,yJAAA,CAAA,SAAM,AAAD,EAAE,cAAc;AAC9B","debugId":null}},
    {"offset": {"line": 424, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/theme-utils.ts"],"sourcesContent":["export function updateThemeMode(value: \"light\" | \"dark\") {\n  const doc = document.documentElement;\n  doc.classList.add(\"disable-transitions\");\n  doc.classList.toggle(\"dark\", value === \"dark\");\n  requestAnimationFrame(() => {\n    doc.classList.remove(\"disable-transitions\");\n  });\n}\n\nexport function updateThemePreset(value: string) {\n  document.documentElement.setAttribute(\"data-theme-preset\", value);\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,gBAAgB,KAAuB;IACrD,MAAM,MAAM,SAAS,eAAe;IACpC,IAAI,SAAS,CAAC,GAAG,CAAC;IAClB,IAAI,SAAS,CAAC,MAAM,CAAC,QAAQ,UAAU;IACvC,sBAAsB;QACpB,IAAI,SAAS,CAAC,MAAM,CAAC;IACvB;AACF;AAEO,SAAS,kBAAkB,KAAa;IAC7C,SAAS,eAAe,CAAC,YAAY,CAAC,qBAAqB;AAC7D","debugId":null}},
    {"offset": {"line": 448, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/lib/mcp-oauth.ts"],"sourcesContent":["/**\n * Clean OAuth implementation using only the official MCP SDK\n */\n\nimport {\n  auth,\n  OAuthClientProvider,\n} from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport { HttpServerDefinition } from \"./types\";\n\nexport interface MCPOAuthOptions {\n  serverName: string;\n  serverUrl: string;\n  scopes?: string[];\n}\n\nexport interface OAuthResult {\n  success: boolean;\n  serverConfig?: HttpServerDefinition;\n  error?: string;\n}\n\n/**\n * Simple localStorage-based OAuth provider for MCP\n */\nclass MCPOAuthProvider implements OAuthClientProvider {\n  private serverName: string;\n  private redirectUri: string;\n\n  constructor(serverName: string) {\n    this.serverName = serverName;\n    this.redirectUri = `${window.location.origin}/oauth/callback`;\n  }\n\n  get redirectUrl(): string {\n    return this.redirectUri;\n  }\n\n  get clientMetadata() {\n    return {\n      client_name: `MCP Inspector - ${this.serverName}`,\n      client_uri: \"https://github.com/modelcontextprotocol/inspector\",\n      redirect_uris: [this.redirectUri],\n      grant_types: [\"authorization_code\", \"refresh_token\"],\n      response_types: [\"code\"],\n      token_endpoint_auth_method: \"client_secret_post\",\n      scope: \"mcp:*\",\n    };\n  }\n\n  clientInformation() {\n    const stored = localStorage.getItem(`mcp-client-${this.serverName}`);\n    return stored ? JSON.parse(stored) : undefined;\n  }\n\n  async saveClientInformation(clientInformation: any) {\n    localStorage.setItem(\n      `mcp-client-${this.serverName}`,\n      JSON.stringify(clientInformation),\n    );\n  }\n\n  tokens() {\n    const stored = localStorage.getItem(`mcp-tokens-${this.serverName}`);\n    return stored ? JSON.parse(stored) : undefined;\n  }\n\n  async saveTokens(tokens: any) {\n    localStorage.setItem(\n      `mcp-tokens-${this.serverName}`,\n      JSON.stringify(tokens),\n    );\n  }\n\n  async redirectToAuthorization(authorizationUrl: URL) {\n    // Store server name for callback recovery\n    console.log(\"Setting mcp-oauth-pending to:\", this.serverName);\n    localStorage.setItem(\"mcp-oauth-pending\", this.serverName);\n    window.location.href = authorizationUrl.toString();\n  }\n\n  async saveCodeVerifier(codeVerifier: string) {\n    localStorage.setItem(`mcp-verifier-${this.serverName}`, codeVerifier);\n  }\n\n  codeVerifier(): string {\n    const verifier = localStorage.getItem(`mcp-verifier-${this.serverName}`);\n    if (!verifier) {\n      throw new Error(\"Code verifier not found\");\n    }\n    return verifier;\n  }\n\n  async invalidateCredentials(scope: \"all\" | \"client\" | \"tokens\" | \"verifier\") {\n    switch (scope) {\n      case \"all\":\n        localStorage.removeItem(`mcp-tokens-${this.serverName}`);\n        localStorage.removeItem(`mcp-client-${this.serverName}`);\n        localStorage.removeItem(`mcp-verifier-${this.serverName}`);\n        break;\n      case \"client\":\n        localStorage.removeItem(`mcp-client-${this.serverName}`);\n        break;\n      case \"tokens\":\n        localStorage.removeItem(`mcp-tokens-${this.serverName}`);\n        break;\n      case \"verifier\":\n        localStorage.removeItem(`mcp-verifier-${this.serverName}`);\n        break;\n    }\n  }\n}\n\n/**\n * Initiates OAuth flow for an MCP server\n */\nexport async function initiateOAuth(\n  options: MCPOAuthOptions,\n): Promise<OAuthResult> {\n  try {\n    const provider = new MCPOAuthProvider(options.serverName);\n\n    // Store server URL for callback recovery\n    localStorage.setItem(\n      `mcp-serverUrl-${options.serverName}`,\n      options.serverUrl,\n    );\n    localStorage.setItem(\"mcp-oauth-pending\", options.serverName);\n\n    const result = await auth(provider, {\n      serverUrl: options.serverUrl,\n      scope: options.scopes?.join(\" \") || \"mcp:*\",\n    });\n\n    if (result === \"REDIRECT\") {\n      return {\n        success: true,\n      };\n    }\n\n    if (result === \"AUTHORIZED\") {\n      const tokens = provider.tokens();\n      if (tokens) {\n        const serverConfig = createServerConfig(options.serverUrl, tokens);\n        return {\n          success: true,\n          serverConfig,\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: \"OAuth flow failed\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown OAuth error\",\n    };\n  }\n}\n\n/**\n * Handles OAuth callback and completes the flow\n */\nexport async function handleOAuthCallback(\n  authorizationCode: string,\n): Promise<OAuthResult & { serverName?: string }> {\n  try {\n    // Get pending server name from localStorage\n    const serverName = localStorage.getItem(\"mcp-oauth-pending\");\n    if (!serverName) {\n      throw new Error(\"No pending OAuth flow found\");\n    }\n\n    // Get server URL\n    const serverUrl = localStorage.getItem(`mcp-serverUrl-${serverName}`);\n    if (!serverUrl) {\n      throw new Error(\"Server URL not found for OAuth callback\");\n    }\n\n    const provider = new MCPOAuthProvider(serverName);\n\n    const result = await auth(provider, {\n      serverUrl,\n      authorizationCode,\n      scope: \"mcp:*\",\n    });\n\n    if (result === \"AUTHORIZED\") {\n      const tokens = provider.tokens();\n      if (tokens) {\n        // Clean up pending state\n        localStorage.removeItem(\"mcp-oauth-pending\");\n\n        const serverConfig = createServerConfig(serverUrl, tokens);\n        return {\n          success: true,\n          serverConfig,\n          serverName, // Return server name so caller doesn't need to look it up\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: \"Token exchange failed\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown callback error\",\n    };\n  }\n}\n\n/**\n * Gets stored tokens for a server\n */\nexport function getStoredTokens(serverName: string): any {\n  const stored = localStorage.getItem(`mcp-tokens-${serverName}`);\n  return stored ? JSON.parse(stored) : undefined;\n}\n\n/**\n * Waits for tokens to be available with timeout\n */\nexport async function waitForTokens(\n  serverName: string,\n  timeoutMs: number = 5000,\n): Promise<any> {\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeoutMs) {\n    const tokens = getStoredTokens(serverName);\n    if (tokens?.access_token) {\n      return tokens;\n    }\n    await new Promise((resolve) => setTimeout(resolve, 100));\n  }\n\n  throw new Error(`Timeout waiting for tokens for server: ${serverName}`);\n}\n\n/**\n * Refreshes OAuth tokens for a server using the refresh token\n */\nexport async function refreshOAuthTokens(\n  serverName: string,\n): Promise<OAuthResult> {\n  try {\n    const provider = new MCPOAuthProvider(serverName);\n    const existingTokens = provider.tokens();\n\n    if (!existingTokens?.refresh_token) {\n      return {\n        success: false,\n        error: \"No refresh token available\",\n      };\n    }\n\n    // Get server URL\n    const serverUrl = localStorage.getItem(`mcp-serverUrl-${serverName}`);\n    if (!serverUrl) {\n      return {\n        success: false,\n        error: \"Server URL not found for token refresh\",\n      };\n    }\n\n    const result = await auth(provider, {\n      serverUrl,\n      scope: \"mcp:*\",\n    });\n\n    if (result === \"AUTHORIZED\") {\n      const tokens = provider.tokens();\n      if (tokens) {\n        const serverConfig = createServerConfig(serverUrl, tokens);\n        return {\n          success: true,\n          serverConfig,\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: \"Token refresh failed\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown refresh error\",\n    };\n  }\n}\n\n/**\n * Clears all OAuth data for a server\n */\nexport function clearOAuthData(serverName: string): void {\n  localStorage.removeItem(`mcp-tokens-${serverName}`);\n  localStorage.removeItem(`mcp-client-${serverName}`);\n  localStorage.removeItem(`mcp-verifier-${serverName}`);\n  localStorage.removeItem(`mcp-serverUrl-${serverName}`);\n}\n\n/**\n * Creates MCP server configuration with OAuth tokens\n */\nfunction createServerConfig(\n  serverUrl: string,\n  tokens: any,\n): HttpServerDefinition {\n  return {\n    url: new URL(serverUrl),\n    requestInit: {\n      headers: tokens.access_token\n        ? {\n            Authorization: `Bearer ${tokens.access_token}`,\n          }\n        : {},\n    },\n    oauth: tokens,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 707, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-logger.ts"],"sourcesContent":["import { useCallback, useMemo, useState, useEffect } from \"react\";\n\nexport type LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  context: string;\n  message: string;\n  data?: unknown;\n  error?: Error;\n}\n\nexport interface LoggerConfig {\n  level: LogLevel;\n  enableConsole: boolean;\n  maxBufferSize: number;\n}\n\nexport const LOG_LEVELS: Record<LogLevel, number> = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4,\n};\n\nconst LOG_COLORS: Record<LogLevel, string> = {\n  error: \"#ef4444\",\n  warn: \"#f59e0b\",\n  info: \"#3b82f6\",\n  debug: \"#8b5cf6\",\n  trace: \"#6b7280\",\n};\n\n// Global logger state\nclass LoggerState {\n  private config: LoggerConfig = {\n    level: \"info\",\n    enableConsole: true,\n    maxBufferSize: 1000,\n  };\n\n  private buffer: LogEntry[] = [];\n  private listeners: Set<() => void> = new Set();\n\n  setConfig(config: Partial<LoggerConfig>) {\n    this.config = { ...this.config, ...config };\n    this.notifyListeners();\n  }\n\n  getConfig(): LoggerConfig {\n    return { ...this.config };\n  }\n\n  addEntry(entry: LogEntry) {\n    this.buffer.push(entry);\n\n    // Maintain buffer size limit\n    if (this.buffer.length > this.config.maxBufferSize) {\n      this.buffer = this.buffer.slice(-this.config.maxBufferSize);\n    }\n\n    this.notifyListeners();\n  }\n\n  getEntries(): LogEntry[] {\n    return [...this.buffer];\n  }\n\n  getFilteredEntries(level?: LogLevel, context?: string): LogEntry[] {\n    let entries = this.buffer;\n\n    if (level) {\n      entries = entries.filter((entry) => entry.level === level);\n    }\n\n    if (context) {\n      const contextLower = context.toLowerCase();\n      entries = entries.filter((entry) =>\n        entry.context.toLowerCase().includes(contextLower),\n      );\n    }\n\n    return entries;\n  }\n\n  clearBuffer() {\n    this.buffer = [];\n    this.notifyListeners();\n  }\n\n  subscribe(listener: () => void) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  private notifyListeners() {\n    this.listeners.forEach((listener) => listener());\n  }\n\n  shouldLog(level: LogLevel): boolean {\n    return LOG_LEVELS[level] <= LOG_LEVELS[this.config.level];\n  }\n}\n\nconst loggerState = new LoggerState();\n\n// Set initial config based on environment\nif (typeof window !== \"undefined\") {\n  const isDevelopment = process.env.NODE_ENV === \"development\";\n  loggerState.setConfig({\n    level: isDevelopment ? \"debug\" : \"info\",\n    enableConsole: true,\n  });\n}\n\nexport interface Logger {\n  error: (message: string, data?: unknown, error?: Error) => void;\n  warn: (message: string, data?: unknown) => void;\n  info: (message: string, data?: unknown) => void;\n  debug: (message: string, data?: unknown) => void;\n  trace: (message: string, data?: unknown) => void;\n  context: string;\n}\n\nexport function useLogger(context: string = \"Unknown\"): Logger {\n  const createLogFunction = useCallback(\n    (level: LogLevel) => (message: string, data?: unknown, error?: Error) => {\n      if (!loggerState.shouldLog(level)) {\n        return;\n      }\n\n      const timestamp = new Date().toISOString();\n      const entry: LogEntry = {\n        timestamp,\n        level,\n        context,\n        message,\n        data,\n        error,\n      };\n\n      loggerState.addEntry(entry);\n\n      // Console output if enabled\n      const config = loggerState.getConfig();\n      if (config.enableConsole) {\n        outputToConsole(entry);\n      }\n    },\n    [context],\n  );\n\n  const logger = useMemo(\n    () => ({\n      error: createLogFunction(\"error\"),\n      warn: createLogFunction(\"warn\"),\n      info: createLogFunction(\"info\"),\n      debug: createLogFunction(\"debug\"),\n      trace: createLogFunction(\"trace\"),\n      context,\n    }),\n    [createLogFunction, context],\n  );\n\n  return logger;\n}\n\nfunction outputToConsole(entry: LogEntry) {\n  const { timestamp, level, context, message, data, error } = entry;\n  const time = new Date(timestamp).toLocaleTimeString();\n  const color = LOG_COLORS[level];\n\n  const contextStyle = `color: ${color}; font-weight: bold;`;\n  const messageStyle = `color: ${color};`;\n\n  const args: unknown[] = [\n    `%c[${time}] %c${level.toUpperCase()} %c[${context}] %c${message}`,\n    \"color: #6b7280;\",\n    contextStyle,\n    \"color: #6b7280;\",\n    messageStyle,\n  ];\n\n  if (data !== undefined) {\n    args.push(\"\\nData:\", data);\n  }\n\n  if (error) {\n    args.push(\"\\nError:\", error);\n  }\n\n  const consoleMethod =\n    level === \"error\"\n      ? console.error\n      : level === \"warn\"\n        ? console.warn\n        : level === \"debug\"\n          ? console.debug\n          : console.log;\n\n  consoleMethod(...args);\n}\n\n// Global logger utilities\nexport const LoggerUtils = {\n  setLevel: (level: LogLevel) => {\n    loggerState.setConfig({ level });\n  },\n\n  getLevel: (): LogLevel => {\n    return loggerState.getConfig().level;\n  },\n\n  setConsoleEnabled: (enabled: boolean) => {\n    loggerState.setConfig({ enableConsole: enabled });\n  },\n\n  isConsoleEnabled: (): boolean => {\n    return loggerState.getConfig().enableConsole;\n  },\n\n  getAllEntries: (): LogEntry[] => {\n    return loggerState.getEntries();\n  },\n\n  getFilteredEntries: (level?: LogLevel, context?: string): LogEntry[] => {\n    return loggerState.getFilteredEntries(level, context);\n  },\n\n  clearLogs: () => {\n    loggerState.clearBuffer();\n  },\n\n  subscribeToLogs: (callback: () => void) => {\n    return loggerState.subscribe(callback);\n  },\n\n  getConfig: () => {\n    return loggerState.getConfig();\n  },\n\n  setConfig: (config: Partial<LoggerConfig>) => {\n    loggerState.setConfig(config);\n  },\n};\n\n// Hook for components that need to observe log changes\nexport function useLoggerState() {\n  const [, forceUpdate] = useState({});\n\n  useEffect(() => {\n    const unsubscribe = loggerState.subscribe(() => {\n      forceUpdate({});\n    });\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  return {\n    entries: loggerState.getEntries(),\n    config: loggerState.getConfig(),\n    setConfig: loggerState.setConfig.bind(loggerState),\n    clearBuffer: loggerState.clearBuffer.bind(loggerState),\n    getFilteredEntries: loggerState.getFilteredEntries.bind(loggerState),\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 942, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-ai-provider-keys.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from \"react\";\n\nexport interface ProviderTokens {\n  anthropic: string;\n  openai: string;\n  ollama: string;\n  ollamaBaseUrl: string;\n}\n\nexport interface useAiProviderKeysReturn {\n  tokens: ProviderTokens;\n  setToken: (provider: keyof ProviderTokens, token: string) => void;\n  clearToken: (provider: keyof ProviderTokens) => void;\n  clearAllTokens: () => void;\n  hasToken: (provider: keyof ProviderTokens) => boolean;\n  getToken: (provider: keyof ProviderTokens) => string;\n  getOllamaBaseUrl: () => string;\n  setOllamaBaseUrl: (url: string) => void;\n}\n\nconst STORAGE_KEY = \"mcp-inspector-provider-tokens\";\n\nconst defaultTokens: ProviderTokens = {\n  anthropic: \"\",\n  openai: \"\",\n  ollama: \"local\", // Ollama runs locally, no API key needed\n  ollamaBaseUrl: \"http://localhost:11434\",\n};\n\nexport function useAiProviderKeys(): useAiProviderKeysReturn {\n  const [tokens, setTokens] = useState<ProviderTokens>(defaultTokens);\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Load tokens from localStorage on mount\n  useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (stored) {\n          const parsedTokens = JSON.parse(stored) as ProviderTokens;\n          setTokens(parsedTokens);\n        }\n      } catch (error) {\n        console.warn(\n          \"Failed to load provider tokens from localStorage:\",\n          error,\n        );\n      }\n      setIsInitialized(true);\n    }\n  }, []);\n\n  // Save tokens to localStorage whenever they change\n  useEffect(() => {\n    if (isInitialized && typeof window !== \"undefined\") {\n      try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(tokens));\n      } catch (error) {\n        console.warn(\"Failed to save provider tokens to localStorage:\", error);\n      }\n    }\n  }, [tokens, isInitialized]);\n\n  const setToken = useCallback(\n    (provider: keyof ProviderTokens, token: string) => {\n      setTokens((prev) => ({\n        ...prev,\n        [provider]: token,\n      }));\n    },\n    [],\n  );\n\n  const clearToken = useCallback((provider: keyof ProviderTokens) => {\n    setTokens((prev) => ({\n      ...prev,\n      [provider]: \"\",\n    }));\n  }, []);\n\n  const clearAllTokens = useCallback(() => {\n    setTokens(defaultTokens);\n  }, []);\n\n  const hasToken = useCallback(\n    (provider: keyof ProviderTokens) => {\n      return Boolean(tokens[provider]?.trim());\n    },\n    [tokens],\n  );\n\n  const getToken = useCallback(\n    (provider: keyof ProviderTokens) => {\n      return tokens[provider] || \"\";\n    },\n    [tokens],\n  );\n\n  const getOllamaBaseUrl = useCallback(() => {\n    return tokens.ollamaBaseUrl || defaultTokens.ollamaBaseUrl;\n  }, [tokens.ollamaBaseUrl]);\n\n  const setOllamaBaseUrl = useCallback((url: string) => {\n    setTokens((prev) => ({\n      ...prev,\n      ollamaBaseUrl: url,\n    }));\n  }, []);\n\n  return {\n    tokens,\n    setToken,\n    clearToken,\n    clearAllTokens,\n    hasToken,\n    getToken,\n    getOllamaBaseUrl,\n    setOllamaBaseUrl,\n  };\n}\n"],"names":[],"mappings":";;;AAEA;;AAFA;;AAsBA,MAAM,cAAc;AAEpB,MAAM,gBAAgC;IACpC,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,eAAe;AACjB;AAEO,SAAS;;IACd,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAkB;IACrD,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAEnD,yCAAyC;IACzC,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;uCAAE;YACR,wCAAmC;gBACjC,IAAI;oBACF,MAAM,SAAS,aAAa,OAAO,CAAC;oBACpC,IAAI,QAAQ;wBACV,MAAM,eAAe,KAAK,KAAK,CAAC;wBAChC,UAAU;oBACZ;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,IAAI,CACV,qDACA;gBAEJ;gBACA,iBAAiB;YACnB;QACF;sCAAG,EAAE;IAEL,mDAAmD;IACnD,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;uCAAE;YACR,IAAI,iBAAiB,aAAkB,aAAa;gBAClD,IAAI;oBACF,aAAa,OAAO,CAAC,aAAa,KAAK,SAAS,CAAC;gBACnD,EAAE,OAAO,OAAO;oBACd,QAAQ,IAAI,CAAC,mDAAmD;gBAClE;YACF;QACF;sCAAG;QAAC;QAAQ;KAAc;IAE1B,MAAM,WAAW,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;mDACzB,CAAC,UAAgC;YAC/B;2DAAU,CAAC,OAAS,CAAC;wBACnB,GAAG,IAAI;wBACP,CAAC,SAAS,EAAE;oBACd,CAAC;;QACH;kDACA,EAAE;IAGJ,MAAM,aAAa,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;qDAAE,CAAC;YAC9B;6DAAU,CAAC,OAAS,CAAC;wBACnB,GAAG,IAAI;wBACP,CAAC,SAAS,EAAE;oBACd,CAAC;;QACH;oDAAG,EAAE;IAEL,MAAM,iBAAiB,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;yDAAE;YACjC,UAAU;QACZ;wDAAG,EAAE;IAEL,MAAM,WAAW,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;mDACzB,CAAC;gBACgB;YAAf,OAAO,SAAQ,mBAAA,MAAM,CAAC,SAAS,cAAhB,uCAAA,iBAAkB,IAAI;QACvC;kDACA;QAAC;KAAO;IAGV,MAAM,WAAW,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;mDACzB,CAAC;YACC,OAAO,MAAM,CAAC,SAAS,IAAI;QAC7B;kDACA;QAAC;KAAO;IAGV,MAAM,mBAAmB,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;2DAAE;YACnC,OAAO,OAAO,aAAa,IAAI,cAAc,aAAa;QAC5D;0DAAG;QAAC,OAAO,aAAa;KAAC;IAEzB,MAAM,mBAAmB,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;2DAAE,CAAC;YACpC;mEAAU,CAAC,OAAS,CAAC;wBACnB,GAAG,IAAI;wBACP,eAAe;oBACjB,CAAC;;QACH;0DAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GA1FgB","debugId":null}},
    {"offset": {"line": 1070, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-chat.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { ChatMessage, ChatState, Attachment } from \"@/lib/chat-types\";\nimport { createMessage } from \"@/lib/chat-utils\";\nimport {\n  MastraMCPServerDefinition,\n  Model,\n  ModelDefinition,\n  SUPPORTED_MODELS,\n} from \"@/lib/types\";\nimport { useAiProviderKeys } from \"@/hooks/use-ai-provider-keys\";\nimport { detectOllamaModels } from \"@/lib/ollama-utils\";\n\ninterface ElicitationRequest {\n  requestId: string;\n  message: string;\n  schema: any;\n  timestamp: string;\n}\n\ninterface UseChatOptions {\n  initialMessages?: ChatMessage[];\n  serverConfigs?: Record<string, MastraMCPServerDefinition>;\n  systemPrompt?: string;\n  onMessageSent?: (message: ChatMessage) => void;\n  onMessageReceived?: (message: ChatMessage) => void;\n  onError?: (error: string) => void;\n  onModelChange?: (model: ModelDefinition) => void;\n}\n\nexport function useChat(options: UseChatOptions = {}) {\n  const { getToken, hasToken, tokens, getOllamaBaseUrl } = useAiProviderKeys();\n\n  const {\n    initialMessages = [],\n    serverConfigs,\n    systemPrompt,\n    onMessageSent,\n    onMessageReceived,\n    onError,\n    onModelChange,\n  } = options;\n\n  const [state, setState] = useState<ChatState>({\n    messages: initialMessages,\n    isLoading: false,\n    connectionStatus: \"disconnected\",\n  });\n  const [input, setInput] = useState(\"\");\n  const [status, setStatus] = useState<\"idle\" | \"error\">(\"idle\");\n  const [model, setModel] = useState<ModelDefinition | null>(null);\n  const [ollamaModels, setOllamaModels] = useState<ModelDefinition[]>([]);\n  const [isOllamaRunning, setIsOllamaRunning] = useState(false);\n  const [elicitationRequest, setElicitationRequest] = useState<ElicitationRequest | null>(null);\n  const [elicitationLoading, setElicitationLoading] = useState(false);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const messagesRef = useRef(state.messages);\n  console.log(\"model\", model);\n  useEffect(() => {\n    messagesRef.current = state.messages;\n  }, [state.messages]);\n\n  // Check for Ollama models on mount and periodically\n  useEffect(() => {\n    const checkOllama = async () => {\n      const { isRunning, availableModels } =\n        await detectOllamaModels(getOllamaBaseUrl());\n      setIsOllamaRunning(isRunning);\n\n      // Convert string model names to ModelDefinition objects\n      const ollamaModelDefinitions: ModelDefinition[] = availableModels.map(\n        (modelName) => ({\n          id: modelName,\n          name: modelName,\n          provider: \"ollama\" as const,\n        }),\n      );\n\n      setOllamaModels(ollamaModelDefinitions);\n    };\n\n    checkOllama();\n\n    // Check every 30 seconds for Ollama availability\n    const interval = setInterval(checkOllama, 30000);\n\n    return () => clearInterval(interval);\n  }, [getOllamaBaseUrl]);\n\n  useEffect(() => {\n    // Only set a model if we don't have one or the current model is not available\n    if (!model || !availableModels.some((m) => m.id === model.id)) {\n      if (isOllamaRunning && ollamaModels.length > 0) {\n        setModel(ollamaModels[0]);\n      } else if (hasToken(\"anthropic\")) {\n        const claudeModel = SUPPORTED_MODELS.find(\n          (m) => m.id === Model.CLAUDE_3_5_SONNET_LATEST,\n        );\n        if (claudeModel) setModel(claudeModel);\n      } else if (hasToken(\"openai\")) {\n        const gptModel = SUPPORTED_MODELS.find((m) => m.id === Model.GPT_4O);\n        if (gptModel) setModel(gptModel);\n      } else {\n        setModel(null);\n      }\n    }\n  }, [tokens, ollamaModels, isOllamaRunning, hasToken, model]);\n\n  const currentApiKey = useMemo(() => {\n    if (model) {\n      if (model.provider === \"ollama\") {\n        // For Ollama, return \"local\" if it's running and the model is available\n        return isOllamaRunning &&\n          ollamaModels.some(\n            (om) => om.id === model.id || om.id.startsWith(`${model.id}:`),\n          )\n          ? \"local\"\n          : \"\";\n      }\n      return getToken(model.provider);\n    }\n    return \"\";\n  }, [model, getToken, isOllamaRunning, ollamaModels]);\n\n  const handleModelChange = useCallback(\n    (newModel: ModelDefinition) => {\n      setModel(newModel);\n      if (onModelChange) {\n        onModelChange(newModel);\n      }\n    },\n    [onModelChange],\n  );\n\n  // Available models with API keys or local Ollama models\n  const availableModels = useMemo(() => {\n    const availableModelsList: ModelDefinition[] = [];\n\n    // Add supported models only if the provider has a valid API key\n    for (const model of SUPPORTED_MODELS) {\n      if (model.provider === \"anthropic\" && hasToken(\"anthropic\")) {\n        availableModelsList.push(model);\n      } else if (model.provider === \"openai\" && hasToken(\"openai\")) {\n        availableModelsList.push(model);\n      }\n    }\n\n    // Add Ollama models if Ollama is running\n    if (isOllamaRunning && ollamaModels.length > 0) {\n      availableModelsList.push(...ollamaModels);\n    }\n\n    return availableModelsList;\n  }, [isOllamaRunning, ollamaModels, hasToken]);\n\n  const handleStreamingEvent = useCallback(\n    (\n      parsed: any,\n      assistantMessage: ChatMessage,\n      assistantContent: { current: string },\n      toolCalls: { current: any[] },\n      toolResults: { current: any[] },\n    ) => {\n      // Handle text content\n      if (\n        (parsed.type === \"text\" || (!parsed.type && parsed.content)) &&\n        parsed.content\n      ) {\n        assistantContent.current += parsed.content;\n        setState((prev) => ({\n          ...prev,\n          messages: prev.messages.map((msg) =>\n            msg.id === assistantMessage.id\n              ? { ...msg, content: assistantContent.current }\n              : msg,\n          ),\n        }));\n        return;\n      }\n\n      // Handle tool calls\n      if (\n        (parsed.type === \"tool_call\" || (!parsed.type && parsed.toolCall)) &&\n        parsed.toolCall\n      ) {\n        const toolCall = parsed.toolCall;\n        toolCalls.current = [...toolCalls.current, toolCall];\n        setState((prev) => ({\n          ...prev,\n          messages: prev.messages.map((msg) =>\n            msg.id === assistantMessage.id\n              ? { ...msg, toolCalls: [...toolCalls.current] }\n              : msg,\n          ),\n        }));\n        return;\n      }\n\n      // Handle tool results\n      if (\n        (parsed.type === \"tool_result\" ||\n          (!parsed.type && parsed.toolResult)) &&\n        parsed.toolResult\n      ) {\n        const toolResult = parsed.toolResult;\n        toolResults.current = [...toolResults.current, toolResult];\n\n        // Update the corresponding tool call status\n        toolCalls.current = toolCalls.current.map((tc) =>\n          tc.id === toolResult.toolCallId\n            ? {\n                ...tc,\n                status: toolResult.error ? \"error\" : \"completed\",\n              }\n            : tc,\n        );\n\n        setState((prev) => ({\n          ...prev,\n          messages: prev.messages.map((msg) =>\n            msg.id === assistantMessage.id\n              ? {\n                  ...msg,\n                  toolCalls: [...toolCalls.current],\n                  toolResults: [...toolResults.current],\n                }\n              : msg,\n          ),\n        }));\n        return;\n      }\n\n      // Handle elicitation requests\n      if (parsed.type === \"elicitation_request\") {\n        setElicitationRequest({\n          requestId: parsed.requestId,\n          message: parsed.message,\n          schema: parsed.schema,\n          timestamp: parsed.timestamp,\n        });\n        return;\n      }\n\n      // Handle elicitation completion\n      if (parsed.type === \"elicitation_complete\") {\n        setElicitationRequest(null);\n        return;\n      }\n\n      // Handle errors\n      if (\n        (parsed.type === \"error\" || (!parsed.type && parsed.error)) &&\n        parsed.error\n      ) {\n        throw new Error(parsed.error);\n      }\n    },\n    [],\n  );\n\n  const sendChatRequest = useCallback(\n    async (userMessage: ChatMessage) => {\n      if (!serverConfigs || !model || !currentApiKey) {\n        throw new Error(\n          \"Missing required configuration: serverConfig, model, and apiKey are required\",\n        );\n      }\n\n      const assistantMessage = createMessage(\"assistant\", \"\");\n\n      setState((prev) => ({\n        ...prev,\n        messages: [...prev.messages, assistantMessage],\n      }));\n\n      try {\n        const response = await fetch(\"/api/mcp/chat\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Accept: \"text/event-stream\",\n          },\n          body: JSON.stringify({\n            serverConfigs,\n            model,\n            apiKey: currentApiKey,\n            systemPrompt,\n            messages: messagesRef.current.concat(userMessage),\n            ollamaBaseUrl: getOllamaBaseUrl(),\n          }),\n          signal: abortControllerRef.current?.signal,\n        });\n\n        if (!response.ok) {\n          const errorText = await response.text();\n          let errorData;\n          try {\n            errorData = JSON.parse(errorText);\n          } catch {\n            throw new Error(`Chat request failed: ${response.status}`);\n          }\n          throw new Error(errorData.error || \"Chat request failed\");\n        }\n\n        // Handle streaming response\n        const reader = response.body?.getReader();\n        const decoder = new TextDecoder();\n        const assistantContent = { current: \"\" };\n        const toolCalls = { current: [] as any[] };\n        const toolResults = { current: [] as any[] };\n        let buffer = \"\";\n        let isDone = false;\n\n        if (reader) {\n          while (!isDone) {\n            const { done, value } = await reader.read();\n            if (done) break;\n\n            buffer += decoder.decode(value, { stream: true });\n            const lines = buffer.split(\"\\n\");\n\n            // Keep the last incomplete line in the buffer\n            buffer = lines.pop() || \"\";\n\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const data = line.slice(6).trim();\n                if (data === \"[DONE]\") {\n                  isDone = true;\n                  setState((prev) => ({\n                    ...prev,\n                    isLoading: false,\n                  }));\n                  break;\n                }\n\n                if (data) {\n                  try {\n                    const parsed = JSON.parse(data);\n                    handleStreamingEvent(\n                      parsed,\n                      assistantMessage,\n                      assistantContent,\n                      toolCalls,\n                      toolResults,\n                    );\n                  } catch (parseError) {\n                    console.warn(\"Failed to parse SSE data:\", data, parseError);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // Ensure we have some content, even if empty\n        if (!assistantContent.current && !toolCalls.current.length) {\n          console.warn(\"No content received from stream\");\n        }\n\n        if (onMessageReceived) {\n          const finalMessage = {\n            ...assistantMessage,\n            content: assistantContent.current,\n          };\n          onMessageReceived(finalMessage);\n        }\n      } catch (error) {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n        }));\n        throw error;\n      }\n    },\n    [\n      serverConfigs,\n      model,\n      currentApiKey,\n      systemPrompt,\n      onMessageReceived,\n      handleStreamingEvent,\n      getOllamaBaseUrl,\n    ],\n  );\n\n  const sendMessage = useCallback(\n    async (content: string, attachments?: Attachment[]) => {\n      if (!content.trim() || state.isLoading) return;\n\n      const userMessage = createMessage(\"user\", content, attachments);\n\n      setState((prev) => ({\n        ...prev,\n        messages: [...prev.messages, userMessage],\n        isLoading: true,\n        error: undefined,\n      }));\n\n      if (onMessageSent) {\n        onMessageSent(userMessage);\n      }\n\n      // Create abort controller for this request\n      abortControllerRef.current = new AbortController();\n\n      try {\n        await sendChatRequest(userMessage);\n        setStatus(\"idle\");\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"An error occurred\";\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: errorMessage,\n        }));\n        setStatus(\"error\");\n\n        if (onError) {\n          onError(errorMessage);\n        }\n      }\n    },\n    [state.isLoading, onMessageSent, sendChatRequest, onError],\n  );\n\n  const stopGeneration = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    setState((prev) => ({\n      ...prev,\n      isLoading: false,\n    }));\n    setStatus(\"idle\");\n  }, []);\n\n  const regenerateMessage = useCallback(\n    async (messageId: string) => {\n      // Find the message and the user message before it\n      const messages = messagesRef.current;\n      const messageIndex = messages.findIndex((m) => m.id === messageId);\n      if (messageIndex === -1 || messageIndex === 0) return;\n\n      const userMessage = messages[messageIndex - 1];\n      if (userMessage.role !== \"user\") return;\n\n      // Remove the assistant message and regenerate\n      setState((prev) => ({\n        ...prev,\n        messages: prev.messages.slice(0, messageIndex),\n        isLoading: true,\n      }));\n\n      abortControllerRef.current = new AbortController();\n\n      try {\n        await sendChatRequest(userMessage);\n        setStatus(\"idle\");\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"An error occurred\";\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: errorMessage,\n        }));\n        setStatus(\"error\");\n\n        if (onError) {\n          onError(errorMessage);\n        }\n      }\n    },\n    [sendChatRequest, onError],\n  );\n\n  const deleteMessage = useCallback((messageId: string) => {\n    setState((prev) => ({\n      ...prev,\n      messages: prev.messages.filter((msg) => msg.id !== messageId),\n    }));\n  }, []);\n\n  const clearChat = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      messages: [],\n      error: undefined,\n    }));\n    setInput(\"\");\n  }, []);\n\n  const handleElicitationResponse = useCallback(\n    async (\n      action: \"accept\" | \"decline\" | \"cancel\",\n      parameters?: Record<string, any>,\n    ) => {\n      if (!elicitationRequest) {\n        console.warn(\"Cannot handle elicitation response: no active request\");\n        return;\n      }\n\n      setElicitationLoading(true);\n\n      try {\n        let responseData = null;\n        if (action === \"accept\") {\n          responseData = {\n            action: \"accept\",\n            content: parameters || {},\n          };\n        } else {\n          responseData = {\n            action,\n          };\n        }\n\n        const response = await fetch(\"/api/mcp/chat\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            action: \"elicitation_response\",\n            requestId: elicitationRequest.requestId,\n            response: responseData,\n          }),\n        });\n\n        if (!response.ok) {\n          const errorMsg = `HTTP error! status: ${response.status}`;\n          throw new Error(errorMsg);\n        }\n\n        setElicitationRequest(null);\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        console.error(\"Error responding to elicitation request:\", errorMessage);\n        \n        if (onError) {\n          onError(\"Error responding to elicitation request\");\n        }\n      } finally {\n        setElicitationLoading(false);\n      }\n    },\n    [elicitationRequest, onError],\n  );\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return {\n    // State\n    messages: state.messages,\n    isLoading: state.isLoading,\n    error: state.error,\n    connectionStatus: state.connectionStatus,\n    status,\n    input,\n    setInput,\n    model,\n    availableModels,\n    hasValidApiKey: Boolean(currentApiKey),\n    elicitationRequest,\n    elicitationLoading,\n\n    // Actions\n    sendMessage,\n    stopGeneration,\n    regenerateMessage,\n    deleteMessage,\n    clearChat,\n    setModel: handleModelChange,\n    handleElicitationResponse,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1659, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-mobile.ts"],"sourcesContent":["import * as React from \"react\";\n\nconst MOBILE_BREAKPOINT = 768;\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(\n    undefined,\n  );\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    };\n    mql.addEventListener(\"change\", onChange);\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    return () => mql.removeEventListener(\"change\", onChange);\n  }, []);\n\n  return !!isMobile;\n}\n"],"names":[],"mappings":";;;AAAA;;;AAEA,MAAM,oBAAoB;AAEnB,SAAS;;IACd,MAAM,CAAC,UAAU,YAAY,GAAG,6JAAA,CAAA,WAAc,CAC5C;IAGF,6JAAA,CAAA,YAAe;iCAAC;YACd,MAAM,MAAM,OAAO,UAAU,CAAC,AAAC,eAAoC,OAAtB,oBAAoB,GAAE;YACnE,MAAM;kDAAW;oBACf,YAAY,OAAO,UAAU,GAAG;gBAClC;;YACA,IAAI,gBAAgB,CAAC,UAAU;YAC/B,YAAY,OAAO,UAAU,GAAG;YAChC;yCAAO,IAAM,IAAI,mBAAmB,CAAC,UAAU;;QACjD;gCAAG,EAAE;IAEL,OAAO,CAAC,CAAC;AACX;GAhBgB","debugId":null}},
    {"offset": {"line": 1696, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/hooks/use-app-state.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from \"react\";\nimport { toast } from \"sonner\";\nimport {\n  initiateOAuth,\n  handleOAuthCallback,\n  getStoredTokens,\n  clearOAuthData,\n  refreshOAuthTokens,\n} from \"@/lib/mcp-oauth\";\nimport {\n  MastraMCPServerDefinition,\n  StdioServerDefinition,\n  HttpServerDefinition,\n  OauthTokens,\n} from \"@/lib/types\";\nimport { useLogger } from \"./use-logger\";\n\nexport interface ServerWithName {\n  name: string;\n  config: MastraMCPServerDefinition;\n  oauthTokens?: OauthTokens;\n  lastConnectionTime: Date;\n  connectionStatus:\n    | \"connected\"\n    | \"connecting\"\n    | \"failed\"\n    | \"disconnected\"\n    | \"oauth-flow\";\n  retryCount: number;\n  lastError?: string;\n}\n\nexport interface AppState {\n  servers: Record<string, ServerWithName>;\n  selectedServer: string;\n  selectedMultipleServers: string[]; // Array of selected server names for multi-select mode\n  isMultiSelectMode: boolean; // Flag to enable/disable multi-select mode\n}\n\nexport interface ServerFormData {\n  name: string;\n  type: \"stdio\" | \"http\";\n  command?: string;\n  args?: string[];\n  url?: string;\n  headers?: Record<string, string>;\n  env?: Record<string, string>;\n  useOAuth?: boolean;\n  oauthScopes?: string[];\n}\n\nconst STORAGE_KEY = \"mcp-inspector-state\";\n\nexport function useAppState() {\n  const logger = useLogger(\"Connections\");\n\n  const [appState, setAppState] = useState<AppState>({\n    servers: {},\n    selectedServer: \"none\",\n    selectedMultipleServers: [],\n    isMultiSelectMode: false,\n  });\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [reconnectionTimeouts, setReconnectionTimeouts] = useState<\n    Record<string, NodeJS.Timeout>\n  >({});\n\n  // Load state from localStorage on mount\n  useEffect(() => {\n    const savedState = localStorage.getItem(STORAGE_KEY);\n    if (savedState) {\n      try {\n        const parsed = JSON.parse(savedState);\n        // Ensure all loaded servers have the new fields with defaults\n        const updatedServers = Object.fromEntries(\n          Object.entries(parsed.servers || {}).map(\n            ([name, server]: [string, any]) => [\n              name,\n              {\n                ...server,\n                connectionStatus: server.connectionStatus || \"disconnected\",\n                retryCount: server.retryCount || 0,\n                lastConnectionTime: server.lastConnectionTime\n                  ? new Date(server.lastConnectionTime)\n                  : new Date(),\n              },\n            ],\n          ),\n        );\n        setAppState({\n          servers: updatedServers,\n          selectedServer: parsed.selectedServer || \"none\",\n          selectedMultipleServers: parsed.selectedMultipleServers || [],\n          isMultiSelectMode: parsed.isMultiSelectMode || false,\n        });\n      } catch (error) {\n        logger.error(\"Failed to parse saved state\", {\n          error: error instanceof Error ? error.message : \"Unknown error\",\n        });\n      }\n    }\n    setIsLoading(false);\n  }, []);\n\n  // Save state to localStorage whenever it changes\n  useEffect(() => {\n    if (!isLoading) {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));\n    }\n  }, [appState, isLoading]);\n\n  const setSelectedMultipleServersToAllServers = useCallback(() => {\n    setAppState((prev) => ({\n      ...prev,\n      selectedMultipleServers: Object.keys(appState.servers),\n    }));\n  }, [appState.servers]);\n\n  // Check for OAuth callback completion on mount\n  useEffect(() => {\n    if (!isLoading) {\n      const urlParams = new URLSearchParams(window.location.search);\n      const code = urlParams.get(\"code\");\n      const error = urlParams.get(\"error\");\n\n      if (code) {\n        handleOAuthCallbackComplete(code);\n      } else if (error) {\n        toast.error(`OAuth authorization failed: ${error}`);\n      }\n    }\n  }, [isLoading]);\n\n  const convertFormToMCPConfig = useCallback(\n    (formData: ServerFormData): MastraMCPServerDefinition => {\n      if (formData.type === \"stdio\") {\n        return {\n          command: formData.command!,\n          args: formData.args,\n          env: formData.env,\n        } as StdioServerDefinition;\n      } else {\n        return {\n          url: new URL(formData.url!),\n          requestInit: { headers: formData.headers || {} },\n        } as HttpServerDefinition;\n      }\n    },\n    [],\n  );\n\n  const handleConnect = useCallback(\n    async (formData: ServerFormData) => {\n      // Validate form data first\n      console.log(\"handleConnectFormData\", formData);\n      if (formData.type === \"stdio\") {\n        if (!formData.command || formData.command.trim() === \"\") {\n          toast.error(\"Command is required for STDIO connections\");\n          return;\n        }\n      } else {\n        if (!formData.url || formData.url.trim() === \"\") {\n          toast.error(\"URL is required for HTTP connections\");\n          return;\n        }\n\n        try {\n          new URL(formData.url);\n        } catch (urlError) {\n          toast.error(`Invalid URL format: ${formData.url} ${urlError}`);\n          return;\n        }\n      }\n\n      // Convert form data to MCP config\n      const mcpConfig = convertFormToMCPConfig(formData);\n\n      // Immediately create server with 'connecting' state for responsive UI\n      setAppState((prev) => ({\n        ...prev,\n        servers: {\n          ...prev.servers,\n          [formData.name]: {\n            name: formData.name,\n            config: mcpConfig,\n            lastConnectionTime: new Date(),\n            connectionStatus: \"connecting\" as const,\n            retryCount: 0,\n          },\n        },\n        selectedServer: formData.name,\n      }));\n\n      try {\n        // Handle OAuth flow for HTTP servers\n        if (formData.type === \"http\" && formData.useOAuth && formData.url) {\n          // Mark as OAuth flow in progress\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [formData.name]: {\n                ...prev.servers[formData.name],\n                connectionStatus: \"oauth-flow\" as const,\n              },\n            },\n          }));\n\n          const oauthResult = await initiateOAuth({\n            serverName: formData.name,\n            serverUrl: formData.url,\n            scopes: formData.oauthScopes || [\"mcp:*\"],\n          });\n\n          if (oauthResult.success) {\n            if (oauthResult.serverConfig) {\n              // Already authorized, test connection immediately\n              try {\n                const response = await fetch(\"/api/mcp/connect\", {\n                  method: \"POST\",\n                  headers: { \"Content-Type\": \"application/json\" },\n                  body: JSON.stringify({\n                    serverConfig: oauthResult.serverConfig,\n                  }),\n                });\n\n                const connectionResult = await response.json();\n\n                if (connectionResult.success) {\n                  setAppState((prev) => ({\n                    ...prev,\n                    servers: {\n                      ...prev.servers,\n                      [formData.name]: {\n                        ...prev.servers[formData.name],\n                        config: oauthResult.serverConfig!,\n                        connectionStatus: \"connected\" as const,\n                        oauthTokens: getStoredTokens(formData.name),\n                        lastError: undefined,\n                      },\n                    },\n                  }));\n                  toast.success(`Connected successfully with OAuth!`);\n                } else {\n                  setAppState((prev) => ({\n                    ...prev,\n                    servers: {\n                      ...prev.servers,\n                      [formData.name]: {\n                        ...prev.servers[formData.name],\n                        connectionStatus: \"failed\" as const,\n                        lastError:\n                          connectionResult.error ||\n                          \"OAuth connection test failed\",\n                      },\n                    },\n                  }));\n                  toast.error(\n                    `OAuth succeeded but connection failed: ${connectionResult.error}`,\n                  );\n                }\n              } catch (error) {\n                const errorMessage =\n                  error instanceof Error ? error.message : \"Unknown error\";\n                setAppState((prev) => ({\n                  ...prev,\n                  servers: {\n                    ...prev.servers,\n                    [formData.name]: {\n                      ...prev.servers[formData.name],\n                      connectionStatus: \"failed\" as const,\n                      lastError: errorMessage,\n                    },\n                  },\n                }));\n                toast.error(\n                  `OAuth succeeded but connection test threw error: ${errorMessage}`,\n                );\n              }\n              return;\n            } else {\n              // Redirect needed - keep oauth-flow status\n              toast.success(\n                \"OAuth flow initiated. You will be redirected to authorize access.\",\n              );\n              return;\n            }\n          } else {\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [formData.name]: {\n                  ...prev.servers[formData.name],\n                  connectionStatus: \"failed\" as const,\n                  retryCount: 0,\n                  lastError: oauthResult.error || \"OAuth initialization failed\",\n                },\n              },\n            }));\n            toast.error(`OAuth initialization failed: ${oauthResult.error}`);\n            return;\n          }\n        }\n\n        // For non-OAuth connections, test connection using the stateless endpoint\n        const response = await fetch(\"/api/mcp/connect\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            serverConfig: mcpConfig,\n          }),\n        });\n\n        const result = await response.json();\n\n        if (result.success) {\n          // Update existing server to connected state\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [formData.name]: {\n                ...prev.servers[formData.name],\n                connectionStatus: \"connected\" as const,\n                lastConnectionTime: new Date(),\n                retryCount: 0,\n                lastError: undefined,\n              },\n            },\n          }));\n          logger.info(\"Connection successful\", {\n            serverName: formData.name,\n          });\n          toast.success(`Connected successfully!`);\n        } else {\n          // Update existing server to failed state\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [formData.name]: {\n                ...prev.servers[formData.name],\n                connectionStatus: \"failed\" as const,\n                retryCount: 0,\n                lastError: result.error,\n              },\n            },\n          }));\n          logger.error(\"Connection failed\", {\n            serverName: formData.name,\n            error: result.error,\n          });\n          toast.error(`Failed to connect to ${formData.name}`);\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n\n        // Update existing server to failed state\n        setAppState((prev) => ({\n          ...prev,\n          servers: {\n            ...prev.servers,\n            [formData.name]: {\n              ...prev.servers[formData.name],\n              connectionStatus: \"failed\" as const,\n              retryCount: 0,\n              lastError: errorMessage,\n            },\n          },\n        }));\n        logger.error(\"Connection failed\", {\n          serverName: formData.name,\n          error: errorMessage,\n        });\n\n        toast.error(`Network error: ${errorMessage}`);\n      }\n    },\n    [convertFormToMCPConfig],\n  );\n\n  const handleOAuthCallbackComplete = useCallback(\n    async (code: string) => {\n      // Clean up URL parameters immediately\n      window.history.replaceState({}, document.title, window.location.pathname);\n\n      try {\n        const result = await handleOAuthCallback(code);\n        console.log(\"OAuth callback result:\", result);\n\n        if (result.success && result.serverConfig && result.serverName) {\n          const serverName = result.serverName;\n\n          // Check if server exists and is in oauth-flow state\n          const existingServer = appState.servers[serverName];\n          if (\n            !existingServer ||\n            existingServer.connectionStatus !== \"oauth-flow\"\n          ) {\n            // Create new server entry if it doesn't exist or wasn't in oauth flow\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  name: serverName,\n                  config: result.serverConfig!,\n                  oauthTokens: getStoredTokens(serverName),\n                  lastConnectionTime: new Date(),\n                  connectionStatus: \"connecting\" as const,\n                  retryCount: 0,\n                },\n              },\n              selectedServer: serverName,\n            }));\n          } else {\n            // Update existing server to connecting with OAuth config\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  ...prev.servers[serverName],\n                  config: result.serverConfig!,\n                  oauthTokens: getStoredTokens(serverName),\n                  connectionStatus: \"connecting\" as const,\n                  lastError: undefined,\n                },\n              },\n              selectedServer: serverName,\n            }));\n          }\n\n          // Test the connection\n          try {\n            const response = await fetch(\"/api/mcp/connect\", {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({\n                serverConfig: result.serverConfig,\n              }),\n            });\n\n            const connectionResult = await response.json();\n\n            if (connectionResult.success) {\n              setAppState((prev) => ({\n                ...prev,\n                servers: {\n                  ...prev.servers,\n                  [serverName]: {\n                    ...prev.servers[serverName],\n                    connectionStatus: \"connected\" as const,\n                    lastConnectionTime: new Date(),\n                    lastError: undefined,\n                  },\n                },\n              }));\n\n              logger.info(\"OAuth connection successful\", { serverName });\n              toast.success(\n                `OAuth connection successful! Connected to ${serverName}.`,\n              );\n            } else {\n              setAppState((prev) => ({\n                ...prev,\n                servers: {\n                  ...prev.servers,\n                  [serverName]: {\n                    ...prev.servers[serverName],\n                    connectionStatus: \"failed\" as const,\n                    lastError:\n                      connectionResult.error ||\n                      \"Connection test failed after OAuth\",\n                  },\n                },\n              }));\n\n              logger.error(\"OAuth connection test failed\", {\n                serverName,\n                error: connectionResult.error,\n              });\n              toast.error(\n                `OAuth succeeded but connection test failed: ${connectionResult.error}`,\n              );\n            }\n          } catch (connectionError) {\n            const errorMessage =\n              connectionError instanceof Error\n                ? connectionError.message\n                : \"Unknown connection error\";\n\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  ...prev.servers[serverName],\n                  connectionStatus: \"failed\" as const,\n                  lastError: errorMessage,\n                },\n              },\n            }));\n\n            logger.error(\"OAuth connection test error\", {\n              serverName,\n              error: errorMessage,\n            });\n            toast.error(\n              `OAuth succeeded but connection test failed: ${errorMessage}`,\n            );\n          }\n        } else {\n          throw new Error(result.error || \"OAuth callback failed\");\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n        toast.error(`Error completing OAuth flow: ${errorMessage}`);\n        logger.error(\"OAuth callback failed\", { error: errorMessage });\n      }\n    },\n    [appState.servers, logger],\n  );\n\n  const getValidAccessToken = useCallback(\n    async (serverName: string): Promise<string | null> => {\n      const server = appState.servers[serverName];\n      if (!server?.oauthTokens) {\n        return null;\n      }\n\n      // The SDK handles token refresh automatically\n      return server.oauthTokens.access_token || null;\n    },\n    [appState.servers],\n  );\n\n  const handleDisconnect = useCallback(async (serverName: string) => {\n    logger.info(\"Disconnecting from server\", { serverName });\n\n    // Clear OAuth data\n    clearOAuthData(serverName);\n\n    // Remove server from state (no API call needed for stateless architecture)\n    setAppState((prev: AppState) => {\n      const newServers = { ...prev.servers };\n      delete newServers[serverName];\n\n      return {\n        ...prev,\n        servers: newServers,\n        selectedServer:\n          prev.selectedServer === serverName ? \"none\" : prev.selectedServer,\n        selectedMultipleServers: prev.selectedMultipleServers.filter(\n          (name) => name !== serverName,\n        ),\n      };\n    });\n  }, []);\n\n  const handleReconnect = useCallback(\n    async (serverName: string) => {\n      logger.info(\"Reconnecting to server\", { serverName });\n\n      const server = appState.servers[serverName];\n      if (!server) {\n        throw new Error(`Server ${serverName} not found`);\n      }\n\n      // Update status to connecting\n      setAppState((prev) => ({\n        ...prev,\n        servers: {\n          ...prev.servers,\n          [serverName]: {\n            ...server,\n            connectionStatus: \"connecting\" as const,\n          },\n        },\n      }));\n\n      try {\n        let serverConfig = server.config;\n\n        // If server has OAuth tokens, try to refresh them\n        if (server.oauthTokens) {\n          logger.info(\"Attempting to refresh OAuth tokens\", { serverName });\n          const refreshResult = await refreshOAuthTokens(serverName);\n\n          if (refreshResult.success && refreshResult.serverConfig) {\n            logger.info(\"OAuth tokens refreshed successfully\", { serverName });\n            serverConfig = refreshResult.serverConfig;\n\n            // Update server state with refreshed config and tokens\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [serverName]: {\n                  ...prev.servers[serverName],\n                  config: refreshResult.serverConfig!,\n                  oauthTokens: getStoredTokens(serverName),\n                },\n              },\n            }));\n          } else {\n            logger.warn(\n              \"OAuth token refresh failed, attempting with existing tokens\",\n              {\n                serverName,\n                error: refreshResult.error,\n              },\n            );\n          }\n        }\n\n        // Test connection using the stateless endpoint\n        const response = await fetch(\"/api/mcp/connect\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            serverConfig,\n          }),\n        });\n\n        const result = await response.json();\n\n        if (result.success) {\n          // Update status to connected and reset retry count\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [serverName]: {\n                ...prev.servers[serverName],\n                connectionStatus: \"connected\" as const,\n                lastConnectionTime: new Date(),\n                retryCount: 0,\n                lastError: undefined,\n              },\n            },\n          }));\n          logger.info(\"Reconnection successful\", {\n            serverName,\n            result,\n          });\n          return { success: true };\n        } else {\n          // Update status to failed and increment retry count\n          setAppState((prev) => ({\n            ...prev,\n            servers: {\n              ...prev.servers,\n              [serverName]: {\n                ...prev.servers[serverName],\n                connectionStatus: \"failed\" as const,\n                retryCount: prev.servers[serverName].retryCount + 1,\n                lastError: result.error || \"Connection test failed\",\n              },\n            },\n          }));\n          logger.error(\"Reconnection failed\", {\n            serverName,\n            result,\n          });\n          toast.error(`Failed to connect: ${serverName}`);\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n\n        // Update status to failed and increment retry count\n        setAppState((prev) => ({\n          ...prev,\n          servers: {\n            ...prev.servers,\n            [serverName]: {\n              ...prev.servers[serverName],\n              connectionStatus: \"failed\" as const,\n              retryCount: prev.servers[serverName].retryCount + 1,\n              lastError: errorMessage,\n            },\n          },\n        }));\n        logger.error(\"Reconnection failed\", {\n          serverName,\n          error: errorMessage,\n        });\n        throw error;\n      }\n    },\n    [appState.servers],\n  );\n\n  // Effect to handle cleanup of reconnection timeouts (automatic retries disabled)\n  useEffect(() => {\n    // Cleanup timeouts for servers that are no longer failed or have been removed\n    Object.keys(reconnectionTimeouts).forEach((serverName) => {\n      const server = appState.servers[serverName];\n      if (!server || server.connectionStatus !== \"failed\") {\n        clearTimeout(reconnectionTimeouts[serverName]);\n        setReconnectionTimeouts((prev) => {\n          const newTimeouts = { ...prev };\n          delete newTimeouts[serverName];\n          return newTimeouts;\n        });\n      }\n    });\n  }, [appState.servers, reconnectionTimeouts]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      Object.values(reconnectionTimeouts).forEach(clearTimeout);\n    };\n  }, [reconnectionTimeouts]);\n\n  const setSelectedServer = useCallback((serverName: string) => {\n    setAppState((prev) => ({\n      ...prev,\n      selectedServer: serverName,\n    }));\n  }, []);\n\n  const setSelectedMCPConfigs = useCallback((serverNames: string[]) => {\n    setAppState((prev) => ({\n      ...prev,\n      selectedMCPConfigs: serverNames,\n    }));\n  }, []);\n\n  const toggleMultiSelectMode = useCallback((enabled: boolean) => {\n    setAppState((prev) => ({\n      ...prev,\n      isMultiSelectMode: enabled,\n      // Reset selections when switching modes\n      selectedMultipleServers: enabled ? [] : prev.selectedMultipleServers,\n    }));\n  }, []);\n\n  const toggleServerSelection = useCallback((serverName: string) => {\n    setAppState((prev) => {\n      const currentSelected = prev.selectedMultipleServers;\n      const isSelected = currentSelected.includes(serverName);\n\n      return {\n        ...prev,\n        selectedMultipleServers: isSelected\n          ? currentSelected.filter((name) => name !== serverName)\n          : [...currentSelected, serverName],\n      };\n    });\n  }, []);\n\n  const handleUpdate = useCallback(\n    async (originalServerName: string, formData: ServerFormData) => {\n      console.log(\"handleUpdateFormData\", formData);\n\n      const originalServer = appState.servers[originalServerName];\n      const hadOAuthTokens = originalServer?.oauthTokens != null;\n\n      // For OAuth servers, preserve the tokens if the server name and URL haven't changed\n      // and the user is still using OAuth authentication\n      const shouldPreserveOAuth =\n        hadOAuthTokens &&\n        formData.useOAuth &&\n        formData.name === originalServerName &&\n        formData.type === \"http\" &&\n        formData.url === originalServer.config.url?.toString();\n\n      if (shouldPreserveOAuth) {\n        // Update server config without disconnecting to preserve OAuth tokens\n        const mcpConfig = convertFormToMCPConfig(formData);\n\n        // Update the server configuration in place\n        setAppState((prev) => ({\n          ...prev,\n          servers: {\n            ...prev.servers,\n            [originalServerName]: {\n              ...prev.servers[originalServerName],\n              config: mcpConfig,\n              connectionStatus: \"connecting\" as const,\n            },\n          },\n        }));\n\n        // Test connection with existing OAuth tokens\n        try {\n          const response = await fetch(\"/api/mcp/connect\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              serverConfig: originalServer.config, // Use original config with OAuth tokens\n            }),\n          });\n\n          const result = await response.json();\n\n          if (result.success) {\n            setAppState((prev) => ({\n              ...prev,\n              servers: {\n                ...prev.servers,\n                [originalServerName]: {\n                  ...prev.servers[originalServerName],\n                  config: mcpConfig, // Now update to new config\n                  connectionStatus: \"connected\" as const,\n                  lastConnectionTime: new Date(),\n                  retryCount: 0,\n                  lastError: undefined,\n                },\n              },\n            }));\n            toast.success(\"Server configuration updated successfully!\");\n            return;\n          } else {\n            // Connection failed, fall back to full reconnect\n            console.warn(\n              \"OAuth connection test failed, falling back to full reconnect\",\n            );\n          }\n        } catch (error) {\n          console.warn(\n            \"OAuth connection test error, falling back to full reconnect\",\n            error,\n          );\n        }\n      }\n\n      // Full disconnect and reconnect for non-OAuth or when preservation fails\n      // First, disconnect the original server\n      await handleDisconnect(originalServerName);\n\n      // Then connect with the new configuration\n      await handleConnect(formData);\n\n      // If the server name changed, update selected server\n      if (\n        appState.selectedServer === originalServerName &&\n        formData.name !== originalServerName\n      ) {\n        setSelectedServer(formData.name);\n      }\n    },\n    [\n      appState.servers,\n      appState.selectedServer,\n      convertFormToMCPConfig,\n      handleDisconnect,\n      handleConnect,\n      setSelectedServer,\n    ],\n  );\n\n  return {\n    // State\n    appState,\n    isLoading,\n\n    // Computed values\n    connectedServerConfigs: appState.servers,\n    selectedServerEntry: appState.servers[appState.selectedServer],\n    selectedMCPConfig: appState.servers[appState.selectedServer]?.config,\n    selectedMCPConfigs: appState.selectedMultipleServers\n      .map((name) => appState.servers[name])\n      .filter(Boolean),\n    selectedMCPConfigsMap: appState.selectedMultipleServers.reduce(\n      (acc, name) => {\n        if (appState.servers[name]) {\n          acc[name] = appState.servers[name].config;\n        }\n        return acc;\n      },\n      {} as Record<string, MastraMCPServerDefinition>,\n    ),\n    isMultiSelectMode: appState.isMultiSelectMode,\n\n    // Actions\n    handleConnect,\n    handleDisconnect,\n    handleReconnect,\n    handleUpdate,\n    setSelectedServer,\n    setSelectedMCPConfigs,\n    toggleMultiSelectMode,\n    toggleServerSelection,\n    getValidAccessToken,\n    setSelectedMultipleServersToAllServers,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2578, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/server/server-actions.ts"],"sourcesContent":["\"use server\";\n\nimport { cookies } from \"next/headers\";\n\nexport async function getValueFromCookie(\n  key: string,\n): Promise<string | undefined> {\n  const cookieStore = await cookies();\n  return cookieStore.get(key)?.value;\n}\n\nexport async function setValueToCookie(\n  key: string,\n  value: string,\n  options: { path?: string; maxAge?: number } = {},\n): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.set(key, value, {\n    path: options.path ?? \"/\",\n    maxAge: options.maxAge ?? 60 * 60 * 24 * 7, // default: 7 days\n  });\n}\n\nexport async function getPreference<T extends string>(\n  key: string,\n  allowed: readonly T[],\n  fallback: T,\n): Promise<T> {\n  const cookieStore = await cookies();\n  const cookie = cookieStore.get(key);\n  const value = cookie ? cookie.value.trim() : undefined;\n  return allowed.includes(value as T) ? (value as T) : fallback;\n}\n"],"names":[],"mappings":";;;;;;IAWsB,mBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 2594, "column": 0}, "map": {"version":3,"sources":["file:///Users/marcelo/mcpjam-inspector/src/app/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\n\nimport { ServersTab } from \"@/components/ServersTab\";\nimport { ToolsTab } from \"@/components/ToolsTab\";\nimport { ResourcesTab } from \"@/components/ResourcesTab\";\nimport { PromptsTab } from \"@/components/PromptsTab\";\nimport { ChatTab } from \"@/components/ChatTab\";\nimport { SettingsTab } from \"@/components/SettingsTab\";\nimport { TracingTab } from \"@/components/TracingTab\";\nimport { MCPSidebar } from \"@/components/mcp-sidebar\";\nimport { ActiveServerSelector } from \"@/components/ActiveServerSelector\";\nimport {\n  SidebarInset,\n  SidebarProvider,\n  SidebarTrigger,\n} from \"@/components/ui/sidebar\";\nimport { ThemeSwitcher } from \"@/components/sidebar/theme-switcher\";\n// import { AccountSwitcher } from \"@/components/sidebar/account-switcher\";\nimport { useAppState } from \"@/hooks/use-app-state\";\n\n// const users = [\n//   {\n//     id: \"1\",\n//     name: \"MCP Inspector\",\n//     email: \"inspector@example.com\",\n//     avatar: \"/avatars/shadcn.jpg\",\n//     role: \"Inspector\",\n//   },\n// ] as const;\n\nexport default function Home() {\n  const [activeTab, setActiveTab] = useState(\"servers\");\n\n  const {\n    appState,\n    isLoading,\n    connectedServerConfigs,\n    selectedMCPConfig,\n    handleConnect,\n    handleDisconnect,\n    handleReconnect,\n    handleUpdate,\n    setSelectedServer,\n    toggleServerSelection,\n    selectedMCPConfigsMap,\n    setSelectedMultipleServersToAllServers,\n  } = useAppState();\n\n  const handleNavigate = (section: string) => {\n    setActiveTab(section);\n    if (section === \"chat\") {\n      setSelectedMultipleServersToAllServers();\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"min-h-screen bg-background flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto\"></div>\n          <p className=\"mt-4 text-muted-foreground\">Loading...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <SidebarProvider defaultOpen={true}>\n      <MCPSidebar onNavigate={handleNavigate} activeTab={activeTab} />\n      <SidebarInset className=\"flex flex-col\">\n        <header className=\"flex h-12 shrink-0 items-center gap-2 border-b transition-[width,height] ease-linear\">\n          <div className=\"flex w-full items-center justify-between px-4 lg:px-6\">\n            <div className=\"flex items-center gap-1 lg:gap-2\">\n              <SidebarTrigger className=\"-ml-1\" />\n            </div>\n            <div className=\"flex items-center gap-2\">\n              <ThemeSwitcher />\n              {/* <AccountSwitcher users={users} /> */}\n            </div>\n          </div>\n        </header>\n\n        <div className=\"flex-1\">\n          {/* Active Server Selector - Only show on Tools, Resources, and Prompts pages */}\n          {(activeTab === \"tools\" ||\n            activeTab === \"resources\" ||\n            activeTab === \"prompts\" ||\n            activeTab === \"chat\") && (\n            <ActiveServerSelector\n              connectedServerConfigs={connectedServerConfigs}\n              selectedServer={appState.selectedServer}\n              onServerChange={setSelectedServer}\n              onConnect={handleConnect}\n              isMultiSelectEnabled={activeTab === \"chat\"}\n              onMultiServerToggle={toggleServerSelection}\n              selectedMultipleServers={appState.selectedMultipleServers}\n            />\n          )}\n\n          {/* Content Areas */}\n          {activeTab === \"servers\" && (\n            <ServersTab\n              connectedServerConfigs={connectedServerConfigs}\n              onConnect={handleConnect}\n              onDisconnect={handleDisconnect}\n              onReconnect={handleReconnect}\n              onUpdate={handleUpdate}\n            />\n          )}\n\n          {activeTab === \"tools\" && (\n            <ToolsTab serverConfig={selectedMCPConfig} />\n          )}\n\n          {activeTab === \"resources\" && (\n            <ResourcesTab serverConfig={selectedMCPConfig} />\n          )}\n\n          {activeTab === \"prompts\" && (\n            <PromptsTab serverConfig={selectedMCPConfig} />\n          )}\n\n          {activeTab === \"chat\" && (\n            <ChatTab serverConfigs={selectedMCPConfigsMap} />\n          )}\n\n          {activeTab === \"tracing\" && <TracingTab />}\n\n          {activeTab === \"settings\" && <SettingsTab />}\n        </div>\n      </SidebarInset>\n    </SidebarProvider>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA,2EAA2E;AAC3E;;;AApBA;;;;;;;;;;;;;;AAgCe,SAAS;;IACtB,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAE3C,MAAM,EACJ,QAAQ,EACR,SAAS,EACT,sBAAsB,EACtB,iBAAiB,EACjB,aAAa,EACb,gBAAgB,EAChB,eAAe,EACf,YAAY,EACZ,iBAAiB,EACjB,qBAAqB,EACrB,qBAAqB,EACrB,sCAAsC,EACvC,GAAG,CAAA,GAAA,sIAAA,CAAA,cAAW,AAAD;IAEd,MAAM,iBAAiB,CAAC;QACtB,aAAa;QACb,IAAI,YAAY,QAAQ;YACtB;QACF;IACF;IAEA,IAAI,WAAW;QACb,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAI,WAAU;;;;;;kCACf,6LAAC;wBAAE,WAAU;kCAA6B;;;;;;;;;;;;;;;;;IAIlD;IAEA,qBACE,6LAAC,sIAAA,CAAA,kBAAe;QAAC,aAAa;;0BAC5B,6LAAC,uIAAA,CAAA,aAAU;gBAAC,YAAY;gBAAgB,WAAW;;;;;;0BACnD,6LAAC,sIAAA,CAAA,eAAY;gBAAC,WAAU;;kCACtB,6LAAC;wBAAO,WAAU;kCAChB,cAAA,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAI,WAAU;8CACb,cAAA,6LAAC,sIAAA,CAAA,iBAAc;wCAAC,WAAU;;;;;;;;;;;8CAE5B,6LAAC;oCAAI,WAAU;8CACb,cAAA,6LAAC,qJAAA,CAAA,gBAAa;;;;;;;;;;;;;;;;;;;;;kCAMpB,6LAAC;wBAAI,WAAU;;4BAEZ,CAAC,cAAc,WACd,cAAc,eACd,cAAc,aACd,cAAc,MAAM,mBACpB,6LAAC,6IAAA,CAAA,uBAAoB;gCACnB,wBAAwB;gCACxB,gBAAgB,SAAS,cAAc;gCACvC,gBAAgB;gCAChB,WAAW;gCACX,sBAAsB,cAAc;gCACpC,qBAAqB;gCACrB,yBAAyB,SAAS,uBAAuB;;;;;;4BAK5D,cAAc,2BACb,6LAAC,mIAAA,CAAA,aAAU;gCACT,wBAAwB;gCACxB,WAAW;gCACX,cAAc;gCACd,aAAa;gCACb,UAAU;;;;;;4BAIb,cAAc,yBACb,6LAAC,iIAAA,CAAA,WAAQ;gCAAC,cAAc;;;;;;4BAGzB,cAAc,6BACb,6LAAC,qIAAA,CAAA,eAAY;gCAAC,cAAc;;;;;;4BAG7B,cAAc,2BACb,6LAAC,mIAAA,CAAA,aAAU;gCAAC,cAAc;;;;;;4BAG3B,cAAc,wBACb,6LAAC,gIAAA,CAAA,UAAO;gCAAC,eAAe;;;;;;4BAGzB,cAAc,2BAAa,6LAAC,mIAAA,CAAA,aAAU;;;;;4BAEtC,cAAc,4BAAc,6LAAC,oIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;;;;;;;;AAKnD;GAvGwB;;QAgBlB,sIAAA,CAAA,cAAW;;;KAhBO","debugId":null}}]
}